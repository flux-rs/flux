<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Use - Flux Documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../css/flux.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Flux Documentation</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="users-guide"><a class="header" href="#users-guide">User's Guide</a></h1>
<p>One day, this will be an actual user's guide.</p>
<p>For now, it is a collection of various <code>flux</code> features as illustrated by examples from the regression tests.</p>
<h2 id="index-refinements"><a class="header" href="#index-refinements">Index Refinements</a></h2>
<p>Of the form <code>i32[e]</code> (<code>i32</code> equal to <code>e</code>) values.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn(bool[true]))]
pub fn assert(_b: bool) {}

pub fn test00() {
    let x = 1;
    let y = 2;
    assert(x + 1 == y);
}

#[flux::sig(fn five() -&gt; usize[5])]
pub fn five() -&gt; usize {
    let x = 2;
    let y = 3;
    x + y
}

#[flux::sig(fn(n:usize) -&gt; usize[n+1])]
pub fn incr(n: usize) -&gt; usize {
    n + 1
}

pub fn test01() {
    let a = five();
    let b = incr(a);
    assert(b == 6);
}
<span class="boring">}</span></code></pre></pre>
<p><strong>NOTE:</strong> We use the <code>sig(..)</code> annotation to specify the refinement type of a function;
you can optionally also add the <em>name</em> of the function as shown for <code>fn five</code>.</p>
<h2 id="existential-refinements"><a class="header" href="#existential-refinements">Existential Refinements</a></h2>
<p>Of the form <code>i32{v: 0 &lt;= v}</code> (non-negative <code>i32</code>) values.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn(x:i32) -&gt; i32{v: v &gt; x})]
pub fn inc(x: i32) -&gt; i32 {
    x + 1
}

#[flux::sig(fn(x:i32) -&gt; i32{v: v &lt; x})]
pub fn dec(x: i32) -&gt; i32 {
    x - 1
}
<span class="boring">}</span></code></pre></pre>
<h2 id="combining-index-and-existential-refinements"><a class="header" href="#combining-index-and-existential-refinements">Combining Index and Existential Refinements</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn(k: i32{0 &lt;= k}) -&gt; i32[0])]
pub fn test(mut k: i32) -&gt; i32 {
    while toss() &amp;&amp; k &lt; i32::MAX - 1 {
        k += 1;
    }
    while k &gt; 0 {
        k -= 1;
    }
    k
}
<span class="boring">}</span></code></pre></pre>
<h2 id="mutable-references"><a class="header" href="#mutable-references">Mutable References</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn(x: &amp;mut i32{v: 0 &lt;= v}))]
pub fn test4(x: &amp;mut i32) {
    *x += 1;
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn(x: &amp;mut i32{v: 0 &lt;= v}))]
pub fn test4(x: &amp;mut i32) {
    *x -= 1; //~ ERROR assignment might be unsafe
}
<span class="boring">}</span></code></pre></pre>
<h2 id="strong-references"><a class="header" href="#strong-references">Strong References</a></h2>
<p>Like <code>&amp;mut T</code> but which allow <em>strong updates</em> via <code>ensures</code> clauses</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn(x: &amp;strg i32[@n]) ensures x: i32[n+1])]
pub fn inc(x: &amp;mut i32) {
    *x += 1;
}

#[flux::sig(fn() -&gt; i32[1])]
pub fn test_inc() -&gt; i32 {
    let mut x = 0;
    inc(&amp;mut x);
    x
}
<span class="boring">}</span></code></pre></pre>
<h2 id="mixing-mutable-and-strong-references"><a class="header" href="#mixing-mutable-and-strong-references">Mixing Mutable and Strong References</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn (x: &amp;strg i32[@n]) ensures x: i32[n+1])]
pub fn incr(x: &amp;mut i32) {
    *x += 1;
}

#[flux::sig(fn (x: &amp;mut i32{v: 0&lt;=v}))]
pub fn client_safe(z: &amp;mut i32) {
    incr(z);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="refined-arrays"><a class="header" href="#refined-arrays">Refined Arrays</a></h2>
<p><code>flux</code> supports <em>refined arrays</em> of the form <code>[i32{v: 0 &lt;= v}; 20]</code>
denoting arrays of size <code>20</code> of non-negative <code>i32</code> values.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn() -&gt; [i32{v : v &gt;= 0}; 2])]
pub fn array00() -&gt; [i32; 2] {
    [0, 1]
}

pub fn read_u16() -&gt; u16 {
    let bytes: [u8; 2] = [10, 20];
    u16::from_le_bytes(bytes)
}

#[flux::sig(fn() -&gt; i32{v : v &gt; 10})]
pub fn write() -&gt; i32 {
    let bytes: [i32; 2] = [10, 20];
    bytes[0] + bytes[1]
}
<span class="boring">}</span></code></pre></pre>
<h2 id="refined-vectors-rvec"><a class="header" href="#refined-vectors-rvec">Refined Vectors <code>rvec</code></a></h2>
<p><code>RVec</code> specification</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![allow(dead_code)]

<span class="boring">fn main() {
</span>pub mod rslice;

#[macro_export]
macro_rules! rvec {
    () =&gt; { RVec::new() };
    ($($e:expr),+$(,)?) =&gt; {{
        let mut res = RVec::new();
        $( res.push($e); )*
        res
    }};
    ($elem:expr; $n:expr) =&gt; {{
        RVec::from_elem_n($elem, $n)
    }}
}

#[flux::opaque]
#[flux::refined_by(len: int)]
#[flux::invariant(0 &lt;= len)]
pub struct RVec&lt;T&gt; {
    inner: Vec&lt;T&gt;,
}

impl&lt;T&gt; RVec&lt;T&gt; {
    #[flux::trusted]
    #[flux::sig(fn() -&gt; RVec&lt;T&gt;[0])]
    pub fn new() -&gt; Self {
        Self { inner: Vec::new() }
    }

    #[flux::trusted]
    #[flux::sig(fn(self: &amp;strg RVec&lt;T&gt;[@n], T) ensures self: RVec&lt;T&gt;[n+1])]
    pub fn push(&amp;mut self, item: T) {
        self.inner.push(item);
    }

    #[flux::trusted]
    #[flux::sig(fn(&amp;RVec&lt;T&gt;[@n]) -&gt; usize[n])]
    pub fn len(&amp;self) -&gt; usize {
        self.inner.len()
    }

    #[flux::trusted]
    #[flux::sig(fn(&amp;RVec&lt;T&gt;[@n]) -&gt; bool[n == 0])]
    pub fn is_empty(&amp;self) -&gt; bool {
        self.inner.is_empty()
    }

    #[flux::trusted]
    #[flux::sig(fn(&amp;RVec&lt;T&gt;[@n], i: usize{i &lt; n}) -&gt; &amp;T)]
    pub fn get(&amp;self, i: usize) -&gt; &amp;T {
        &amp;self.inner[i]
    }

    #[flux::trusted]
    #[flux::sig(fn(&amp;mut RVec&lt;T&gt;[@n], i: usize{i &lt; n}) -&gt; &amp;mut T)]
    pub fn get_mut(&amp;mut self, i: usize) -&gt; &amp;mut T {
        &amp;mut self.inner[i]
    }

    #[flux::trusted]
    #[flux::sig(fn(self: &amp;strg RVec&lt;T&gt;[@n]) -&gt; T
    		requires n &gt; 0
            ensures self: RVec&lt;T&gt;[n-1])]
    pub fn pop(&amp;mut self) -&gt; T {
        self.inner.pop().unwrap()
    }

    #[flux::trusted]
    #[flux::sig(fn(&amp;mut RVec&lt;T&gt;[@n], a: usize{a &lt; n}, b: usize{b &lt; n}))]
    pub fn swap(&amp;mut self, a: usize, b: usize) {
        self.inner.swap(a, b);
    }

    #[flux::trusted]
    #[flux::sig(fn(&amp;mut RVec&lt;T&gt;[@n]) -&gt; &amp;mut [T][n])]
    pub fn as_mut_slice(&amp;mut self) -&gt; &amp;mut [T] {
        self.inner.as_mut_slice()
    }

    #[flux::trusted]
    #[flux::sig(fn(arr:_) -&gt; RVec&lt;T&gt;[N])]
    pub fn from_array&lt;const N: usize&gt;(arr: [T; N]) -&gt; Self {
        Self { inner: Vec::from(arr) }
    }

    #[flux::trusted]
    #[flux::sig(fn(xs:&amp;[T][@n]) -&gt; RVec&lt;T&gt;[n])]
    pub fn from_slice(xs: &amp;[T]) -&gt; Self
    where
        T: Clone,
    {
        Self { inner: Vec::from(xs) }
    }

    #[flux::trusted]
    #[flux::sig(fn(T, n: usize) -&gt; RVec&lt;T&gt;[n])]
    pub fn from_elem_n(elem: T, n: usize) -&gt; Self
    where
        T: Copy,
    {
        let mut vec = Self::new();
        let mut i = 0;
        while i &lt; n {
            vec.push(elem);
            i += 1;
        }
        vec
    }

    #[flux::trusted]
    #[flux::sig(fn(&amp;RVec&lt;T&gt;[@n]) -&gt; RVec&lt;T&gt;[n])]
    pub fn clone(&amp;self) -&gt; Self
    where
        T: Clone,
    {
        Self { inner: self.inner.clone() }
    }

    #[flux::trusted]
    #[flux::sig(fn(self: &amp;strg RVec&lt;T&gt;[@n], other: &amp;[T][@m]) ensures self: RVec&lt;T&gt;[n + m])]
    pub fn extend_from_slice(&amp;mut self, other: &amp;[T])
    where
        T: Clone,
    {
        self.inner.extend_from_slice(other)
    }

    #[flux::trusted]
    #[flux::sig(fn (&amp;RVec&lt;T&gt;[@n], F) -&gt; RVec&lt;U&gt;[n])]
    pub fn map&lt;U, F&gt;(&amp;self, f: F) -&gt; RVec&lt;U&gt;
    where
        F: Fn(&amp;T) -&gt; U,
    {
        RVec { inner: self.inner.iter().map(f).collect() }
    }

    #[flux::trusted]
    pub fn fold&lt;B, F&gt;(&amp;self, init: B, f: F) -&gt; B
    where
        F: FnMut(B, &amp;T) -&gt; B,
    {
        self.inner.iter().fold(init, f)
    }
}

#[flux::opaque]
pub struct RVecIter&lt;T&gt; {
    vec: RVec&lt;T&gt;,
    curr: usize,
}

impl&lt;T&gt; IntoIterator for RVec&lt;T&gt; {
    type Item = T;
    type IntoIter = RVecIter&lt;T&gt;;

    // TODO: cannot get variant of opaque struct
    #[flux::trusted]
    #[flux::sig(fn(RVec&lt;T&gt;) -&gt; RVecIter&lt;T&gt;)]
    fn into_iter(self) -&gt; RVecIter&lt;T&gt; {
        RVecIter { vec: self, curr: 0 }
    }
}

impl&lt;T&gt; Iterator for RVecIter&lt;T&gt; {
    type Item = T;

    // TODO: cannot get variant of opaque struct
    #[flux::trusted]
    #[flux::sig(fn(&amp;mut RVecIter&lt;T&gt;) -&gt; Option&lt;T&gt;)]
    fn next(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.vec.inner.pop()
    }
}

impl&lt;T&gt; std::ops::Index&lt;usize&gt; for RVec&lt;T&gt; {
    type Output = T;

    #[flux::trusted_impl]
    #[flux::sig(fn(&amp;RVec&lt;T&gt;[@n], usize{v : v &lt; n}) -&gt; &amp;T)]
    fn index(&amp;self, index: usize) -&gt; &amp;T {
        self.get(index)
    }
}

impl&lt;T&gt; std::ops::IndexMut&lt;usize&gt; for RVec&lt;T&gt; {
    #[flux::trusted_impl]
    #[flux::sig(fn(&amp;mut RVec&lt;T&gt;[@n], usize{v : v &lt; n}) -&gt; &amp;mut T)]
    fn index_mut(&amp;mut self, index: usize) -&gt; &amp;mut T {
        self.get_mut(index)
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>RVec</code> clients</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[path = "../../lib/rvec.rs"]
mod rvec;
use rvec::RVec;

#[flux::sig(fn() -&gt; RVec&lt;i32&gt;[0])]
pub fn test0() -&gt; RVec&lt;i32&gt; {
    let mv = rvec![];
    mv
}

#[flux::sig(fn() -&gt; RVec&lt;i32&gt;[5])]
pub fn test1() -&gt; RVec&lt;i32&gt; {
    rvec![ 12; 5 ]
}

#[flux::sig(fn(n:usize) -&gt; RVec&lt;i32&gt;[n])]
pub fn test2(n: usize) -&gt; RVec&lt;i32&gt; {
    rvec![ 12; n ]
}

pub fn test3() -&gt; usize {
    let v = rvec![0, 1];
    let r = v[0];
    let r = r + v[1];
    r
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Binary Search</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![allow(unused_attributes)]

<span class="boring">fn main() {
</span>#[path = "../../lib/rvec.rs"]
pub mod rvec;
use rvec::RVec;

// CREDIT: https://shane-o.dev/blog/binary-search-rust

#[flux::sig(fn(i32, &amp;RVec&lt;i32&gt;) -&gt; usize)]
pub fn binary_search(k: i32, items: &amp;RVec&lt;i32&gt;) -&gt; usize {
    let size = items.len();
    if size &lt;= 0 {
        return size;
    }

    let mut low: usize = 0;
    let mut high: usize = size - 1;

    while low &lt;= high {
        // SAFE   let middle = (high + low) / 2;
        // UNSAFE let middle = high + ((high - low) / 2);
        let middle = low + ((high - low) / 2);
        let current = items[middle];
        if current == k {
            return middle;
        }
        if current &gt; k {
            if middle == 0 {
                return size;
            }
            high = middle - 1
        }
        if current &lt; k {
            low = middle + 1
        }
    }
    size
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Heapsort</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[path = "../../lib/rvec.rs"]
mod rvec;
use rvec::RVec;

#[flux::sig(fn(&amp;mut RVec&lt;i32&gt;[@n]) -&gt; i32)]
pub fn heap_sort(vec: &amp;mut RVec&lt;i32&gt;) -&gt; i32 {
    let len = vec.len();

    if len &lt;= 0 {
        return 0;
    }

    let mut start = len / 2;
    while start &gt; 0 {
        start -= 1;
        shift_down(vec, start, len - 1);
    }

    let mut end = len;
    while end &gt; 1 {
        end -= 1;
        vec.swap(0, end);
        shift_down(vec, 0, end - 1);
    }
    0
}

#[flux::sig(fn(&amp;mut RVec&lt;i32&gt;[@len], usize{v : v &lt; len}, usize{v : v &lt; len}) -&gt; i32)]
pub fn shift_down(vec: &amp;mut RVec&lt;i32&gt;, start: usize, end: usize) -&gt; i32 {
    let mut root = start;
    loop {
        let mut child = root * 2 + 1;
        if child &gt; end {
            break;
        } else {
            if child + 1 &lt;= end {
                let a = vec[child];
                let b = vec[child + 1];
                if a &lt; b {
                    child += 1;
                }
            }
            let a = vec[root];
            let b = vec[child];
            if a &lt; b {
                vec.swap(root, child);
                root = child;
            } else {
                break;
            }
        }
    }
    0
}
<span class="boring">}</span></code></pre></pre>
<h2 id="refined-slices"><a class="header" href="#refined-slices">Refined Slices</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn(&amp;[i32{v : v &gt; 0}]) -&gt; &amp;[i32{v : v &gt;= 0}])]
fn first_half(slice: &amp;[i32]) -&gt; &amp;[i32] {
    let mid = slice.len() / 2;
    let (fst, snd) = slice.split_at(mid);
    fst
}

#[flux::sig(fn(&amp;[i32{v : v &gt; 0}]) -&gt; Option&lt;&amp;i32{v : v &gt;= 0}&gt;)]
fn first(slice: &amp;[i32]) -&gt; Option&lt;&amp;i32&gt; {
    slice.first()
}

#[flux::sig(fn(&amp;mut [i32{v : v &gt; 0}]))]
fn inc_fst(slice: &amp;mut [i32]) {
    if let Some(x) = slice.first_mut() {
        *x += 1;
    }
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[path = "../../lib/rvec.rs"]
mod rvec;
use rvec::{RVec, rslice::RSlice};

#[flux::sig(fn(&amp;mut RVec&lt;T&gt;[10]))]
fn test00&lt;T&gt;(vec: &amp;mut RVec&lt;T&gt;) {
    let mut s = RSlice::from_vec(vec);
    let s1 = s.subslice(0, 3);
    let s2 = s.subslice(4, 5);
}

#[flux::sig(fn(&amp;mut {RVec&lt;i32&gt;[@n] | n % 2 == 0 &amp;&amp; n &gt; 0}))]
fn test01(vec: &amp;mut RVec&lt;i32&gt;) {
    let n = vec.len();
    let mut s = RSlice::from_vec(vec);
    let mut s1 = s.subslice(0, n / 2 - 1);
    let s2 = s.subslice(n / 2, n - 1);
    add(s1.as_mut_slice(), s2.as_slice())
}

#[flux::sig(fn(&amp;mut [i32][@n], &amp;[i32][n]))]
fn add(x: &amp;mut [i32], y: &amp;[i32]) {
    let mut i = 0;
    while i &lt; len(x) {
        x[i] += y[i];
    }
}

#[flux::trusted]
#[flux::sig(fn(x: &amp;[T][@n]) -&gt; usize[n])]
fn len&lt;T&gt;(x: &amp;[T]) -&gt; usize {
    x.len()
}
<span class="boring">}</span></code></pre></pre>
<h2 id="refined-vec"><a class="header" href="#refined-vec">Refined <code>Vec</code></a></h2>
<p>This uses <code>extern_spec</code> which is described in the <a href="specs.html">specifications guide</a>.</p>
<p><strong>Standalone</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(allocator_api)]

<span class="boring">fn main() {
</span>use std::alloc::{Allocator, Global};

use flux_rs::extern_spec;

#[extern_spec]
#[refined_by(len: int)]
struct Vec&lt;T, A: Allocator = Global&gt;;

#[extern_spec]
impl&lt;T&gt; Vec&lt;T&gt; {
    #[sig(fn() -&gt; Vec&lt;T&gt;[0])]
    fn new() -&gt; Vec&lt;T&gt;;
}

#[extern_spec]
impl&lt;T, A: Allocator&gt; Vec&lt;T, A&gt; {
    #[sig(fn(self: &amp;strg Vec&lt;T, A&gt;[@n], T) ensures self: Vec&lt;T, A&gt;[n+1])]
    fn push(&amp;mut self, value: T);

    #[sig(fn(&amp;Vec&lt;T, A&gt;[@n]) -&gt; usize[n])]
    fn len(&amp;self) -&gt; usize;

    #[sig(fn(&amp;Vec&lt;T, A&gt;[@n]) -&gt; bool[n == 0])]
    fn is_empty(&amp;self) -&gt; bool;
}

#[extern_spec]
impl&lt;T&gt; [T] {
    #[sig(fn(self: Box&lt;[T][@n], A&gt;) -&gt; Vec&lt;T, A&gt;[n])]
    fn into_vec&lt;A&gt;(self: Box&lt;[T], A&gt;) -&gt; Vec&lt;T, A&gt;
    where
        A: Allocator;
}

#[flux::sig(fn(bool[true]))]
fn assert(_: bool) {}

#[flux::sig(fn() -&gt; Vec&lt;i32&gt;[3])]
pub fn test_vec_macro() -&gt; Vec&lt;i32&gt; {
    vec![10, 20, 30]
}

#[flux::sig(fn() -&gt; Vec&lt;i32&gt;[3])]
pub fn test_push() -&gt; Vec&lt;i32&gt; {
    let mut res = Vec::new();
    res.push(10);
    res.push(20);
    res.push(30);
    res
}

#[flux::sig(fn() -&gt; usize[3])]
pub fn test_len() -&gt; usize {
    let res = test_push();
    res.len()
}

pub fn test_is_empty() {
    let res = test_push();
    assert(!res.is_empty())
}

// TODO: https://github.com/flux-rs/flux/issues/578
// #[flux::sig(fn (Vec&lt;i32{v:10 &lt;= v}&gt;))]
// pub fn test3(xs: Vec&lt;i32&gt;) {
//     for x in &amp;xs {
//         assert(0 &lt;= *x)
//     }
// }
<span class="boring">}</span></code></pre></pre>
<p><strong>Associated Refinements</strong> for indexing</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::{
    alloc::{Allocator, Global},
    ops::{Index, IndexMut},
    slice::{Iter, SliceIndex},
};

use flux_rs::extern_spec;

#[extern_spec]
#[flux::refined_by(len: int)]
struct Vec&lt;T, A: Allocator = Global&gt;;

#[extern_spec]
#[flux::assoc(fn in_bounds(idx: Self, v: T) -&gt; bool)]
trait SliceIndex&lt;T&gt;
where
    T: ?Sized,
{
}

#[extern_spec]
#[flux::assoc(fn in_bounds(idx: int, len: int) -&gt; bool {idx &lt; len} )]
impl&lt;T&gt; SliceIndex&lt;[T]&gt; for usize {}

#[extern_spec]
impl&lt;T, I: SliceIndex&lt;[T]&gt;, A: Allocator&gt; Index&lt;I&gt; for Vec&lt;T, A&gt; {
    #[flux::sig(fn(&amp;Vec&lt;T, A&gt;[@len], {I[@idx] | &lt;I as SliceIndex&lt;[T]&gt;&gt;::in_bounds(idx, len)}) -&gt; _)]
    fn index(z: &amp;Vec&lt;T, A&gt;, index: I) -&gt; &amp;&lt;I as SliceIndex&lt;[T]&gt;&gt;::Output;
}

#[extern_spec]
impl&lt;T, I: SliceIndex&lt;[T]&gt;, A: Allocator&gt; IndexMut&lt;I&gt; for Vec&lt;T, A&gt; {
    #[flux::sig(fn(&amp;mut Vec&lt;T,A&gt;[@len], {I[@idx] | &lt;I as SliceIndex&lt;[T]&gt;&gt;::in_bounds(idx, len)}) -&gt; _)]
    fn index_mut(z: &amp;mut Vec&lt;T, A&gt;, index: I) -&gt; &amp;mut &lt;I as SliceIndex&lt;[T]&gt;&gt;::Output;
}

//---------------------------------------------------------------------------------------

#[extern_spec]
impl&lt;T&gt; Vec&lt;T&gt; {
    #[flux::sig(fn() -&gt; Vec&lt;T&gt;[0])]
    fn new() -&gt; Vec&lt;T&gt;;
}

#[extern_spec]
impl&lt;T, A: Allocator&gt; Vec&lt;T, A&gt; {
    #[flux::sig(fn(self: &amp;strg Vec&lt;T, A&gt;[@n], T) ensures self: Vec&lt;T, A&gt;[n+1])]
    fn push(v: &amp;mut Vec&lt;T, A&gt;, value: T);

    #[flux::sig(fn(&amp;Vec&lt;T, A&gt;[@n]) -&gt; usize[n])]
    fn len(v: &amp;Vec&lt;T, A&gt;) -&gt; usize;
}

#[extern_spec]
impl&lt;'a, T, A: Allocator&gt; IntoIterator for &amp;'a Vec&lt;T, A&gt; {
    #[flux::sig(fn (&amp;Vec&lt;T, A&gt;[@n]) -&gt; &lt;&amp;Vec&lt;T, A&gt; as IntoIterator&gt;::IntoIter[0,n])]
    fn into_iter(v: &amp;'a Vec&lt;T, A&gt;) -&gt; &lt;&amp;'a Vec&lt;T, A&gt; as IntoIterator&gt;::IntoIter;
}

#[extern_spec]
#[flux::assoc(fn with_size(self: Self, n:int) -&gt; bool { self.len == n })]
impl&lt;T&gt; FromIterator&lt;T&gt; for Vec&lt;T&gt; {}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(allocator_api)]

<span class="boring">fn main() {
</span>use std::ops::Index;

#[path = "../../lib/option.rs"]
mod option;

#[path = "../../lib/slice.rs"]
mod slice;

#[path = "../../lib/vec.rs"]
mod vec;

#[path = "../../lib/iter.rs"]
mod iter;

// ---------------------------------------------------------------------------------------

pub fn test_get0(xs: &amp;Vec&lt;i32&gt;) -&gt; &amp;i32 {
    &lt;Vec&lt;i32&gt; as Index&lt;usize&gt;&gt;::index(xs, 10) //~ ERROR refinement type
}

pub fn test_get1(xs: &amp;Vec&lt;i32&gt;) -&gt; i32 {
    xs[10] //~ ERROR refinement type
}

#[flux::sig(fn (&amp;Vec&lt;i32&gt;[100]) -&gt; &amp;i32)]
pub fn test_get2(xs: &amp;Vec&lt;i32&gt;) -&gt; &amp;i32 {
    &lt;Vec&lt;i32&gt; as Index&lt;usize&gt;&gt;::index(xs, 99)
}

#[flux::sig(fn (&amp;Vec&lt;i32&gt;[100]) -&gt; i32)]
pub fn test_get3(xs: &amp;Vec&lt;i32&gt;) -&gt; i32 {
    xs[99]
}

pub fn test_set0(xs: &amp;mut Vec&lt;i32&gt;) {
    xs[10] = 100; //~ ERROR refinement type
}

#[flux::sig(fn (&amp;mut Vec&lt;i32&gt;[100]))]
pub fn test_set1(xs: &amp;mut Vec&lt;i32&gt;) {
    xs[99] = 100;
}

pub fn test1() {
    let mut xs = Vec::&lt;i32&gt;::new();
    xs.push(10);
    xs.push(20);
    xs.push(30);

    xs[0] = 100;
    xs[1] = 100;
    xs[2] = 100;
    xs[10] = 100; //~ ERROR refinement type
}

pub fn test2(xs: Vec&lt;i32&gt;, i: usize) {
    if i &lt; xs.len() {
        let _ = xs[i];
        let _ = xs[i + 1]; //~ ERROR refinement type
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="named-function-signatures"><a class="header" href="#named-function-signatures">Named Function Signatures</a></h2>
<p>You can also write <em>named</em> function signatures using the <code>spec</code>
annotation (instead of the anonymous <code>sig</code> annotation).</p>
<h2 id="requires-clauses"><a class="header" href="#requires-clauses">Requires Clauses</a></h2>
<p>Used to specify preconditions in a single spot, if needed.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[path = "../../lib/rvec.rs"]
mod rvec;
use rvec::RVec;

#[flux::sig(
    fn(&amp;mut RVec&lt;i32&gt;[@n], b:bool) -&gt; i32[0]
    requires 2 &lt;= n
)]
pub fn test1(vec: &amp;mut RVec&lt;i32&gt;, b: bool) -&gt; i32 {
    let r;
    if b {
        r = &amp;mut vec[0];
    } else {
        r = &amp;mut vec[1];
    }
    *r = 12;
    0
}
<span class="boring">}</span></code></pre></pre>
<h2 id="refining-structs"><a class="header" href="#refining-structs">Refining Structs</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![flux::defs {
<span class="boring">fn main() {
</span>    qualifier Sub2(x: int, a: int, b:int) { x == a - b }
}]
#[path = "../../lib/rvec.rs"]
pub mod rvec;

use rvec::RVec;

#[flux::refined_by(x: int, y:int)]
pub struct Pair {
    #[flux::field(i32[x])]
    pub x: i32,
    #[flux::field(i32[y])]
    pub y: i32,
}

#[flux::sig(fn(a: i32) -&gt; RVec&lt;Pair{v : v.x + v.y &lt;= a }&gt;)]
pub fn mk_pairs_with_bound(a: i32) -&gt; RVec&lt;Pair&gt; {
    let mut i = 0;
    let mut res = RVec::new();
    while i &lt; a {
        let p = Pair { x: i, y: a - i };
        res.push(p);
        i += 1;
    }
    res
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![flux::defs {
<span class="boring">fn main() {
</span>    fn is_btwn(v:int, lo:int, hi: int) -&gt; bool { lo &lt;= v &amp;&amp; v &lt;= hi }
    fn ok_day(d:int) -&gt; bool { is_btwn(d, 1, 31) }
    fn is_month30(m:int) -&gt; bool { m == 4 || m == 6 || m == 9 || m == 11 }
    fn ok_month(d:int, m:int) -&gt; bool { is_btwn(m, 1, 12) &amp;&amp; (is_month30(m) =&gt; d &lt;= 30) }
    fn is_leap_year(y:int) -&gt; bool { y % 400 == 0 || (y % 4 == 0 &amp;&amp; (y % 100) &gt; 0) }
    fn is_feb_day(d:int, y:int) -&gt; bool { d &lt;= 29 &amp;&amp; ( d == 29 =&gt; is_leap_year(y) ) }
    fn ok_year(d:int, m:int, y:int) -&gt; bool { 1 &lt;= y &amp;&amp; (m == 2 =&gt; is_feb_day(d, y)) }
}]

// https://github.com/chrisdone/sandbox/blob/master/liquid-haskell-dates.hs

#[allow(dead_code)]
#[flux::refined_by(d:int, m:int, y:int)]
pub struct Date {
    #[flux::field({ usize[d] | ok_day(d) })]
    day: usize,
    #[flux::field({ usize[m] | ok_month(d, m)})]
    month: usize,
    #[flux::field({ usize[y] | ok_year(d, m, y)})]
    year: usize,
}

pub fn test() {
    let _ok_date = Date { day: 9, month: 8, year: 1977 };
}

// TODO: Tedious to duplicate the definitions if you want to use them in rust code.
// Maybe some macro magic can unify?

#[flux::sig(fn(m:usize) -&gt; bool[is_month30(m)])]
fn is_month30(m: usize) -&gt; bool {
    m == 4 || m == 6 || m == 9 || m == 11
}

#[flux::sig(fn(y:usize) -&gt; bool[is_leap_year(y)])]
fn is_leap_year(y: usize) -&gt; bool {
    y % 400 == 0 || (y % 4 == 0 &amp;&amp; y % 100 != 0)
}

#[flux::sig(fn(d:usize, y:usize) -&gt; bool[is_feb_day(d, y)])]
fn is_feb_day(d: usize, y: usize) -&gt; bool {
    d &lt;= 29 &amp;&amp; (d != 29 || is_leap_year(y))
}

pub fn mk_date(day: usize, month: usize, year: usize) -&gt; Option&lt;Date&gt; {
    if 1 &lt;= year &amp;&amp; 1 &lt;= month &amp;&amp; month &lt;= 12 &amp;&amp; 1 &lt;= day &amp;&amp; day &lt;= 31 {
        if !is_month30(month) || day &lt;= 30 {
            if month != 2 || is_feb_day(day, year) {
                return Some(Date { day, month, year });
            }
        }
    }
    return None;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="invariants-on-structs"><a class="header" href="#invariants-on-structs">Invariants on Structs</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::refined_by(a: int, b: int)]
#[flux::invariant(a &gt; 0)]
#[flux::invariant(b &gt; 0)]
pub struct S {
    #[flux::field({i32[a] | a &gt; 0})]
    fst: i32,
    #[flux::field({i32[b] | b &gt;= a})]
    snd: i32,
}
<span class="boring">}</span></code></pre></pre>
<p>with <code>const</code> generics</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Test that const generics in invariants are properly instantiated

use flux_rs::attrs::*;

#[invariant(N &gt; 0)]
struct S&lt;const N: usize&gt; {}

#[sig(fn(_) -&gt; usize{v : v &gt; 0})]
fn foo&lt;const M: usize&gt;(x: S&lt;M&gt;) -&gt; usize {
    M
}
<span class="boring">}</span></code></pre></pre>
<h3 id="opaque-structs"><a class="header" href="#opaque-structs">Opaque Structs</a></h3>
<p>See the <a href="specs.html">specifications guide</a> for more about the <code>opaque</code> annotation.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::opaque]
#[flux::refined_by(a: int, b: int)]
#[flux::invariant(a &lt;= b)]
pub struct Range {
    a: i32,
    b: i32,
}

impl Range {
    #[flux::trusted]
    #[flux::sig(fn(a: i32, b: i32{b &gt;= a}) -&gt; Range[a, b])]
    pub fn new(a: i32, b: i32) -&gt; Range {
        Range { a, b }
    }

    #[flux::trusted]
    #[flux::sig(fn(&amp;Range[@r]) -&gt; i32[r.a])]
    pub fn fst(&amp;self) -&gt; i32 {
        self.a
    }

    #[flux::trusted]
    #[flux::sig(fn(&amp;Range[@r]) -&gt; i32[r.b])]
    pub fn snd(&amp;self) -&gt; i32 {
        self.b
    }
}

#[flux::sig(fn(Range) -&gt; bool[true])]
fn test(r: Range) -&gt; bool {
    r.snd() - r.fst() &gt;= 0
}
<span class="boring">}</span></code></pre></pre>
<h2 id="refining-enums"><a class="header" href="#refining-enums">Refining Enums</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::refined_by(b:bool)]
pub enum Opt&lt;T&gt; {
    #[flux::variant(Opt&lt;T&gt;[false])]
    None,
    #[flux::variant({T} -&gt; Opt&lt;T&gt;[true])]
    Some(T),
}

#[flux::sig(fn(Opt&lt;T&gt;[@b]) -&gt; bool[b])]
pub fn is_some&lt;T&gt;(x: Opt&lt;T&gt;) -&gt; bool {
    match x {
        Opt::None =&gt; false,
        Opt::Some(_) =&gt; true,
    }
}

#[flux::sig(fn(Opt&lt;T&gt;[@b]) -&gt; bool[b])]
pub fn is_some_flip&lt;T&gt;(x: Opt&lt;T&gt;) -&gt; bool {
    match x {
        Opt::Some(_) =&gt; true,
        Opt::None =&gt; false,
    }
}

#[flux::sig(fn(i32{v:false}) -&gt; T)]
pub fn never&lt;T&gt;(_x: i32) -&gt; T {
    loop {}
}

#[flux::sig(fn(Opt&lt;T&gt;[true]) -&gt; T)]
pub fn unwrap&lt;T&gt;(x: Opt&lt;T&gt;) -&gt; T {
    match x {
        Opt::Some(v) =&gt; v,
        Opt::None =&gt; never(0),
    }
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::refined_by(n: int)]
#[flux::invariant(n &gt; 0)]
pub enum Pos {
    #[flux::variant({Box&lt;Pos[@n]&gt;} -&gt; Pos[2*n])]
    XO(Box&lt;Pos&gt;),
    #[flux::variant({Box&lt;Pos[@n]&gt;} -&gt; Pos[2*n + 1])]
    XI(Box&lt;Pos&gt;),
    #[flux::variant(Pos[1])]
    XH,
}

impl Pos {
    #[flux::spec(fn(&amp;Pos[@n]) -&gt; i32[n])]
    pub fn to_i32(&amp;self) -&gt; i32 {
        match self {
            Pos::XH =&gt; 1,
            Pos::XI(rest) =&gt; 2 * rest.to_i32() + 1,
            Pos::XO(rest) =&gt; 2 * rest.to_i32(),
        }
    }

    #[flux::sig(fn(&amp;Pos[@n]) -&gt; bool[n == 1])]
    pub fn is_one(&amp;self) -&gt; bool {
        match self {
            Pos::XH =&gt; true,
            Pos::XI(_) =&gt; false,
            Pos::XO(_) =&gt; false,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn(i32{v: false}) -&gt; T)]
pub fn never&lt;T&gt;(_: i32) -&gt; T {
    loop {}
}

#[flux::refined_by(n:int)]
#[flux::invariant(n &gt;= 0)]
pub enum List {
    #[flux::variant(List[0])]
    Nil,
    #[flux::variant((i32, Box&lt;List[@n]&gt;) -&gt; List[n+1])]
    Cons(i32, Box&lt;List&gt;),
}

#[flux::sig(fn(&amp;List[@n]) -&gt; bool[n == 0])]
pub fn empty(l: &amp;List) -&gt; bool {
    match l {
        List::Nil =&gt; true,
        List::Cons(_, _) =&gt; false,
    }
}

#[flux::sig(fn(&amp;List[@n]) -&gt; i32[n])]
pub fn len(l: &amp;List) -&gt; i32 {
    match l {
        List::Nil =&gt; 0,
        List::Cons(_, tl) =&gt; 1 + len(tl),
    }
}

#[flux::sig(fn({&amp;List[@n] | 0 &lt; n}) -&gt; i32)]
pub fn head(l: &amp;List) -&gt; i32 {
    match l {
        List::Nil =&gt; never(0),
        List::Cons(h, _) =&gt; *h,
    }
}

#[flux::sig(fn({&amp;List[@n] | 0 &lt; n}) -&gt; &amp;List)]
pub fn tail(l: &amp;List) -&gt; &amp;List {
    match l {
        List::Nil =&gt; never(0),
        List::Cons(_, t) =&gt; t,
    }
}

#[flux::sig(fn(i32, n: usize) -&gt; List[n])]
pub fn clone(val: i32, n: usize) -&gt; List {
    if n == 0 {
        List::Nil
    } else {
        List::Cons(val, Box::new(clone(val, n - 1)))
    }
}

#[flux::sig(fn(List[@n1], List[@n2]) -&gt; List[n1+n2])]
pub fn append(l1: List, l2: List) -&gt; List {
    match l1 {
        List::Nil =&gt; l2,
        List::Cons(h1, t1) =&gt; List::Cons(h1, Box::new(append(*t1, l2))),
    }
}

#[flux::sig(fn(l1: &amp;strg List[@n1], List[@n2]) ensures l1: List[n1+n2])]
pub fn mappend(l1: &amp;mut List, l2: List) {
    match l1 {
        List::Nil =&gt; *l1 = l2,
        List::Cons(_, t1) =&gt; mappend(&amp;mut *t1, l2),
    }
}

#[flux::sig(fn(&amp;List[@n], k:usize{k &lt; n} ) -&gt; i32)]
pub fn get_nth(l: &amp;List, k: usize) -&gt; i32 {
    match l {
        List::Cons(h, tl) =&gt; {
            if k == 0 {
                *h
            } else {
                get_nth(tl, k - 1)
            }
        }
        List::Nil =&gt; never(0),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="invariants-on-enums"><a class="header" href="#invariants-on-enums">Invariants on Enums</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::refined_by(n: int)]
#[flux::invariant(n &gt;= 0)]
pub enum E {
    #[flux::variant({{i32[@n] | n &gt; 0}} -&gt; E[n])]
    Pos(i32),
    #[flux::variant({i32[0]} -&gt; E[0])]
    Zero(i32),
}

#[flux::sig(fn(E[@n], i32[n]) -&gt; i32{v: v &gt; 0})]
pub fn is_zero(_: E, x: i32) -&gt; i32 {
    x + 1
}
<span class="boring">}</span></code></pre></pre>
<h3 id="reflecting-enums"><a class="header" href="#reflecting-enums">Reflecting Enums</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::reflect]
pub enum State {
    On,
    Off,
}

#[flux_rs::sig(fn () -&gt; State[State::On])]
pub fn test00() -&gt; State {
    State::On
}

#[flux_rs::sig(fn () -&gt; State[State::Off])]
pub fn test01() -&gt; State {
    State::Off
}

#[flux::sig(fn () -&gt; State[State::Off])]
pub fn test02() -&gt; State {
    State::On //~ ERROR refinement type
}

#[flux::sig(fn (State[State::On]) -&gt; usize[1])]
pub fn test03(s: State) -&gt; usize {
    match s {
        State::On =&gt; 1,
        State::Off =&gt; 0,
    }
}

#[flux::sig(fn (State[@squig], zig: usize, tag: Day) -&gt; usize[tag])]
pub fn test04(s: State, _zig: usize, tag: Day) -&gt; usize {
    match s {
        State::On =&gt; 1,  //~ ERROR refinement type
        State::Off =&gt; 0, //~ ERROR refinement type
    }
}

#[flux::refined_by(day: int)]
pub enum Day {
    #[flux::variant(Day[0])]
    Mon,
    #[flux::variant(Day[1])]
    Tue,
    #[flux::variant(Day[2])]
    Wed,
}

#[flux::sig(fn (s:State, zig: usize, tag: Day) -&gt; usize[tag])]
pub fn test05(s: State, _zig: usize, _tag: Day) -&gt; usize {
    match s {
        State::On =&gt; 1,  //~ ERROR refinement type
        State::Off =&gt; 0, //~ ERROR refinement type
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="field-syntax-for-indices"><a class="header" href="#field-syntax-for-indices">Field Syntax for Indices</a></h2>
<h3 id="structs"><a class="header" href="#structs">Structs</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::refined_by(x: int, y: int)]
pub struct X {
    #[flux::field(u32[x])]
    x: u32,
    #[flux::field(u32[y])]
    y: u32,
}

#[flux::sig(fn (x: X[@old_x]) -&gt; X[X { y: 2, x: 1 }])]
fn f(mut x: X) -&gt; X {
    x.x = 1;
    x.y = 2;
    x
}
<span class="boring">}</span></code></pre></pre>
<h3 id="enums"><a class="header" href="#enums">Enums</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::refined_by(x: int, y: int)]
pub enum E {
    #[flux::variant(E[0, 1])]
    Variant1,
    #[flux::variant(E[1, 2])]
    Variant2,
    #[flux::variant(E[2, 3])]
    Variant3,
}

#[flux::sig(fn (e: E[@old_enum]) -&gt; E[E { x: 1, y: 2 }])]
fn f(e: E) -&gt; E {
    E::Variant2
}
<span class="boring">}</span></code></pre></pre>
<h3 id="updates"><a class="header" href="#updates">Updates</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::refined_by(x: int, y: int)]
pub struct S {
    #[flux::field(u32[x])]
    x: u32,
    #[flux::field(u32[y])]
    y: u32,
}

impl S {
    #[flux::sig(fn (self: &amp;strg S[@old_x]) ensures self: S[S { x: 1, ..old_x }])]
    pub fn update(&amp;mut self) {
        self.x = 1;
    }
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![flux::defs {
<span class="boring">fn main() {
</span>    fn some_computation(s: S) -&gt; S { s }
}]

#[flux::refined_by(x: int, y: int)]
pub struct S {
    #[flux::field(u32[x])]
    x: u32,
    #[flux::field(u32[y])]
    y: u32,
}

impl S {
    #[flux::sig(fn (self: &amp;strg S[@old_x]) ensures self: S[S { x: 1, ..some_computation(old_x) }])]
    pub fn update(&amp;mut self) {
        self.x = 1;
    }

    #[flux::sig(fn (self: &amp;strg S[@old_x]) ensures self: S[S { x: 1, ..S { x: 2, ..old_x } }])]
    pub fn update2(&amp;mut self) {
        self.x = 1;
    }
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use flux_rs::*;

#[refined_by(start: T, end: T)]
pub struct Range&lt;T&gt; {
    #[flux::field(T[start])]
    pub start: T,
    #[flux::field(T[end])]
    pub end: T,
}

#[sig(fn(r: Range&lt;T&gt;[@old]) -&gt; Range&lt;T&gt;[ Range { ..old } ])]
pub fn foo&lt;T&gt;(r: Range&lt;T&gt;) -&gt; Range&lt;T&gt; {
    r
}

#[sig(fn(r: Range&lt;i32&gt;{v: v == Range { start: 0, end: 0 } }))]
pub fn foo2(_r: Range&lt;i32&gt;) {}

#[sig(fn(r: Range&lt;i32&gt;[Range { start: 0, end: 0 } ]))]
pub fn foo3(_r: Range&lt;i32&gt;) {}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![flux::defs {
<span class="boring">fn main() {
</span>    fn some_computation(s: S) -&gt; S { s }
}]

#[flux::refined_by(x: int, y: int)]
pub struct S {
    #[flux::field(u32[x])]
    x: u32,
    #[flux::field(u32[y])]
    y: u32,
}

impl S {
    #[flux::sig(fn (self: &amp;strg S[@old_x]) ensures self: S[{ x: 1, ..some_computation(old_x) }])]
    pub fn update(&amp;mut self) {
        self.x = 1;
    }

    #[flux::sig(fn (self: &amp;strg S[@old_x]) ensures self: S[{ x: 1, ..S { x: 2, ..old_x } }])]
    pub fn update2(&amp;mut self) {
        self.x = 1;
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="const"><a class="header" href="#const">Const</a></h2>
<p>You can use <code>int</code>-ish <code>const</code> in refinements e.g.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Cow {}

impl Cow {
    const GRASS: usize = 12;

    #[flux_rs::sig(fn () -&gt; usize[12])]
    pub fn test() -&gt; usize {
        Self::GRASS
    }
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(u32)]
pub enum SyscallReturnVariant {
    Failure = 0,
}

#[flux_rs::sig(fn() -&gt; u32[0])]
pub fn test() -&gt; u32 {
    SyscallReturnVariant::Failure as u32
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Cow {}

const GRASS: usize = 12;
impl Cow {
    #[flux_rs::sig(fn () -&gt; usize[12])]
    fn test() -&gt; usize {
        GRASS
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="requires-with-forall"><a class="header" href="#requires-with-forall">Requires with <code>forall</code></a></h2>
<p>We allow a <code>forall</code> on the requires clauses, e.g.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn(bool[true]))]
fn assert(_: bool) {}
#[flux::sig(
    fn(x: i32)
    requires forall y. y &gt;= 0 =&gt; y &gt; x
)]
fn requires_negative(x: i32) {
    assert(x + 1 == 1 + x); // make sure there's something to check to avoid optimizing the entire constraint away
}

fn test2() {
    requires_negative(-1);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="refined-associated-types"><a class="header" href="#refined-associated-types">Refined Associated Types</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use flux_rs::*;

#[sig(fn(bool[true]))]
fn assert(_: bool) {}

trait MyTrait {
    type Assoc;

    #[sig(fn(Self::Assoc[@x]) -&gt; Self::Assoc[x])]
    fn f0(x: Self::Assoc) -&gt; Self::Assoc;

    #[sig(fn(x: Self::Assoc) -&gt; Self::Assoc{ v: v == x })]
    fn f1(x: Self::Assoc) -&gt; Self::Assoc;
}

impl MyTrait for () {
    type Assoc = i32;

    #[sig(fn(x: i32) -&gt; i32[x])]
    fn f0(x: i32) -&gt; i32 {
        x
    }

    #[sig(fn(x: i32) -&gt; i32[x])]
    fn f1(x: i32) -&gt; i32 {
        x
    }
}

fn test00() {
    let x = &lt;() as MyTrait&gt;::f0(0);
    assert(x == 0);
}

fn test01() {
    let x = &lt;() as MyTrait&gt;::f1(0);
    assert(x == 0);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="pragma-ignore"><a class="header" href="#pragma-ignore">Pragma: <code>ignore</code></a></h2>
<p>Used to tell <code>flux</code> to <em>ignore</em> (checking) a bunch of definitions.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![flux::ignore] // default to ignore for the entire crate

<span class="boring">fn main() {
</span>#[flux::ignore(no)] // include this module
mod included {
    #[flux::sig(fn(bool[true]))]
    pub fn assert(_: bool) {}

    pub fn test1() {
        // we are indeed checking this code
        assert(20 &lt; 10); //~ ERROR refinement type error
    }

    pub fn test2() {
        // we cannot use an ignored function in included code
        crate::ignored_fun(); //~ERROR use of ignored function
    }
}

// bad refinement, but no error since we are ignoring this function
#[flux::sig(fn(i32, i32))]
pub fn malformed(_: i32) {}

// an ignored function that cannot be used in included code
pub fn ignored_fun() {}
<span class="boring">}</span></code></pre></pre>
<h2 id="pragma-should_fail"><a class="header" href="#pragma-should_fail">Pragma: <code>should_fail</code></a></h2>
<p>Used to tell <code>flux</code> to <em>expect</em> a failure when checking a function.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This function has an error
// but it's marked as should_fail so that ok.
// flux would yell if instead it verified!

#[flux::should_fail]
#[flux::sig(fn(x: i32) -&gt; i32[x + 1])]
fn test00(x: i32) -&gt; i32 {
    x + 2
}
<span class="boring">}</span></code></pre></pre>
<h2 id="const-generics"><a class="header" href="#const-generics">Const Generics</a></h2>
<p><code>flux</code> lets you use Rust's const-generics inside refinements.</p>
<p><strong>Refining Array Lengths</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// https://github.com/flux-rs/flux/issues/625

const BUFLEN: usize = 100;

pub struct Blob {
    data: [i32; BUFLEN],
}

pub fn test(buf: &amp;[i32; BUFLEN]) -&gt; i32 {
    let x0 = buf[0];
    let x1 = buf[10];
    let x2 = buf[BUFLEN - 1];
    let xbad = buf[BUFLEN]; //~ ERROR assertion might fail
    x0 + x1 + x2 + xbad
}

pub fn test_blob(blob: Blob) -&gt; i32 {
    let x0 = blob.data[0];
    let x1 = blob.data[10];
    let x2 = blob.data[BUFLEN - 1];
    let xbad = blob.data[BUFLEN]; //~ ERROR assertion might fail
    x0 + x1 + x2 + xbad
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Refining Struct Fields</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::invariant(N &gt; 0)]
pub struct MPU&lt;const N: usize&gt; {
    #[flux::field({ i32 | N &gt; 0 })]
    field: i32,
}

pub fn foo&lt;const N: usize&gt;(x: usize, _mpu: MPU&lt;N&gt;) {
    let _x = x % N;
}

#[flux::invariant(N &gt; 0)]
pub struct MPUGOOD&lt;const N: usize&gt; {
    field: i32,
}

pub fn bar&lt;const N: usize&gt;(x: usize, _mpu: MPUGOOD&lt;N&gt;) {
    let _x = x % N;
}

pub fn baz&lt;const N: usize&gt;() -&gt; i32 {
    if N &gt; 0 {
        let mpu = MPUGOOD::&lt;N&gt; { field: 12 };
        mpu.field
    } else {
        0
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Refining Function Signatures</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[path = "../../lib/rvec.rs"]
mod rvec;
use rvec::RVec;

/// A statically sized matrix represented with a linear vector
struct Matrix&lt;const N: usize, const M: usize&gt; {
    #[flux::field(RVec&lt;i32&gt;[N * M])]
    inner: RVec&lt;i32&gt;,
}

impl&lt;const N: usize, const M: usize&gt; Matrix&lt;N, M&gt; {
    fn new() -&gt; Matrix&lt;N, M&gt; {
        Matrix { inner: RVec::from_elem_n(0, N * M) }
    }

    #[flux::sig(fn(&amp;mut Self, i: usize{ i &lt; N }, j: usize{ j &lt; M }, v: i32))]
    fn set(&amp;mut self, i: usize, j: usize, v: i32) {
        self.inner[i * M + j] = v
    }

    #[flux::sig(fn(&amp;Self, i: usize{ i &lt; N }, j: usize{ j &lt; M }) -&gt; i32)]
    fn get(&amp;self, i: usize, j: usize) -&gt; i32 {
        self.inner[i * M + j]
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="type-aliases"><a class="header" href="#type-aliases">Type Aliases</a></h2>
<p>You can define refined <strong>type aliases</strong> for Rust types.</p>
<p><strong>Note</strong></p>
<ol>
<li>They are connected to an underlying Rust type,</li>
<li>They may also be parameterized by refinements, e.g. <code>Lb</code></li>
<li>There are two different kinds of parametrizations
<ul>
<li><em>early</em> (<code>Nat</code>) and</li>
<li><em>late</em> (<code>Lb</code>).</li>
</ul>
</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::alias(type Nat[n: int] = {i32[n] | 0 &lt;= n})]
type Nat = i32;

#[flux::alias(type Lb(n: int)[v: int] = {i32[v] | n &lt;= v})]
type Lb = i32;

#[flux::sig(fn(x: Nat) -&gt; Nat)]
pub fn test1(x: Nat) -&gt; Nat {
    x + 1
}

#[flux::sig(fn(x: Lb(10)) -&gt; Lb(10))]
pub fn test2(x: Lb) -&gt; Lb {
    x + 1
}
<span class="boring">}</span></code></pre></pre>
<h2 id="spec-function-definitions"><a class="header" href="#spec-function-definitions">Spec Function Definitions</a></h2>
<p>You can define <strong>spec functions</strong> that abstract complicated refinements into refinement-level
functions, which can then be used in refinements.</p>
<h3 id="plain-expressions"><a class="header" href="#plain-expressions">Plain Expressions</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![flux::defs {
<span class="boring">fn main() {
</span>    fn is_btwn(v:int, lo:int, hi: int) -&gt; bool { lo &lt;= v &amp;&amp; v &lt;= hi }
    fn ok_day(d:int) -&gt; bool { is_btwn(d, 1, 31) }
    fn is_month30(m:int) -&gt; bool { m == 4 || m == 6 || m == 9 || m == 11 }
    fn ok_month(d:int, m:int) -&gt; bool { is_btwn(m, 1, 12) &amp;&amp; (is_month30(m) =&gt; d &lt;= 30) }
    fn is_leap_year(y:int) -&gt; bool { y % 400 == 0 || (y % 4 == 0 &amp;&amp; (y % 100) &gt; 0) }
    fn is_feb_day(d:int, y:int) -&gt; bool { d &lt;= 29 &amp;&amp; ( d == 29 =&gt; is_leap_year(y) ) }
    fn ok_year(d:int, m:int, y:int) -&gt; bool { 1 &lt;= y &amp;&amp; (m == 2 =&gt; is_feb_day(d, y)) }
}]

// https://github.com/chrisdone/sandbox/blob/master/liquid-haskell-dates.hs

#[allow(dead_code)]
#[flux::refined_by(d:int, m:int, y:int)]
pub struct Date {
    #[flux::field({ usize[d] | ok_day(d) })]
    day: usize,
    #[flux::field({ usize[m] | ok_month(d, m)})]
    month: usize,
    #[flux::field({ usize[y] | ok_year(d, m, y)})]
    year: usize,
}

pub fn test() {
    let _ok_date = Date { day: 9, month: 8, year: 1977 };
}

// TODO: Tedious to duplicate the definitions if you want to use them in rust code.
// Maybe some macro magic can unify?

#[flux::sig(fn(m:usize) -&gt; bool[is_month30(m)])]
fn is_month30(m: usize) -&gt; bool {
    m == 4 || m == 6 || m == 9 || m == 11
}

#[flux::sig(fn(y:usize) -&gt; bool[is_leap_year(y)])]
fn is_leap_year(y: usize) -&gt; bool {
    y % 400 == 0 || (y % 4 == 0 &amp;&amp; y % 100 != 0)
}

#[flux::sig(fn(d:usize, y:usize) -&gt; bool[is_feb_day(d, y)])]
fn is_feb_day(d: usize, y: usize) -&gt; bool {
    d &lt;= 29 &amp;&amp; (d != 29 || is_leap_year(y))
}

pub fn mk_date(day: usize, month: usize, year: usize) -&gt; Option&lt;Date&gt; {
    if 1 &lt;= year &amp;&amp; 1 &lt;= month &amp;&amp; month &lt;= 12 &amp;&amp; 1 &lt;= day &amp;&amp; day &lt;= 31 {
        if !is_month30(month) || day &lt;= 30 {
            if month != 2 || is_feb_day(day, year) {
                return Some(Date { day, month, year });
            }
        }
    }
    return None;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="let-binders"><a class="header" href="#let-binders"><code>let</code> binders</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use flux_rs::attrs::*;

defs! {
    fn times2(x: int) -&gt; int {
        x * 2
    }

    fn test(x: int) -&gt; int {
        let y = times2(x);
        let z = times2(y);
        z * z * y
    }
}

#[sig(fn() -&gt; i32[test(10)])]
fn test() -&gt; i32 {
    32000
}
<span class="boring">}</span></code></pre></pre>
<h3 id="bounded-quantification"><a class="header" href="#bounded-quantification">Bounded Quantification</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![flux::defs {
<span class="boring">fn main() {
</span>    fn magic(xing:int, yonk:int) -&gt; bool;

    fn magic_all(noob:int) -&gt; bool {
        forall i in 0 .. 4 {
            magic(i, noob)
        }
    }

    fn magic_ex(n:int) -&gt; bool {
        exists i in 0 .. 4 {
            i == n
        }
    }
}]

#[flux::trusted]
#[flux::sig(fn(x:i32, y:i32) ensures magic(x, y))]
pub fn do_magic(_x: i32, _y: i32) {}

// forall tests ----------------------------------------------------------------

#[flux::sig(fn({i32[@n] | magic_all(n)}) ensures magic(3, n))]
pub fn test_all_l(_x: i32) {}

#[flux::sig(fn(n:i32) ensures magic_all(n))]
pub fn test_all_r(n: i32) {
    do_magic(0, n);
    do_magic(1, n);
    do_magic(2, n);
    do_magic(3, n);
}

// exists tests ----------------------------------------------------------------
#[flux::sig(fn({i32[@n] | magic_ex(n)}) -&gt; bool[true])]
pub fn test_exi_l(n: i32) -&gt; bool {
    n == 0 || n == 1 || n == 2 || n == 3
}

#[flux::sig(fn(n:i32) -&gt; bool[magic_ex(n)])]
pub fn test_exi_r(n: i32) -&gt; bool {
    n == 0 || n == 1 || n == 2 || n == 3
}
<span class="boring">}</span></code></pre></pre>
<h3 id="no-cycles"><a class="header" href="#no-cycles">No Cycles!</a></h3>
<p>However, there should be no <em>cyclic dependencies</em> in the function definitions.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![flux::defs {
<span class="boring">fn main() {
</span>    fn even(x: int) -&gt; bool { x == 0 || odd(x-1) }
    fn odd(x: int) -&gt; bool { x == 1 || even(x-1) } //~ ERROR cycle
}]

#[flux::sig(fn(x:i32) -&gt; i32[x+1])]
pub fn test(x: i32) -&gt; i32 {
    x + 1
}
<span class="boring">}</span></code></pre></pre>
<h2 id="uninterpreted-function-declarations"><a class="header" href="#uninterpreted-function-declarations">Uninterpreted Function Declarations</a></h2>
<p>You can also declare <em>uninterpreted</em> functions -- about which <code>flux</code> knows nothing
other than the congruence property -- and then use them in refinements. Note that
in this case you have to use a <code>trusted</code> annotation for the function (e.g. <code>is_valid</code>)
that asserts facts over the uninterpreted function</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![flux::defs {
<span class="boring">fn main() {
</span>    fn valid(x:int) -&gt; bool;
}]

#[flux::trusted]
#[flux::sig(fn(x:i32) -&gt; bool[valid(x)])]
fn is_valid(x: i32) -&gt; bool {
    0 &lt;= x &amp;&amp; x &lt;= 100
}

#[flux::sig(fn (i32{v:valid(v)}) -&gt; i32)]
fn bar(a: i32) -&gt; i32 {
    return a;
}

#[flux::sig(fn(i32))]
pub fn test(n: i32) {
    let ok = is_valid(n);
    if ok {
        bar(n);
    }
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![flux::defs {
<span class="boring">fn main() {
</span>    fn foo(x:int, y:int) -&gt; int;
}]

#[flux::trusted]
#[flux::sig(fn(x: i32, y:i32) -&gt; i32[foo(x, y)])]
fn foo(x: i32, y: i32) -&gt; i32 {
    x + y
}

#[flux::sig(fn (i32[foo(10, 20)]) -&gt; i32)]
fn bar(a: i32) -&gt; i32 {
    return a;
}

#[flux::sig(fn())]
pub fn test() {
    let a = 10;
    let b = 20;
    let c = foo(a, b);
    bar(c);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="hiding-and-revealing-function-definitions"><a class="header" href="#hiding-and-revealing-function-definitions">Hiding and Revealing Function Definitions</a></h2>
<p>By default all the function definitions are either <em>inlined</em> or sent to the SMT solver
as <code>define-fun</code> (when run with <code>FLUX_SMT_DEFINE_FUN=1</code>). Sometimes we want to <em>hide</em> the
definition because reasoning about those functions can kill the solver -- or the function
is super complex and we just want to reason about it via congruence. For that you can</p>
<ul>
<li>use the <code>#[hide]</code> attribute at the spec function definition, to make the function <em>uninterpreted</em> by default, and</li>
<li>use the <code>#[reveal]</code> attribute at specific Rust function definition, to indicate you
want to use the actual definition when checking that Rust function.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![flux::defs {
<span class="boring">fn main() {
</span>    #[hide]
    fn mod33(n:int) -&gt; int {
        n % 33
    }

    #[hide]
    fn foo(n:int, k:int) -&gt; bool {
      mod33(n) == k
    }

}]

#[flux::sig(fn (a:i32) requires foo(a, 7))]
pub fn assert_foo(_a: i32) {}

#[flux::reveal(foo, mod33)]
pub fn use_foo(n: i32) {
    if n == 40 {
        assert_foo(n)
        // without `reveal(foo)` we want to see an error in the above line.
    }
}

#[flux::sig(fn (xs: &amp;[i32{v: foo(v, 7)}][100]) -&gt; i32{v : foo(v, 7)})]
pub fn bar(xs: &amp;[i32]) -&gt; i32 {
    xs[0] // `foo` as uninterpreted works fine
}
<span class="boring">}</span></code></pre></pre>
<h2 id="spec-functions-in-smtlib"><a class="header" href="#spec-functions-in-smtlib">Spec Functions in SMTLIB</a></h2>
<p>By default <code>flux</code> inlines all such function definitions.</p>
<p>Monomorphic functions may <em>optionally</em> be encoded
as functions in SMT by using the <code>FLUX_SMT_DEFINE_FUN=1</code>
environment variable.</p>
<h2 id="type-holes"><a class="header" href="#type-holes">Type Holes</a></h2>
<p>You can (sometimes!) use <code>_</code> in the <code>flux</code> signatures to omit the Rust components, e.g.</p>
<h3 id="function-signatures"><a class="header" href="#function-signatures">Function Signatures</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn(_) -&gt; Option&lt;_&gt;)]
fn test00(x: i32) -&gt; Option&lt;i32&gt; {
    Some(x)
}

#[flux::sig(fn(x: &amp;strg _) ensures x: i32[0])]
fn test01(x: &amp;mut i32) {
    *x = 0;
}

#[flux::sig(fn(x: &amp;strg i32) ensures x: _)]
fn test02(x: &amp;mut i32) {
    *x = 0;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="structs-and-enums"><a class="header" href="#structs-and-enums">Structs and Enums</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Type holes in structs and enums

pub struct S {
    #[flux::field(Option&lt;_&gt;)]
    x: Option&lt;i32&gt;,
}

pub fn test_s(s: S) -&gt; Option&lt;i32&gt; {
    s.x
}

pub enum E {
    #[flux::variant((_) -&gt; E)]
    A(i32),
}

pub fn test_e(e: E) -&gt; i32 {
    match e {
        E::A(x) =&gt; x,
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="type-aliases-1"><a class="header" href="#type-aliases-1">Type Aliases</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::alias(type Test = Vec&lt;_&gt;)]
type Test = Vec&lt;i32&gt;;

fn test(x: Test) -&gt; Vec&lt;i32&gt; {
    x
}
<span class="boring">}</span></code></pre></pre>
<h3 id="generic-args"><a class="header" href="#generic-args">Generic Args</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux_rs::refined_by(m: Map&lt;int, int&gt;)]
#[flux_rs::opaque]
pub struct S1&lt;const N: usize&gt; {
    _arr: [usize; N],
}

const MY_N: usize = 10;

#[flux_rs::refined_by(gloop: S1)]
pub struct S2 {
    #[field(S1&lt;_&gt;[gloop])]
    pub s1: S1&lt;MY_N&gt;,
}

#[flux_rs::refined_by(zoo: S1)]
pub struct S3&lt;const M: usize&gt; {
    #[field(S1&lt;_&gt;[zoo])]
    pub s1: S1&lt;M&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="closures"><a class="header" href="#closures">Closures</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn(c: Option&lt;bool&gt;) -&gt; Option&lt;i32{v:0 &lt;= v}&gt;)]
pub fn test0(c: Option&lt;bool&gt;) -&gt; Option&lt;i32&gt; {
    c.map(|b| if b { 1 } else { 2 })
}

// #[flux::sig(fn(c: Option&lt;bool&gt;) -&gt; Option&lt;i32{v:1 &lt;= v}&gt;)]
// pub fn test1(c: Option&lt;bool&gt;) -&gt; Option&lt;i32&gt; {
//     c.map(|b| if b { 1 } else { 2 })
// }

// #[flux::sig(fn(c: Option&lt;bool[true]&gt;) -&gt; Option&lt;i32[1]&gt;)]
// pub fn test2(c: Option&lt;bool&gt;) -&gt; Option&lt;i32&gt; {
//     c.map(|b| if b { 1 } else { 2 })
// }

// #[flux::sig(fn(n:usize) -&gt; usize[n + 2])]
// pub fn test3(n: usize) -&gt; usize {
//     checked_add(n, 1)
//         .and_then(|m| Some(m + 1))
//         .expect("overflow")
// }

// #[flux::trusted]
// #[flux::sig(fn(n:usize, m:usize) -&gt; Option&lt;usize[n + m]&gt;)]
// pub fn checked_add(n: usize, m: usize) -&gt; Option&lt;usize&gt; {
//     n.checked_add(m)
// }
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[path = "../../lib/rvec.rs"]
mod rvec;
use rvec::RVec;

#[flux::trusted]
fn smap&lt;S, F, A, B&gt;(s: S, v: Vec&lt;A&gt;, f: F) -&gt; Vec&lt;B&gt;
where
    F: Fn(S, A) -&gt; B,
    S: Copy,
{
    v.into_iter().map(|x| f(s, x)).collect()
}

#[flux::sig(fn(vs: Vec&lt;i32{v:0&lt;=v}&gt;) -&gt; Vec&lt;i32{v:3&lt;=v}&gt;)]
pub fn test1_old(vs: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    let st = 3;
    smap(st, vs, |s, x| s + x)
}

#[flux::sig(fn(vs: Option&lt;i32{v:0&lt;=v}&gt;) -&gt; Option&lt;i32{v:3&lt;=v}&gt;)]
pub fn test2_old(vs: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    let y = 1;
    let z = 2;
    vs.map(|x| x + y + z)
}

pub struct Foo {
    #[flux::field(i32{v: 10 &lt;= v})]
    pub val: i32,
}

pub fn test1(c: Option&lt;bool&gt;) -&gt; Option&lt;Foo&gt; {
    let x = 6;
    let y = 10;
    c.map(|b| if b { Foo { val: x + y } } else { Foo { val: 20 } })
}

#[flux::sig(fn(vec:&amp;RVec&lt;i32{v: 10 &lt;= v}&gt;{v: 0 &lt; v}) -&gt; Foo)]
fn bob(vec: &amp;RVec&lt;i32&gt;) -&gt; Foo {
    Foo { val: vec[0] }
}

pub fn test2(c: Option&lt;bool&gt;) -&gt; Option&lt;Foo&gt; {
    let vec = rvec![100, 200, 300];
    c.map(|b| if b { bob(&amp;vec) } else { Foo { val: 20 } })
}

#[flux::trusted]
fn frob(_vec: &amp;RVec&lt;RVec&lt;i32&gt;&gt;) -&gt; Foo {
    todo!()
}

pub fn test3(c: Option&lt;bool&gt;, vec: RVec&lt;RVec&lt;i32&gt;&gt;) -&gt; Option&lt;Foo&gt; {
    // let mut vec = rvec![rvec![100, 200, 300]];
    c.map(|b| if b { frob(&amp;vec) } else { Foo { val: 20 } })
}
<span class="boring">}</span></code></pre></pre>
<h2 id="function-pointers"><a class="header" href="#function-pointers">Function Pointers</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![allow(unused)]

<span class="boring">fn main() {
</span>#[flux::sig(fn (x:usize) -&gt; usize[x+1])]
fn inc(x: usize) -&gt; usize {
    x + 1
}

#[flux::sig(fn(c: Option&lt;usize[99]&gt;) -&gt; Option&lt;usize[100]&gt;)]
pub fn test_ok(c: Option&lt;usize&gt;) -&gt; Option&lt;usize&gt; {
    c.map(inc)
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![allow(unused)]

<span class="boring">fn main() {
</span>fn id&lt;T&gt;(x: T) -&gt; T {
    x
}

#[flux::sig(fn(c: Option&lt;usize[99]&gt;) -&gt; Option&lt;usize[99]&gt;)]
pub fn test_ok(c: Option&lt;usize&gt;) -&gt; Option&lt;usize&gt; {
    c.map(id)
}

#[flux::sig(fn(Option&lt;i32[99]&gt;) -&gt; Option&lt;i32[99]&gt;)]
fn test_also_ok(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    let f = id;
    x.map(f)
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use flux_rs::*;

#[sig(fn(x: i32{x != 0}) -&gt; i32[1/x])]
fn div(x: i32) -&gt; i32 {
    1 / x
}

fn apply&lt;A, B&gt;(f: impl FnOnce(A) -&gt; B, x: A) -&gt; B {
    f(x)
}

#[sig(fn() -&gt; i32[0])]
fn test() -&gt; i32 {
    apply(div, 10)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="traits-and-implementations"><a class="header" href="#traits-and-implementations">Traits and Implementations</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait MyTrait {
    fn foo() -&gt; i32;
    fn bar();
}

pub struct MyTy;

impl MyTrait for MyTy {
    #[flux::sig(fn () -&gt; i32[10])]
    fn foo() -&gt; i32 {
        10
    }

    fn bar() {}
}

#[flux::sig(fn () -&gt; i32[10])]
pub fn test() -&gt; i32 {
    let n = MyTy::foo();
    MyTy::bar();
    n
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Mono {
    #[flux::sig(fn (zing: &amp;strg i32[@n]) ensures zing: i32{v:n &lt; v})]
    fn foo(z: &amp;mut i32);
}

pub struct Tiger;

impl Mono for Tiger {
    #[flux::sig(fn (pig: &amp;strg i32[@m]) ensures pig: i32{v:m &lt; v})]
    fn foo(pig: &amp;mut i32) {
        *pig += 1;
    }
}

pub struct Snake;

impl Mono for Snake {
    #[flux::sig(fn (pig: &amp;strg i32[@m]) ensures pig: i32[m+1])]
    fn foo(pig: &amp;mut i32) {
        *pig += 1;
    }
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Mono {
    #[flux::sig(fn (zing: &amp;strg i32[@n])
                  requires 100 &lt; n
                  ensures zing: i32{v:n &lt; v})]
    fn foo(z: &amp;mut i32);
}

pub struct Tiger;

impl Mono for Tiger {
    #[flux::sig(fn (pig: &amp;strg i32[@m])
                  requires 0 &lt; m
                  ensures pig: i32{v:m &lt; v})]
    fn foo(pig: &amp;mut i32) {
        *pig += 1;
    }
}

pub struct Snake;

impl Mono for Snake {
    #[flux::sig(fn (pig: &amp;strg {i32[@m] | 0 &lt; m})
                ensures pig: i32[m+1])]
    fn foo(pig: &amp;mut i32) {
        *pig += 1;
    }
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::generics(Self as base)]
pub trait MyTrait {
    #[flux::sig(fn[hrn p: Self -&gt; bool](&amp;Self{v: p(v)}) -&gt; Self{v: p(v)})]
    fn foo1(&amp;self) -&gt; Self;

    fn foo2(&amp;self) -&gt; Self;
}

impl MyTrait for i32 {
    // TODO: error-message when below is missing (currently: fixpoint crash!) see tests/tests/todo/trait13.rs
    #[flux::sig(fn[hrn p: Self -&gt; bool](&amp;Self{v: p(v)}) -&gt; Self{v: p(v)})]
    fn foo1(&amp;self) -&gt; Self {
        *self
    }

    #[flux::sig(fn[hrn q: Self -&gt; bool](&amp;Self{v: q(v)}) -&gt; Self{v: q(v)})]
    fn foo2(&amp;self) -&gt; Self {
        *self
    }
}

#[flux::sig(fn[hrn q: T -&gt; bool](&amp;T{v:q(v)}) -&gt; T{v: q(v)})]
pub fn bar1&lt;T: MyTrait&gt;(x: &amp;T) -&gt; T {
    x.foo1()
}

#[flux::sig(fn(bool[true]))]
fn assert(_b: bool) {}

pub fn test() {
    let x = 42;
    assert(bar1(&amp;x) == 42);
    assert(x.foo2() == 42);
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Silly&lt;A&gt; {
    #[flux::sig(fn(&amp;Self, z: A) -&gt; i32{v:100 &lt; v})]
    fn bloop(&amp;self, z: A) -&gt; i32;
}

impl Silly&lt;bool&gt; for i32 {
    #[flux::sig(fn(&amp;Self, b : bool) -&gt; i32[2000])]
    fn bloop(&amp;self, _b: bool) -&gt; i32 {
        2000
    }
}

#[flux::sig(fn(i32) -&gt; i32{v: 100 &lt; v})]
pub fn client(x: i32) -&gt; i32 {
    let y = x.bloop(true);
    y + 1
}

#[flux::sig(fn(_, _) -&gt; i32{v:100 &lt; v})]
pub fn client2&lt;A, B: Silly&lt;A&gt;&gt;(x: B, y: A) -&gt; i32 {
    x.bloop(y)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="impl-trait"><a class="header" href="#impl-trait">Impl Trait</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn test1() -&gt; impl Iterator&lt;Item = i32&gt; {
    Some(10).into_iter()
}

#[flux::sig(fn () -&gt; impl Iterator&lt;Item = i32{v:1&lt;=v}&gt;)]
pub fn test2() -&gt; impl Iterator&lt;Item = i32&gt; {
    Some(10).into_iter()
}

#[flux::sig(fn () -&gt; impl Iterator&lt;Item = i32{v:1&lt;=v}&gt;)]
pub fn test_lib() -&gt; impl Iterator&lt;Item = i32&gt; {
    Some(10).into_iter()
}

#[flux::sig(fn () -&gt; Option&lt;i32{v:0&lt;=v}&gt;)]
pub fn test_client() -&gt; Option&lt;i32&gt; {
    let mut it = test_lib();
    it.next()
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn (x:i32) -&gt; impl Iterator&lt;Item = i32{v:x&lt;=v}&gt;)]
pub fn lib(x: i32) -&gt; impl Iterator&lt;Item = i32&gt; {
    Some(x).into_iter()
}

#[flux::sig(fn (k:i32) -&gt; Option&lt;i32{v:k&lt;=v}&gt;)]
pub fn test_client(k: i32) -&gt; Option&lt;i32&gt; {
    let mut it = lib(k);
    it.next()
}
<span class="boring">}</span></code></pre></pre>
<h2 id="dynamic-trait-objects"><a class="header" href="#dynamic-trait-objects">Dynamic Trait Objects</a></h2>
<pre><pre class="playground"><code class="language-rust">#![allow(unused)]

// ------------------------------------------------------

trait Shape {
    #[flux::sig(fn(self: _) -&gt; i32{v: 0 &lt;= v})]
    fn vertices(&amp;self) -&gt; i32;
}

// ------------------------------------------------------

struct Circle {}

impl Shape for Circle {
    #[flux::sig(fn(self: _) -&gt; i32{v: 0 &lt;= v})]
    fn vertices(&amp;self) -&gt; i32 {
        0
    }
}

// ------------------------------------------------------

#[flux::sig(fn(shape: _) -&gt; i32{v: 0 &lt;= v})]
fn count(shape: &amp;dyn Shape) -&gt; i32 {
    shape.vertices()
}

#[flux::sig(fn(shape: _) -&gt; i32{v: 10 &lt;= v})]
fn count_bad(shape: &amp;dyn Shape) -&gt; i32 {
    shape.vertices() //~ ERROR: refinement type
}

fn main() {
    let c = Circle {};
    count(&amp;c);
    count_bad(&amp;c);
}</code></pre></pre>
<h2 id="generic-refinements"><a class="header" href="#generic-refinements">Generic Refinements</a></h2>
<p><code>flux</code> supports <em>generic refinements</em> see <a href="https://dl.acm.org/doi/10.1145/3704885">this paper for details</a></p>
<p><strong>Horn Refinements</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Define a function whose type uses the Horn generic refinement `p`
#[flux::sig(
    fn[hrn p: int -&gt; bool](x: i32, y: i32) -&gt; i32{v: p(v) &amp;&amp; v &gt;= x &amp;&amp; v &gt;= y}
    requires p(x) &amp;&amp; p(y)
)]
fn max(x: i32, y: i32) -&gt; i32 {
    if x &gt; y { x } else { y }
}

// A client of `max` where the generic is instantiated to `|v| {v % 2 == 0}`
#[flux::sig(fn() -&gt; i32{v: v % 2 == 0})]
pub fn test00() -&gt; i32 {
    max(4, 10)
}

// A client of `max` where the generic is instantiated to `|v| {v == 4 || v == 10}`
#[flux::sig(fn() -&gt; i32[10])]
pub fn test01() -&gt; i32 {
    max(4, 10)
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::refined_by(a: int, b: int, hrn p: (int, int) -&gt; bool)]
struct Pair {
    #[flux::field(i32[a])]
    fst: i32,
    #[flux::field({i32[b] | p(a, b)})]
    snd: i32,
}

#[flux::sig(fn() -&gt; Pair)]
fn test00() -&gt; Pair {
    Pair { fst: 0, snd: 1 }
}

#[flux::sig(fn(Pair[@a, @b, |a, b| a &lt; b]) -&gt; i32{v: v &gt; 0})]
fn test01(pair: Pair) -&gt; i32 {
    pair.snd - pair.fst
}

fn test02() {
    let pair = Pair { fst: 0, snd: 1 };
    let x = test01(pair);
}

#[flux::sig(fn(x: i32, Pair[@a, @b, |a, b| a &gt; x]) -&gt; i32{v: v &gt; x})]
fn test03(x: i32, pair: Pair) -&gt; i32 {
    pair.fst
}

fn test04() {
    let pair = Pair { fst: 10, snd: 0 };
    test03(0, pair);
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Copy)]
#[flux::refined_by(hrn p: int -&gt; bool)]
pub struct S;

#[flux::sig(fn(x: i32) -&gt; S[|y| y &gt; x])]
pub fn gt(x: i32) -&gt; S {
    S
}

#[flux::sig(fn(x: i32) -&gt; S[|y| y &lt; x])]
pub fn lt(x: i32) -&gt; S {
    S
}

#[flux::sig(fn(S[@p1], S[@p2]) -&gt; S[|x| p1(x) || p2(x)])]
pub fn or(_: S, _: S) -&gt; S {
    S
}

#[flux::sig(fn(S[@p], x: i32{ p(x) }))]
pub fn check(_: S, x: i32) {}

pub fn test() {
    let s = or(gt(10), lt(0));
    check(s, 11);
    check(s, -1);
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Hindley Refinements</strong></p>
<p>TODO</p>
<h2 id="bitvector-refinements"><a class="header" href="#bitvector-refinements">Bitvector Refinements</a></h2>
<h3 id="operators"><a class="header" href="#operators">Operators</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// https://github.com/flux-rs/flux/issues/1010

use flux_rs::{attrs::*, bitvec::BV32};

#[sig(fn (x:BV32{x == 1}) ensures (bv_shl(x, 3) == 8))]
pub fn test_shl_a(_x: BV32) {}

#[sig(fn (x:BV32{x == 1}) ensures (x &lt;&lt; 3 == 8))]
pub fn test_shl_b(_x: BV32) {}

#[sig(fn (x:BV32{x == 8}) ensures (bv_lshr(x, 3) == 1))]
pub fn test_shr_a(_x: BV32) {}

#[sig(fn (x:BV32{x == 8}) ensures (x &gt;&gt; 3 == 1))]
pub fn test_shr_b(_x: BV32) {}

#[sig(fn (x:BV32{x == 8}) ensures (bv_or(x, 3) == 11))]
pub fn test_or_a(_x: BV32) {}

#[sig(fn (x:BV32{x == 8}) ensures (x | 3 == 11))]
pub fn test_or_b(_x: BV32) {}

#[sig(fn (x:BV32{x == 10}) ensures (bv_and(x, 3) == 2))]
pub fn test_and_a(_x: BV32) {}

#[sig(fn (x:BV32{x == 10}) ensures (x &amp; 3 == 2))]
pub fn test_and_b(_x: BV32) {}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use flux_rs::{attrs::*, bitvec::BV32};

#[sig(fn(x: BV32) -&gt; BV32[bv_add(x, bv_int_to_bv32(1))])]
pub fn test_00(x: BV32) -&gt; BV32 {
    x + BV32::new(1)
}

#[sig(fn(x: BV32) -&gt; BV32[x + bv_int_to_bv32(1)])]
pub fn test_01(x: BV32) -&gt; BV32 {
    x + BV32::new(1)
}

#[sig(fn(x: BV32) -&gt; BV32[x + 1])]
pub fn test_02(x: BV32) -&gt; BV32 {
    x + BV32::new(1)
}

#[sig(fn(x: i32) -&gt; i32[x + (1 + 2)])]
pub fn test_03(x: i32) -&gt; i32 {
    x + 3
}

#[sig(fn() -&gt; BV32[bv_int_to_bv32(0x5)])]
pub fn test_04() -&gt; BV32 {
    BV32::new(0x5)
}

#[sig(fn() -&gt; BV32[5])]
pub fn test_05() -&gt; BV32 {
    BV32::new(0x5)
}

#[sig(fn(x: BV32, y:BV32) -&gt; bool[x + y &gt; 5])]
pub fn test_06(x: BV32, y: BV32) -&gt; bool {
    x + y &gt; BV32::new(5)
}

#[sig(fn(x: BV32, y:BV32) -&gt; bool[x + y &gt; x - y])]
pub fn test_07(x: BV32, y: BV32) -&gt; bool {
    x + y &gt; x - y
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::{Add, Sub};

#[flux::opaque]
#[flux::refined_by(x: bitvec&lt;32&gt;)]
pub struct BV32(u32);

impl BV32 {
    #[flux::trusted]
    #[flux::sig(fn (u32[@x]) -&gt; BV32[bv_int_to_bv32(x)])]
    pub fn new(x: u32) -&gt; Self {
        BV32(x)
    }
}

impl Add for BV32 {
    type Output = BV32;

    #[flux_rs::trusted]
    #[flux_rs::sig(fn (BV32[@val1], BV32[@val2]) -&gt; BV32[bv_add(val1, val2)])]
    fn add(self, rhs: Self) -&gt; BV32 {
        BV32(self.0 + rhs.0)
    }
}

impl Sub for BV32 {
    type Output = BV32;

    #[flux_rs::trusted]
    #[flux_rs::sig(fn (BV32[@val1], BV32[@val2]) -&gt; BV32[bv_sub(val1, val2)])]
    fn sub(self, rhs: Self) -&gt; BV32 {
        BV32(self.0.wrapping_add(!rhs.0))
    }
}

impl PartialEq for BV32 {
    #[flux::trusted]
    #[flux::sig(fn (&amp;BV32[@val1], &amp;BV32[@val2]) -&gt; bool[val1 == val2])]
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        self.0 == other.0
    }

    #[flux::trusted]
    #[flux::sig(fn (&amp;BV32[@val1], &amp;BV32[@val2]) -&gt; bool[val1 != val2])]
    fn ne(&amp;self, other: &amp;Self) -&gt; bool {
        self.0 != other.0
    }
}

impl PartialOrd for BV32 {
    #[flux::trusted]
    fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;std::cmp::Ordering&gt; {
        self.0.partial_cmp(&amp;other.0)
    }

    #[flux::trusted]
    #[flux::sig(fn (&amp;BV32[@x], &amp;BV32[@y]) -&gt; bool[bv_ule(x, y)])]
    fn le(&amp;self, other: &amp;Self) -&gt; bool {
        self.0 &lt;= other.0
    }

    #[flux::trusted]
    #[flux::sig(fn (&amp;BV32[@x], &amp;BV32[@y]) -&gt; bool[bv_ult(x, y)])]
    fn lt(&amp;self, other: &amp;Self) -&gt; bool {
        self.0 &lt; other.0
    }

    #[flux::trusted]
    #[flux::sig(fn (&amp;BV32[@x], &amp;BV32[@y]) -&gt; bool[bv_uge(x, y)])]
    fn ge(&amp;self, other: &amp;Self) -&gt; bool {
        self.0 &gt;= other.0
    }

    #[flux::trusted]
    #[flux::sig(fn (&amp;BV32[@x], &amp;BV32[@y]) -&gt; bool[bv_ugt(x, y)])]
    fn gt(&amp;self, other: &amp;Self) -&gt; bool {
        self.0 &gt; other.0
    }
}

#[flux::sig(fn (BV32[@x]) -&gt; bool[bv_ule(x, x)])]
pub fn trivial_le(x: BV32) -&gt; bool {
    x &lt;= x
}

#[flux::sig(fn (BV32[@x]) -&gt; bool[bv_ult(x, x)])]
pub fn trivial_lt(x: BV32) -&gt; bool {
    x &lt; x
}

#[flux::sig(fn (BV32[@x]) -&gt; bool[bv_uge(x, x)])]
pub fn trivial_ge(x: BV32) -&gt; bool {
    x &lt;= x
}

#[flux::sig(fn (BV32[@x]) -&gt; bool[bv_ugt(x, x)])]
pub fn trivial_gt(x: BV32) -&gt; bool {
    x &lt; x
}

#[flux::sig(fn (BV32[@x], BV32[@y]) -&gt; bool[
    bv_ule(x, bv_int_to_bv32(10))
    &amp;&amp; 
    bv_uge(y, bv_int_to_bv32(20))
    &amp;&amp;
    bv_ult(x, bv_int_to_bv32(11))
    &amp;&amp;
    bv_ugt(y, bv_int_to_bv32(21))
])]
pub fn real_example(x: BV32, y: BV32) -&gt; bool {
    x &lt;= BV32::new(10) &amp;&amp; y &gt;= BV32::new(20) &amp;&amp; x &lt; BV32::new(11) &amp;&amp; y &gt; BV32::new(21)
}


#[flux_rs::sig(fn (BV32[@x], BV32[@y]) -&gt; bool[true] requires bv_ult(x, y) &amp;&amp; bv_ugt(x, bv_int_to_bv32(0x20)) &amp;&amp; bv_ult(y, bv_int_to_bv32(0xFF)))]
fn lt_imp(x: BV32, y: BV32) -&gt; bool {
    x - BV32::new(0x20) &lt; y + BV32::new(0x20)
}

#[flux_rs::sig(fn (BV32[@x], BV32[@y]) -&gt; bool[true] requires bv_ule(x, y) &amp;&amp; bv_uge(x, bv_int_to_bv32(0x20)) &amp;&amp; bv_ule(y, bv_int_to_bv32(0xFF)))]
fn le_imp(x: BV32, y: BV32) -&gt; bool {
    x - BV32::new(0x20) &lt;= y + BV32::new(0x20)
}

#[flux_rs::sig(fn (BV32[@x], BV32[@y]) -&gt; bool[true] requires bv_ugt(x, y) &amp;&amp; bv_ugt(y, bv_int_to_bv32(0x20)) &amp;&amp; bv_ult(x, bv_int_to_bv32(0xFF)))]
fn gt_imp(x: BV32, y: BV32) -&gt; bool {
    x + BV32::new(0x20) &gt; y - BV32::new(0x20)
}

#[flux_rs::sig(fn (BV32[@x], BV32[@y]) -&gt; bool[true] requires bv_uge(x, y) &amp;&amp; bv_uge(y, bv_int_to_bv32(0x20)) &amp;&amp; bv_ule(x, bv_int_to_bv32(0xFF)))]
fn ge_imp(x: BV32, y: BV32) -&gt; bool {
    x + BV32::new(0x20) &gt;= y - BV32::new(0x20)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="specification-functions"><a class="header" href="#specification-functions">Specification functions</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use flux_rs::{attrs::*, bitvec::BV32};

defs! {
    fn is_pow2(x: bitvec&lt;32&gt;) -&gt; bool {
        (x &gt; 0) &amp;&amp; ((x &amp; x - 1) == 0)
    }
}

#[sig(fn(x: BV32) requires is_pow2(x) &amp;&amp; 8 &lt;= x ensures x % 8 == 0)]
fn theorem_pow2_octet(x: BV32) {}
<span class="boring">}</span></code></pre></pre>
<h3 id="extensions"><a class="header" href="#extensions">Extensions</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// https://github.com/flux-rs/flux/issues/686

#[allow(dead_code)]
#[flux::sig(fn(x: bool[true]))]
pub fn assert(_x: bool) {}

#[flux::opaque]
#[flux::refined_by(v: bitvec&lt;32&gt;)]
struct Register {
    inner: u32,
}

impl Register {
    #[flux::sig(fn(u32[@n]) -&gt; Register[bv_int_to_bv32(n)])]
    #[flux::trusted]
    fn new(v: u32) -&gt; Self {
        Register { inner: v }
    }

    #[flux::sig(fn(&amp;Register[@n]) -&gt; u64[bv_bv64_to_int(bv_zero_extend_32_to_64(n))])]
    #[flux::trusted]
    fn zero_extend(&amp;self) -&gt; u64 {
        self.inner as u64
    }

    #[flux::sig(fn(&amp;Register[@n]) -&gt; u64[bv_bv64_to_int(bv_sign_extend_32_to_64(n))])]
    #[flux::trusted]
    fn sign_extend(&amp;self) -&gt; u64 {
        self.inner as i32 as i64 as u64
    }
}

pub fn test_bv_extensions() {
    let r = Register::new(u32::MAX);
    assert(r.zero_extend() == u32::MAX as u64);
    assert(r.zero_extend() == 12); //~ ERROR refinement type
    assert(r.sign_extend() == u64::MAX);
    assert(r.sign_extend() == 12); //~ ERROR refinement type
}
<span class="boring">}</span></code></pre></pre>
<h3 id="bitvector-constants"><a class="header" href="#bitvector-constants">Bitvector Constants</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![flux::defs(
<span class="boring">fn main() {
</span>    fn is_start(x:bitvec&lt;32&gt;) -&gt; bool { x == START }
)]

#[flux::opaque]
#[flux::refined_by(val: bitvec&lt;32&gt;)]
pub struct BV32(u32);

impl BV32 {
    #[flux::trusted]
    #[flux::sig(fn (x:u32) -&gt; BV32[bv_int_to_bv32(x)])]
    const fn new(val: u32) -&gt; Self {
        BV32(val)
    }
}

#[flux_rs::constant(bv_int_to_bv32(0x4567))]
pub const START: BV32 = BV32::new(0x4567);

#[flux_rs::sig(fn () -&gt; BV32[START])]
pub fn test1() -&gt; BV32 {
    BV32::new(0x4567)
}

#[flux_rs::sig(fn () -&gt; BV32{v: is_start(v)})]
pub fn test2() -&gt; BV32 {
    BV32::new(0x4567)
}

#[flux_rs::sig(fn () -&gt; BV32{v: is_start(v)})]
pub fn test3() -&gt; BV32 {
    BV32::new(0x4568) //~ ERROR: refinement type
}
<span class="boring">}</span></code></pre></pre>
<h2 id="char-literals"><a class="header" href="#char-literals"><code>char</code> Literals</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn() -&gt; char['a'])]
pub fn char00() -&gt; char {
    'a'
}

#[flux::sig(fn(c: char{v: 'a' &lt;= v &amp;&amp; v &lt;= 'z'}) -&gt; bool[true])]
pub fn lowercase(c: char) -&gt; bool {
    'c' == 'c'
}
<span class="boring">}</span></code></pre></pre>
<h2 id="string-literals"><a class="header" href="#string-literals"><code>String</code> Literals</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn (&amp;str["cat"]))]
fn require_cat(_x: &amp;str) {}

pub fn test_cat() {
    require_cat("cat");
    require_cat("dog"); //~ ERROR refinement type
}

#[flux::sig(fn (&amp;str[@a], &amp;{str[@b] | a == b}))]
fn require_eq(_x: &amp;str, _y: &amp;str) {}

pub fn test_eq() {
    require_eq("a", "a");
    require_eq("a", "b"); //~ ERROR refinement type
}
<span class="boring">}</span></code></pre></pre>
<h2 id="extern-specs"><a class="header" href="#extern-specs">Extern Specs</a></h2>
<p>The <code>extern_spec</code> is used to provide <code>flux</code> signatures for functions defined in <em>external</em> crates. See the <a href="specs.html">specifications guide</a> for more details.</p>
<h3 id="functions"><a class="header" href="#functions">Functions</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::slice::from_ref;

use flux_rs::extern_spec;

#[extern_spec]
#[flux::sig(fn(&amp;T) -&gt; &amp;[T][1])]
fn from_ref&lt;T&gt;(s: &amp;T) -&gt; &amp;[T];

#[flux::sig(fn(&amp;i32) -&gt; &amp;[i32]{n: n &gt; 0})]
pub fn test(x: &amp;i32) -&gt; &amp;[i32] {
    from_ref(x)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="options"><a class="header" href="#options">Options</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use flux_rs::extern_spec;

#[extern_spec]
#[flux::refined_by(b:bool)]
enum Option&lt;T&gt; {
    #[flux::variant(Option&lt;T&gt;[false])]
    None,
    #[flux::variant({T} -&gt; Option&lt;T&gt;[true])]
    Some(T),
}

#[extern_spec]
impl&lt;T&gt; Option&lt;T&gt; {
    #[sig(fn(&amp;Option&lt;T&gt;[@b]) -&gt; bool[b])]
    const fn is_some(&amp;self) -&gt; bool;

    #[sig(fn(&amp;Option&lt;T&gt;[@b]) -&gt; bool[!b])]
    const fn is_none(&amp;self) -&gt; bool;
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[path = "../../lib/option.rs"]
mod option;

#[flux::trusted]
#[flux::sig(fn(i32{v: false}) -&gt; T)]
pub fn never&lt;T&gt;(_: i32) -&gt; T {
    loop {}
}

#[flux::sig(fn(x:Option&lt;T&gt;[true]) -&gt; T)]
pub fn my_unwrap&lt;T&gt;(x: Option&lt;T&gt;) -&gt; T {
    match x {
        Option::Some(v) =&gt; v,
        Option::None =&gt; never(0),
    }
}

#[flux::sig(fn(T) -&gt; Option&lt;T&gt;[true])]
fn my_some&lt;T&gt;(x: T) -&gt; Option&lt;T&gt; {
    Option::Some(x)
}

#[flux::sig(fn(bool[true]))]
fn assert(_b: bool) {}

pub fn test1() {
    let x = my_some(42);
    let y = my_unwrap(x);
    assert(y == 42);
}

pub fn test3() {
    let x = Option::Some(42);
    let y = my_unwrap(x);
    assert(y == 42);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="vec"><a class="header" href="#vec">Vec</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use flux_rs::extern_spec;

#[extern_spec]
#[flux::refined_by(b:bool)]
enum Option&lt;T&gt; {
    #[flux::variant(Option&lt;T&gt;[false])]
    None,
    #[flux::variant({T} -&gt; Option&lt;T&gt;[true])]
    Some(T),
}

#[extern_spec]
impl&lt;T&gt; Option&lt;T&gt; {
    #[sig(fn(&amp;Option&lt;T&gt;[@b]) -&gt; bool[b])]
    const fn is_some(&amp;self) -&gt; bool;

    #[sig(fn(&amp;Option&lt;T&gt;[@b]) -&gt; bool[!b])]
    const fn is_none(&amp;self) -&gt; bool;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="structs-1"><a class="header" href="#structs-1">Structs</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Testing we can add external specs to "transparent" structs.

use flux_rs::extern_spec;

#[extern_spec(std::ops)]
#[refined_by(start: Idx, end: Idx)]
struct Range&lt;Idx&gt; {
    #[field(Idx[start])]
    start: Idx,
    #[field(Idx[end])]
    end: Idx,
}

#[extern_spec(std::ops)]
#[generics(Idx as base)]
impl&lt;Idx: PartialOrd&lt;Idx&gt;&gt; Range&lt;Idx&gt; {
    // This specification is actually unsound for `Idx`s where the `PartialOrd` implementation doesn't
    // match the logical `&lt;`.
    #[sig(fn(&amp;Range&lt;Idx&gt;[@r]) -&gt; bool[!(r.start &lt; r.end)])]
    fn is_empty(&amp;self) -&gt; bool;
}

#[flux::sig(fn(bool[true]))]
fn assert(_: bool) {}

fn test00() {
    let r = 0..1;
    assert(!r.is_empty());
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Extern spec of a type with a lifetime

use std::slice::Iter;

use flux_rs::*;

#[extern_spec]
#[refined_by(len: int)]
struct Iter&lt;'a, T&gt;;

#[extern_spec]
impl&lt;'a, T&gt; Iter&lt;'a, T&gt; {
    #[spec(fn as_slice(&amp;Iter&lt;T&gt;[@n]) -&gt; &amp;[T][n])]
    fn as_slice(v: &amp;Iter&lt;'a, T&gt;) -&gt; &amp;'a [T];
}

#[extern_spec]
impl&lt;T&gt; [T] {
    #[spec(fn iter(&amp;[T][@n]) -&gt; Iter&lt;T&gt;[n])]
    fn iter(v: &amp;[T]) -&gt; Iter&lt;'_, T&gt;;
}

#[spec(fn test00(x: &amp;[i32][@n]) -&gt; &amp;[i32][n])]
fn test00(x: &amp;[i32]) -&gt; &amp;[i32] {
    x.iter().as_slice()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="impls"><a class="header" href="#impls">Impls</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use flux_rs::extern_spec;

#[extern_spec]
#[flux::refined_by(len: int)]
struct String;

#[extern_spec]
impl String {
    #[flux::sig(fn() -&gt; String[0])]
    fn new() -&gt; String;

    #[flux::sig(fn(&amp;String[@n]) -&gt; usize[n])]
    fn len(s: &amp;String) -&gt; usize;

    #[flux::sig(fn(&amp;String[@n]) -&gt; bool[n == 0])]
    fn is_empty(s: &amp;String) -&gt; bool;

    #[flux::sig(fn(s: &amp;strg String[@n], char) ensures s: String[n+1])]
    fn push(s: &amp;mut String, c: char);

    #[flux::sig(fn(s: &amp;strg String[@n]) -&gt; Option&lt;char&gt;
                requires n &gt; 0
                ensures s: String[n-1])]
    fn pop(s: &amp;mut String) -&gt; Option&lt;char&gt;;

    #[flux::sig(fn(&amp;String[@n]) -&gt; &amp;[u8][n])]
    fn as_bytes(s: &amp;String) -&gt; &amp;[u8];
}

#[extern_spec]
impl&lt;T&gt; [T] {
    #[flux::sig(fn(&amp;[T][@n]) -&gt; usize[n])]
    fn len(v: &amp;[T]) -&gt; usize;

    #[flux::sig(fn(&amp;[T][@n]) -&gt; bool[n == 0])]
    fn is_empty(v: &amp;[T]) -&gt; bool;
}

#[flux::sig(fn(bool[@b]) requires b)]
pub fn assert_true(_: bool) {}

pub fn test_string() {
    let mut s = String::new();
    assert_true(s.is_empty());
    assert_true(s.as_bytes().is_empty());
    s.push('h');
    s.push('i');
    assert_true(s.len() == 2);
    s.pop();
    assert_true(s.len() == 1);
    s.pop();
    assert_true(s.is_empty());
    assert_true(s.as_bytes().is_empty());
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//@aux-build:extern_spec_impl01_aux.rs

extern crate extern_spec_impl01_aux;

use extern_spec_impl01_aux::MyTrait;
use flux_rs::extern_spec;

#[extern_spec]
impl&lt;T&gt; MyTrait for Vec&lt;T&gt; {
    #[flux::sig(fn() -&gt; i32[10])]
    fn foo() -&gt; i32;
}

#[flux::sig(fn () -&gt; i32[10])]
pub fn test_ok() -&gt; i32 {
    &lt;Vec&lt;i32&gt; as MyTrait&gt;::foo()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="traits"><a class="header" href="#traits">Traits</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use flux_rs::*;

#[extern_spec(std::cmp)]
#[generics(Self as base, Rhs as base)]
#[assoc(fn eq_rel(lhs: Self, rhs: Rhs) -&gt; bool)]
trait PartialEq&lt;Rhs&gt; {
    #[sig(fn(&amp;Self[@lhs], &amp;Rhs[@rhs]) -&gt; bool[&lt;Self as PartialEq&lt;Rhs&gt;&gt;::eq_rel(lhs, rhs)])]
    fn eq(&amp;self, other: &amp;Rhs) -&gt; bool;
}

#[refined_by(n: int)]
struct MyInt(#[field(i32[n])] i32);

#[assoc(fn eq_rel(lhs: MyInt, rhs: MyInt) -&gt; bool { lhs == rhs })]
impl PartialEq for MyInt {
    #[sig(fn(&amp;Self[@lhs], &amp;MyInt[@rhs]) -&gt; bool[&lt;MyInt as PartialEq&lt;MyInt&gt;&gt;::eq_rel(lhs, rhs)])]
    fn eq(&amp;self, other: &amp;MyInt) -&gt; bool {
        self.0 == other.0
    }
}

#[sig(fn(x: T, y: T) -&gt; bool[&lt;T as PartialEq&lt;T&gt;&gt;::eq_rel(x, y)])]
fn test00&lt;T: PartialEq&gt;(x: T, y: T) -&gt; bool {
    x == y
}

#[sig(fn(x: MyInt, y: MyInt) -&gt; bool[x == y])]
fn test01(x: MyInt, y: MyInt) -&gt; bool {
    test00(x, y)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="for-loops-with-range-ij"><a class="header" href="#for-loops-with-range-ij"><code>for</code> loops with range <code>i..j</code></a></h3>
<p>To see how <code>flux</code> handles <code>for i in 0..n</code> style loops:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(step_trait)]
#![allow(unused)]

<span class="boring">fn main() {
</span>#[path = "../../lib/iterator.rs"]
mod iterator;

#[flux_rs::sig(fn (bool[true]))]
fn assert(b: bool) {}

fn donald() {
    let n: i32 = 10;
    let mut thing = 0..n;
    let a = thing.next().unwrap();
    assert(a == 0);
    let b = thing.next().unwrap();
    assert(b == 1);
    let c = thing.next().unwrap();
    assert(c == 2);
}

#[flux_rs::sig(fn (n:i32{n == 99}))]
fn goofy(n: i32) {
    let mut thing = 0..n;
    let a0 = thing.end;
    assert(a0 == n);
    while let Some(i) = thing.next() {
        assert(0 &lt;= i);
        assert(i &lt; n);
    }
}

#[flux_rs::sig(fn (n:i32{n == 99}))]
fn mickey(n: i32) {
    for i in 0..n {
        assert(0 &lt;= i);
        assert(i &lt; n);
    }
}

#[flux_rs::trusted]
fn cond() -&gt; bool {
    todo!()
}

fn test(len: i32) {
    if len &gt;= 0 {
        let mut del = 0;
        for i in 0..len {
            assert(del &lt;= i);
            if cond() {
                del += 1;
            }
        }
        assert(del &lt;= len)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="associated-refinements"><a class="header" href="#associated-refinements">Associated Refinements</a></h2>
<h3 id="basic"><a class="header" href="#basic">Basic</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![allow(dead_code)]

<span class="boring">fn main() {
</span>use flux_rs::attrs::*;

trait MyTrait {
    #![reft(fn f(x: int) -&gt; int)]
    //
}

struct Add1;

impl MyTrait for Add1 {
    #![reft(fn f(x: int) -&gt; int { x + 1 })]
    //
}

#[sig(fn(x: i32{v: v == &lt;Add1 as MyTrait&gt;::f(0) }))]
fn test00(_x: i32) {}

fn test01() {
    test00(1);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="check-subtyping-at-impl"><a class="header" href="#check-subtyping-at-impl">Check Subtyping at Impl</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// test that implementations with extra const generics work as expected

use flux_rs::attrs::*;

#[reft(fn p(x: int) -&gt; bool)]
trait MyTrait {
    #[sig(fn() -&gt; i32{ v: &lt;Self as MyTrait&gt;::p(v) })]
    fn method() -&gt; i32;
}

struct MyStruct&lt;const N: i32&gt;;

// This implementation requires proving `x == N =&gt; x &gt;= N`
#[reft(fn p(x: int) -&gt; bool { x &gt;= N })]
impl&lt;const N: i32&gt; MyTrait for MyStruct&lt;N&gt; {
    #[sig(fn() -&gt; i32{v: v == N})]
    fn method() -&gt; i32 {
        N
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="default"><a class="header" href="#default">Default</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use flux_rs::attrs::*;

pub trait MyTrait {
    #![reft(fn f(x: int) -&gt; int { x + 1 })]
    //
}

// -----------------------------------------------------------------------------

pub struct Add1;

// Use the "default" assoc reft for Add1
impl MyTrait for Add1 {}

#[flux::sig(fn() -&gt; i32{v: v == &lt;Add1 as MyTrait&gt;::f(0)})]
pub fn test1_ok() -&gt; i32 {
    1
}

#[flux::sig(fn() -&gt; i32{v: v == &lt;Add1 as MyTrait&gt;::f(0)})]
pub fn test1_fail() -&gt; i32 {
    99 //~ ERROR: refinement type error
}

// -----------------------------------------------------------------------------

pub struct Add2;

// Specify a custom assoc reft for Add2
impl MyTrait for Add2 {
    #![reft(fn f(x: int) -&gt; int { x + 2 })]
    //
}

#[flux::sig(fn() -&gt; i32{v: v == &lt;Add2 as MyTrait&gt;::f(0)})]
pub fn test2() -&gt; i32 {
    2
}
<span class="boring">}</span></code></pre></pre>
<h3 id="use-in-extern-spec"><a class="header" href="#use-in-extern-spec">Use in Extern Spec</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use flux_rs::*;

#[extern_spec(std::cmp)]
#[generics(Self as base, Rhs as base)]
#[assoc(fn eq_rel(lhs: Self, rhs: Rhs) -&gt; bool)]
trait PartialEq&lt;Rhs&gt; {
    #[sig(fn(&amp;Self[@lhs], &amp;Rhs[@rhs]) -&gt; bool[&lt;Self as PartialEq&lt;Rhs&gt;&gt;::eq_rel(lhs, rhs)])]
    fn eq(&amp;self, other: &amp;Rhs) -&gt; bool;
}

#[refined_by(n: int)]
struct MyInt(#[field(i32[n])] i32);

#[assoc(fn eq_rel(lhs: MyInt, rhs: MyInt) -&gt; bool { lhs == rhs })]
impl PartialEq for MyInt {
    #[sig(fn(&amp;Self[@lhs], &amp;MyInt[@rhs]) -&gt; bool[&lt;MyInt as PartialEq&lt;MyInt&gt;&gt;::eq_rel(lhs, rhs)])]
    fn eq(&amp;self, other: &amp;MyInt) -&gt; bool {
        self.0 == other.0
    }
}

#[sig(fn(x: T, y: T) -&gt; bool[&lt;T as PartialEq&lt;T&gt;&gt;::eq_rel(x, y)])]
fn test00&lt;T: PartialEq&gt;(x: T, y: T) -&gt; bool {
    x == y
}

#[sig(fn(x: MyInt, y: MyInt) -&gt; bool[x == y])]
fn test01(x: MyInt, y: MyInt) -&gt; bool {
    test00(x, y)
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::{
    alloc::{Allocator, Global},
    ops::{Index, IndexMut},
    slice::{Iter, SliceIndex},
};

use flux_rs::extern_spec;

#[extern_spec]
#[flux::refined_by(len: int)]
struct Vec&lt;T, A: Allocator = Global&gt;;

#[extern_spec]
#[flux::assoc(fn in_bounds(idx: Self, v: T) -&gt; bool)]
trait SliceIndex&lt;T&gt;
where
    T: ?Sized,
{
}

#[extern_spec]
#[flux::assoc(fn in_bounds(idx: int, len: int) -&gt; bool {idx &lt; len} )]
impl&lt;T&gt; SliceIndex&lt;[T]&gt; for usize {}

#[extern_spec]
impl&lt;T, I: SliceIndex&lt;[T]&gt;, A: Allocator&gt; Index&lt;I&gt; for Vec&lt;T, A&gt; {
    #[flux::sig(fn(&amp;Vec&lt;T, A&gt;[@len], {I[@idx] | &lt;I as SliceIndex&lt;[T]&gt;&gt;::in_bounds(idx, len)}) -&gt; _)]
    fn index(z: &amp;Vec&lt;T, A&gt;, index: I) -&gt; &amp;&lt;I as SliceIndex&lt;[T]&gt;&gt;::Output;
}

#[extern_spec]
impl&lt;T, I: SliceIndex&lt;[T]&gt;, A: Allocator&gt; IndexMut&lt;I&gt; for Vec&lt;T, A&gt; {
    #[flux::sig(fn(&amp;mut Vec&lt;T,A&gt;[@len], {I[@idx] | &lt;I as SliceIndex&lt;[T]&gt;&gt;::in_bounds(idx, len)}) -&gt; _)]
    fn index_mut(z: &amp;mut Vec&lt;T, A&gt;, index: I) -&gt; &amp;mut &lt;I as SliceIndex&lt;[T]&gt;&gt;::Output;
}

//---------------------------------------------------------------------------------------

#[extern_spec]
impl&lt;T&gt; Vec&lt;T&gt; {
    #[flux::sig(fn() -&gt; Vec&lt;T&gt;[0])]
    fn new() -&gt; Vec&lt;T&gt;;
}

#[extern_spec]
impl&lt;T, A: Allocator&gt; Vec&lt;T, A&gt; {
    #[flux::sig(fn(self: &amp;strg Vec&lt;T, A&gt;[@n], T) ensures self: Vec&lt;T, A&gt;[n+1])]
    fn push(v: &amp;mut Vec&lt;T, A&gt;, value: T);

    #[flux::sig(fn(&amp;Vec&lt;T, A&gt;[@n]) -&gt; usize[n])]
    fn len(v: &amp;Vec&lt;T, A&gt;) -&gt; usize;
}

#[extern_spec]
impl&lt;'a, T, A: Allocator&gt; IntoIterator for &amp;'a Vec&lt;T, A&gt; {
    #[flux::sig(fn (&amp;Vec&lt;T, A&gt;[@n]) -&gt; &lt;&amp;Vec&lt;T, A&gt; as IntoIterator&gt;::IntoIter[0,n])]
    fn into_iter(v: &amp;'a Vec&lt;T, A&gt;) -&gt; &lt;&amp;'a Vec&lt;T, A&gt; as IntoIterator&gt;::IntoIter;
}

#[extern_spec]
#[flux::assoc(fn with_size(self: Self, n:int) -&gt; bool { self.len == n })]
impl&lt;T&gt; FromIterator&lt;T&gt; for Vec&lt;T&gt; {}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use flux_rs::extern_spec;

// Specs for std::slice::Iter and Enumerate
#[extern_spec(std::slice)]
#[refined_by(idx: int, len: int)]
struct Iter&lt;'a, T&gt;;

#[extern_spec(std::iter)]
#[refined_by(idx: int, inner: I)]
struct Enumerate&lt;I&gt;;

#[extern_spec(std::iter)]
#[refined_by(inner: I)]
struct Map&lt;I, F&gt;;

#[extern_spec]
#[flux::assoc(fn with_size(self: Self, n:int) -&gt; bool { true })] // default: don't know!
trait FromIterator&lt;A&gt; {}

#[extern_spec(std::iter)]
#[flux::assoc(fn size(self: Self) -&gt; int)]
#[flux::assoc(fn done(self: Self) -&gt; bool )]
#[flux::assoc(fn step(self: Self, other: Self) -&gt; bool )]
trait Iterator {
    #[flux::sig(fn(self: &amp;strg Self[@curr_s]) -&gt; Option&lt;Self::Item&gt;[!&lt;Self as Iterator&gt;::done(curr_s)] ensures self: Self{next_s: &lt;Self as Iterator&gt;::step(curr_s, next_s)})]
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    #[flux::sig(fn(Self[@s]) -&gt; Enumerate&lt;Self&gt;[0, s])]
    fn enumerate(self) -&gt; Enumerate&lt;Self&gt;
    where
        Self: Sized;

    #[flux::sig(fn(Self[@s], f: F) -&gt; Map&lt;Self, F&gt;[s])]
    fn map&lt;B, F&gt;(self, f: F) -&gt; Map&lt;Self, F&gt;
    where
        Self: Sized,
        F: FnMut(Self::Item) -&gt; B;

    #[flux::sig(fn (Self[@s]) -&gt; B{v: &lt;B as FromIterator&lt;Self::Item&gt;&gt;::with_size(v, &lt;Self as Iterator&gt;::size(s))})]
    fn collect&lt;B: FromIterator&lt;Self::Item&gt;&gt;(self) -&gt; B
    where
        Self: Sized;
}

#[extern_spec(std::slice)]
#[flux::assoc(fn size(x: Iter) -&gt; int { x.len - x.idx })]
#[flux::assoc(fn done(x: Iter) -&gt; bool { x.idx &gt;= x.len })]
#[flux::assoc(fn step(x: Iter, y: Iter) -&gt; bool { x.idx + 1 == y.idx &amp;&amp; x.len == y.len})]
impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    #[flux::sig(fn(self: &amp;strg Iter&lt;T&gt;[@curr_s]) -&gt; Option&lt;_&gt;[curr_s.idx &lt; curr_s.len] ensures self: Iter&lt;T&gt;{next_s: curr_s.idx + 1 == next_s.idx &amp;&amp; curr_s.len == next_s.len})]
    fn next(&amp;mut self) -&gt; Option&lt;&amp;'a T&gt;;
}

#[extern_spec(std::iter)]
#[flux::assoc(fn size(x: Enumerate&lt;I&gt;) -&gt; int { &lt;I as Iterator&gt;::size(x.inner) })]
#[flux::assoc(fn done(x: Enumerate&lt;I&gt;) -&gt; bool { &lt;I as Iterator&gt;::done(x.inner)})]
#[flux::assoc(fn step(x: Enumerate&lt;I&gt;, y: Enumerate&lt;I&gt;) -&gt; bool { &lt;I as Iterator&gt;::step(x.inner, y.inner)})]
impl&lt;I: Iterator&gt; Iterator for Enumerate&lt;I&gt; {
    #[flux::sig(fn(self: &amp;strg Enumerate&lt;I&gt;[@curr_s]) -&gt; Option&lt;(usize[curr_s.idx], _)&gt;[!&lt;I as Iterator&gt;::done(curr_s.inner)]
    ensures self: Enumerate&lt;I&gt;{next_s: curr_s.idx + 1 == next_s.idx &amp;&amp; &lt;I as Iterator&gt;::step(curr_s.inner, next_s.inner)})]
    fn next(&amp;mut self) -&gt; Option&lt;(usize, &lt;I as Iterator&gt;::Item)&gt;;
}

#[extern_spec(std::iter)]
#[flux::assoc(fn size(x: Map&lt;I&gt;) -&gt; int { &lt;I as Iterator&gt;::size(x.inner) })]
#[flux::assoc(fn done(x: Map&lt;I&gt;) -&gt; bool { &lt;I as Iterator&gt;::done(x.inner)})]
#[flux::assoc(fn step(x: Map&lt;I&gt;, y: Map&lt;I&gt;) -&gt; bool { &lt;I as Iterator&gt;::step(x.inner, y.inner)})]
impl&lt;B, I: Iterator, F: FnMut(I::Item) -&gt; B&gt; Iterator for Map&lt;I, F&gt; {} // orig: where F: FnMut(I::Item) -&gt; B {}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![allow(unused)]
#![feature(allocator_api)]

<span class="boring">fn main() {
</span>use std::{iter::Enumerate, slice::Iter};

#[path = "../../lib/option.rs"]
mod option;

#[path = "../../lib/slice.rs"]
mod slice;

#[path = "../../lib/vec.rs"]
mod vec;

#[path = "../../lib/iter.rs"]
mod iter;

#[flux::sig(fn(bool[true]))]
pub fn assert(_b: bool) {}

// Tests
#[flux::sig(fn(slice: &amp;[u8]{n: n &gt; 0}))]
fn test_iter1(slice: &amp;[u8]) {
    let mut iter = slice.iter();
    let next = iter.next();
    assert(next.is_some());
}

#[flux::sig(fn(slice: &amp;[u8]{n: n &gt; 1}))]
fn test_enumerate1(slice: &amp;[u8]) {
    assert(slice.len() &gt; 0);
    let mut enumer = slice.iter().enumerate();

    let next = enumer.next();
    assert(next.is_some());
    let (idx, _) = next.unwrap();
    assert(idx == 0);

    let next_next = enumer.next();
    assert(next_next.is_some());
    let (idx, _) = next_next.unwrap();
    assert(idx == 1);
}

#[flux::sig(fn(&amp;[usize][1]) )]
pub fn test_enumer2(slice: &amp;[usize]) {
    assert(slice.len() == 1);
    let mut enumer = slice.iter().enumerate();

    let next = enumer.next();
    assert(next.is_some());

    let next_next = enumer.next();
    assert(next_next.is_none())
}

#[flux::sig(fn(&amp;[usize][@n]) )]
pub fn test_enumer3(slice: &amp;[usize]) {
    let mut e = slice.iter().enumerate();
    while let Some((idx, _)) = e.next() {
        assert(idx &lt; slice.len())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="associated-types"><a class="header" href="#associated-types">Associated Types</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use flux_rs::attrs::*;

trait MyTrait {
    #![reft(fn f(x: int) -&gt; int)]
    //
}

struct Add1;

#[assoc(fn f(x: int) -&gt; int { x + 1 })]
impl MyTrait for Add1 {}

#[sig(fn(x: i32{v: v == &lt;Add1 as MyTrait&gt;::f(0) }))]
fn test00(x: i32) {}

fn test01() {
    test00(0); //~ ERROR refinement type error
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Testing that we properly map generics in trait's default associated refinement
// body into the impl.

use flux_rs::attrs::*;

trait MyTrait {
    #![reft(fn p(x: Self) -&gt; bool { true })]

    #[sig(fn(&amp;Self{v: &lt;Self as MyTrait&gt;::p(v)}))]
    fn method(&amp;self);
}

impl MyTrait for i32 {
    #[sig(fn(&amp;Self{v: &lt;Self as MyTrait&gt;::p(v)}))]
    fn method(&amp;self) {}
}

impl&lt;T&gt; MyTrait for S&lt;T&gt; {
    #[sig(fn(&amp;Self{v: &lt;Self as MyTrait&gt;::p(v)}))]
    fn method(&amp;self) {}
}

struct S&lt;T&gt; {
    f: T,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="refined-associated-types-1"><a class="header" href="#refined-associated-types-1">Refined Associated Types</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use flux_rs::*;

#[assoc(fn can_fit(self: Self, animal: Self::Animal) -&gt; bool)]
trait Barn {
    type Animal;

    #[sig(fn(self: &amp;mut Self[@barn], animal: Self::Animal{ &lt;Self as Barn&gt;::can_fit(barn, animal) }))]
    fn put_animal_in_house(&amp;mut self, animal: Self::Animal);
}

#[refined_by(size: int)]
struct Horse {
    #[field(i32[size])]
    size: i32,
}

#[refined_by(max_size: int)]
struct HorseBarn {
    #[field(i32[max_size])]
    max_size: i32,
}

#[assoc(fn can_fit(self: HorseBarn, horse: Horse) -&gt; bool { horse.size &lt;= self.max_size })]
impl Barn for HorseBarn {
    type Animal = Horse;

    #[trusted]
    #[sig(fn(self: &amp;mut Self[@barn], horse: Horse { horse.size &lt;= barn.max_size}))]
    fn put_animal_in_house(&amp;mut self, horse: Horse) {}
}

fn test00() {
    let mut barn = HorseBarn { max_size: 20 };
    let horse = Horse { size: 10 };

    barn.put_animal_in_house(horse);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="checking-overflows"><a class="header" href="#checking-overflows">Checking Overflows</a></h2>
<p>You can switch on overflow checking</p>
<ul>
<li><em>globally</em> <a href="http://localhost:3000/guide/run.html?highlight=cache#flux-flags">with a flag</a> or</li>
<li><em>locally</em> with an attribute as shown below</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const MAX: u32 = std::u32::MAX;

// Error on this as it may overflow
#[flux::opts(check_overflow = true)]
#[flux::sig(fn (u32[@x], u32[@y], u32[@z]) -&gt; u32[x + y + z] requires x + y + z &lt;= MAX)]
fn add_three(x: u32, y: u32, z: u32) -&gt; u32 {
    x + y + z
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::opts(check_overflow = true)]
mod my_mod {
    const MAX: u32 = std::u32::MAX;

    #[flux::sig(fn(u32[@x], u32[@y]) -&gt; u32[x + y] requires x + y &lt;= MAX)]
    fn add(x: u32, y: u32) -&gt; u32 {
        x + y
    }

    #[flux::sig(fn(u32[@x]) -&gt; u32[x + 2] requires x + 2 &lt;= MAX)]
    fn add2(x: u32) -&gt; u32 {
        x + 2
    }
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const MAX: u32 = std::u32::MAX;

#[flux_rs::refined_by(inner: int)]
struct MyStruct {
    #[field(u32[inner])]
    inner: u32,
}

impl MyStruct {
    fn add1(&amp;self) -&gt; u32 {
        self.inner + 1
    }

    // Error as this may overflow
    #[flux::opts(check_overflow = true)]
    #[flux::sig(fn (&amp;MyStruct[@inner]) -&gt; u32[inner + 2] requires inner + 2 &lt;= MAX)]
    fn add2(&amp;self) -&gt; u32 {
        self.inner + 2
    }
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const MAX: u32 = std::u32::MAX;

struct MyStruct {
    inner: u32,
}

#[flux::opts(check_overflow = true)]
trait MyTrait {
    #[flux::sig(fn(u32[@x], { u32[@y] | x + y &lt;= MAX }) -&gt; u32[x + y] )]
    fn add(x: u32, y: u32) -&gt; u32;
}

impl MyTrait for MyStruct {
    #[flux::sig(fn(u32[@x], { u32[@y] | x + y &lt;= MAX }) -&gt; u32[x + y] )]
    fn add(x: u32, y: u32) -&gt; u32 {
        x + y
    }
}
<span class="boring">}</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../guide/specs.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../dev/develop.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../guide/specs.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../dev/develop.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../js/flux.js"></script>


    </div>
    </body>
</html>
