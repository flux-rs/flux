<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Flux Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="css/flux.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Flux Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <img src="img/logo-wide.svg" class="flux-logo" alt="Flux Logo">
<p>Flux is a <strong>refinement type checker</strong> for Rust that lets you <em>specify</em>
a range of correctness properties and have them be <em>verified</em> at compile
time.</p>
<p>See the <strong>examples</strong>  -- listed in the summary on the left -- to learn about Refinement types and Rust.</p>
<p>You can try it online <a href="https://flux.goto.ucsd.edu/">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing-flux"><a class="header" href="#installing-flux">Installing Flux</a></h1>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<ul>
<li><a href="https://rustup.rs/">rustup</a></li>
<li><a href="https://github.com/ucsd-progsys/liquid-fixpoint">liquid-fixpoint</a></li>
<li><a href="https://github.com/Z3Prover/z3">z3</a></li>
</ul>
<p>Be sure that the <code>liquid-fixpoint</code> and <code>z3</code> executables are in your <code>$PATH</code>.</p>
<h2 id="installing"><a class="header" href="#installing">Installing</a></h2>
<p>The only way to use Flux is to build it from source.</p>
<p>First you need to clone the repository</p>
<pre><code class="language-bash">git clone https://github.com/flux-rs/flux
cd flux
</code></pre>
<p>To build the source you need a nightly version of <code>rustc</code>.
We pin the version using a <a href="https://github.com/flux-rs/flux/blob/main/rust-toolchain">toolchain file</a> (more info <a href="https://rust-lang.github.io/rustup/overrides.html#the-toolchain-file">here</a>).
If you are using <code>rustup</code>, no special action is needed as it should install the correct <code>rustc</code> version and components based on the information on that file.</p>
<p>Next, run the following to build and install <code>flux</code> binaries</p>
<pre><code class="language-bash">cargo xtask install
</code></pre>
<p>This will install two binaries <code>flux</code> and <code>cargo-flux</code> in your cargo home. These two binaries should be used
respectively to run Flux on either a single file or on a project using cargo. The installation process will
also copy some files to <code>$HOME/.flux</code>.</p>
<p>In order to use Flux refinement attributes in a Cargo project, you will need to add the
following to your Cargo.toml</p>
<pre><code class="language-toml">[dependencies]
flux-rs = { git  = "https://github.com/flux-rs/flux.git" }
</code></pre>
<p>This will add the procedural macros Flux uses to your project; it is not a susbstitute
for installing Flux, which must still be done.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-flux"><a class="header" href="#running-flux">Running Flux</a></h1>
<p>You can run <code>flux</code> on a single file or entire crate.</p>
<h2 id="running-on-a-file-flux"><a class="header" href="#running-on-a-file-flux">Running on a File: <code>flux</code></a></h2>
<p>You can use <code>flux</code> as you would use <code>rustc</code>.
For example, the following command checks the file <code>test.rs</code>.</p>
<pre><code class="language-bash">flux path/to/test.rs
</code></pre>
<p>The flux binary accepts the same flags as <code>rustc</code>.
You could for example check a file as a library instead of a binary like so</p>
<pre><code class="language-bash">flux --crate-type=lib path/to/test.rs
</code></pre>
<h3 id="refinement-annotations-on-a-file"><a class="header" href="#refinement-annotations-on-a-file">Refinement Annotations on a File</a></h3>
<p>When running flux on a file with <code>flux path/to/test.rs</code>, refinement annotations should be prefixed with <code>flux::</code>.</p>
<p>For example, the refinement below will only work when running <code>flux</code> which is intended for use on a single file.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn(x: i32) -&gt; i32{v: x &lt; v})]
fn inc(x: i32) -&gt; i32 {
    x - 1
}
<span class="boring">}</span></code></pre></pre>
<h2 id="running-on-a-package-cargo-flux"><a class="header" href="#running-on-a-package-cargo-flux">Running on a package: <code>cargo-flux</code></a></h2>
<p>Flux is integrated with <code>cargo</code> and can be invoked in a package as follows:</p>
<pre><code class="language-bash">cargo flux
</code></pre>
<p>By default, Flux won't verify a package unless it's explicitly enabled in the manifest.
To do so add the following to <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package.metadata.flux]
enabled = true
</code></pre>
<h3 id="refinement-annotations-on-a-cargo-projects"><a class="header" href="#refinement-annotations-on-a-cargo-projects">Refinement Annotations on a Cargo Projects</a></h3>
<p>Adding refinement annotations to cargo projects is simple. You can add <code>flux-rs</code> as a dependency in <code>Cargo.toml</code></p>
<pre><code class="language-toml">[dependencies]
flux-rs = { git  = "https://github.com/flux-rs/flux.git" }
</code></pre>
<p>Then, import attributes from <code>flux_rs</code> and add the appropriate refinement annoations.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use flux_rs::*;

#[sig(fn(x: i32) -&gt; i32{v: x &lt; v)]
fn inc(x: i32) -&gt; i32 {
    x - 1
}
<span class="boring">}</span></code></pre></pre>
<h2 id="a-tiny-example"><a class="header" href="#a-tiny-example">A tiny example</a></h2>
<p>The following example declares a function <code>inc</code>
that returns an integer greater than the input.
We use the nightly feature <code>register_tool</code>
to register the <code>flux</code> tool in order to
add refinement annotations to functions.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn(x: i32) -&gt; i32{v: x &lt; v})]
pub fn inc(x: i32) -&gt; i32 {
    x - 1
}
<span class="boring">}</span></code></pre></pre>
<p>You can save the above snippet in say <code>test0.rs</code> and then run</p>
<pre><code class="language-bash">flux --crate-type=lib path/to/test0.rs
</code></pre>
<p>you should see in your output</p>
<pre><code class="language-text">error[FLUX]: postcondition might not hold
 --&gt; test0.rs:3:5
  |
3 |     x - 1
  |     ^^^^^
</code></pre>
<p>as indeed <code>x - 1</code> is <em>not</em> greater than <code>x</code> as required by the output refinement <code>i32{v: x &lt; v}</code>.</p>
<p>If you fix the error by replacing <code>x - 1</code> with <code>x + 1</code>, you should get no errors
in the output (the output may be empty, but in this case no output is a good
thing).</p>
<p>Read <a href="guide/SUMMARY.html#learn">these chapters</a> to learn more about what you specify and verify with <code>flux</code>.</p>
<h2 id="a-note-about-the-flux-driver-binary"><a class="header" href="#a-note-about-the-flux-driver-binary">A note about the flux-driver binary</a></h2>
<p>The <code>flux-driver</code> binary is a <a href="https://rustc-dev-guide.rust-lang.org/rustc-driver.html?highlight=driver#the-rustc-driver-and-interface">rustc
driver</a>
(similar to how clippy works) meaning it uses rustc as a library to "drive"
compilation performing additional analysis along the way. Running the binary
requires dynamically linking a correct version of <code>librustc</code>. Thus, to avoid the
hassle you should never execute it directly. Instead, use <code>flux</code> or <code>cargo-flux</code>.</p>
<h2 id="editor-support"><a class="header" href="#editor-support">Editor Support</a></h2>
<p>This section assumes you have installed <code>cargo-flux</code>.</p>
<h3 id="rust-analyzer-in-vscode"><a class="header" href="#rust-analyzer-in-vscode">Rust-Analyzer in VSCode</a></h3>
<p>Add this to the workspace settings i.e. <code>.vscode/settings.json</code></p>
<pre><code class="language-json">{
  "rust-analyzer.check.overrideCommand": [
    "cargo",
    "flux",
    "--workspace",
    "--message-format=json-diagnostic-rendered-ansi"
  ]
}
</code></pre>
<p><strong>Note:</strong> Make sure to edit the paths in the above snippet to point to the correct locations on your machine.</p>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<h3 id="flux-flags"><a class="header" href="#flux-flags">Flux Flags</a></h3>
<p>The <code>flux</code> binary accepts configuration flags in the format <code>-Fname=value</code>. For boolean flags, the
<code>value</code> can be one of <code>y</code>, <code>yes</code>, <code>on</code>, <code>true</code>, <code>n</code>, <code>no</code>, <code>off</code>, <code>false</code>. Alternatively, the <code>value</code>
can be omitted which will default to <code>true</code>. For example, to set the solver to <code>cvc5</code> and enable
qualifier scrapping:</p>
<pre><code class="language-console">flux -Fsolver=cvc5 -Fscrape-quals path/to/file.rs
</code></pre>
<p>For all avilable flags, see  <a href="https://flux-rs.github.io/flux/doc/flux_config/flags/struct.Flags.html">https://flux-rs.github.io/flux/doc/flux_config/flags/struct.Flags.html</a></p>
<h3 id="cargo-projects"><a class="header" href="#cargo-projects">Cargo Projects</a></h3>
<p>When working with a Cargo project, some of the <a href="guide/run.html#Flux-Flags">flags</a> can be configured in the
<code>[package.metadata.flux]</code> table in <code>Cargo.toml</code>. For example, to enable query caching and set
<code>cvc5</code> as the solver:</p>
<pre><code class="language-toml"># Cargo.toml
[package.metadata.flux]
enabled = true
cache = true
solver = "cvc5"
</code></pre>
<p>Additionally, <code>cargo flux</code> searches for a configuration file called <code>flux.toml</code> with the same format
as the metadata table. The content of <code>flux.toml</code> takes precedence and it's  merged with the
content of the <code>metadata</code> table. Note that the content of <code>flux.toml</code> will override the <code>metadata</code>
for all crates, including dependencies. This behavior is likely to change in the future as we figure
out what configurations make sense to have per package and which should only affect the current execution
of <code>cargo flux</code>.</p>
<p>You can see the format of the <code>metadata</code> in <a href="https://flux-rs.github.io/flux/doc/flux_bin/struct.FluxMetadata.html">https://flux-rs.github.io/flux/doc/flux_bin/struct.FluxMetadata.html</a>.</p>
<h3 id="fluxflags-environement-variable"><a class="header" href="#fluxflags-environement-variable"><code>FLUXFLAGS</code> Environement Variable</a></h3>
<p>When running <code>cargo flux</code>, flags defined in <code>FLUXFLAGS</code> will be passed to all <code>flux</code> invocations,
for example, to print timing information for all crates checked by Flux:</p>
<pre><code class="language-console">FLUXFLAGS="-Ftimings" cargo flux
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flux-specification-guide"><a class="header" href="#flux-specification-guide">Flux Specification Guide</a></h1>
<p>This is a WIP guide to writing specifications in <code>flux</code>.</p>
<h2 id="refinement-types"><a class="header" href="#refinement-types">Refinement Types</a></h2>
<ul>
<li>
<p><strong>Indexed Type</strong>: An indexed type <code>B[r]</code> is composed of a base Rust type <code>B</code> and a refinement index <code>r</code>. The meaning of the index depends on the type. Some examples are</p>
<ul>
<li><code>i32[n]</code>: denotes the (singleton) set of <code>i32</code> values equal to <code>n</code>.</li>
<li><code>List&lt;T&gt;[n]</code>: values of type <code>List&lt;T&gt;</code> of length <code>n</code>.</li>
</ul>
</li>
<li>
<p><strong>Refinement parameter</strong>: Function signatures can be parametric on refinement variables. Refinement parameters are declared using the <code>@n</code> syntax. For example, the following signature:</p>
<p><code>fn(i32[@n]) -&gt; i32[n + 1]</code></p>
<p>binds <code>n</code> over the entire scope of the function to specify that it takes an <code>i32</code> equal to <code>n</code> and returns an <code>i32</code> equal to <code>n + 1</code>. This is analogous to languages like Haskell where a lower case letter can be used to quantify over a type, e.g., the type <code>a -&gt; a</code> in Haskell is polymorphic on the type <code>a</code> which is bound for the scope of the entire function type.</p>
</li>
<li>
<p><strong>Existential Type</strong>: An existential type <code>B{v: r(v)}</code> is composed of a base type <code>B</code>, a refinement variable <code>v</code> and a refinement predicate <code>r</code> on <code>v</code>. Intuitively, a Rust value <code>x</code> has type <code>B{v: r(v)}</code> if there exists a refinement value <code>a</code> such that <code>r(a)</code> holds and <code>x</code> has type <code>B[a]</code>.</p>
<ul>
<li><code>i32{v: v &gt; 0}</code>: set of positive <code>i32</code> values.</li>
<li><code>List&lt;T&gt;{v: v &gt; 0}</code>: set of non-empty lists.</li>
</ul>
</li>
<li>
<p><strong>Constraint Type</strong>: A constraint type has the form <code>{T | r}</code> where <code>T</code> is any type (not just a base type). Intuitively, a value has type <code>{T | r}</code> if it has type <code>T</code> and also <code>r</code> holds. They can be used to constraint a refinement parameter. For example, the following signature constraint the refinement parameter <code>n</code> to be less than <code>10</code>.</p>
<p><code>fn({i32[@n] | n &lt; 10}) -&gt; i32[n + 1]</code></p>
<p>Constraint types serve a similar role as existentials as they can also be used to constraint some
refinement value with a predicate, but an existential type can only be used to constraint refinement
variable that it bound locally, in contrast constraint types can be used to constraint a "non-local" parameter. This can be seen in the example above where the parameter <code>n</code> cannot be bound locally
because it has to be used in the return type.</p>
</li>
</ul>
<h2 id="argument-syntax"><a class="header" href="#argument-syntax">Argument Syntax</a></h2>
<p>The <code>@n</code> syntax used to declare refinements parameters can be hard to read sometimes. Flux also supports a syntax that let you bind refinement parameters using colons similar to the syntax used to declare arguments in a function. We call this <em>argument syntax</em>. This syntax desugars to one of the refinements forms discussed above. For example, the following signature</p>
<p><code>fn(x: i32, y: i32) -&gt; i32[x + y]</code></p>
<p>desugars to</p>
<p><code>fn(i32[@x], i32[@y]) -&gt; i32[x + y]</code></p>
<p>It is also possible to attach some constraint to the parameters when using argument syntax. For example,
to specify that <code>y</code> must be greater than <code>x</code> using argument syntax we can write:</p>
<p><code>fn(x: i32, y: i32{x &gt; y}) -&gt; i32[x + y]</code></p>
<p>This will desugar to:</p>
<p><code>fn(i32[@x], {i32[@y] | x &gt; y}) -&gt; i32[x + y]</code></p>
<h2 id="extern-specs"><a class="header" href="#extern-specs">Extern specs</a></h2>
<p>Sometimes you may want to refine a struct or function that outside your code. We
refer to such a specification as an "extern spec," which is short for "external
specification."</p>
<p>Flux right now has rudimentary support for extern specs: they are supported for
functions, impls, and structs. Impls are only supported for structs and if you
have multiple impls for a struct (such as <code>&amp;[T]</code> and <code>[T]</code>), those may conflict.
Structs only support opaque refinements.</p>
<p>Extern specs are given using <code>extern_spec</code> attribute macro, which is provided
by the procedural macros package <code>flux_rs</code>.</p>
<pre><code>use flux_rs::extern_spec;
</code></pre>
<h3 id="extern-functions"><a class="header" href="#extern-functions">Extern functions</a></h3>
<p>An example of refining an extern function can be found
<a href="https://github.com/flux-rs/flux/blob/d49a74dc59b2b9bb1dda01ee019d0ab9a66cdd89/flux-tests/tests/pos/surface/extern_spec_macro.rs">here</a>.</p>
<p>To define an extern spec on a function, you need to do three things, which
happen to correspond to each of the below lines.</p>
<pre><code>#[extern_spec(std::mem)]
#[flux_rs::sig(fn(&amp;mut i32[@a], &amp;mut i32{v : a &lt; v }) -&gt; ())]
fn swap(a: &amp;mut i32, b: &amp;mut i32);
</code></pre>
<ol>
<li>Add the <code>#[extern_spec]</code> attribute. This attribute optionally takes a path;
in the above example, this is <code>std::mem</code>. You can use this path to qualify
the function. So in the above example, the function we are targeting has the
full path of <code>std::mem::swap</code>.</li>
<li>Add a <code>#[flux_rs::sig(...)]</code> attribute. This is required for any extern spec on
a function. This signature behaves as if the <code>#[flux_rs::trusted]</code> attribute was
added, because we can't actually check the implementation. We just verify
some simple things, like that the function arguments have compatible types.</li>
<li>Write a function stub that matches the external function.</li>
</ol>
<p>If you do the above, you can use <code>std::mem::swap</code> as if it were refined by the
above type.</p>
<p>You shouldn't need to know the details, but here's how the macro works. It
parses the <code>std::mem</code> into a module path and then transforms the function into</p>
<pre><code>#[flux_rs::extern_spec]
#[flux_rs::sig(fn(&amp;mut i32[@a], &amp;mut i32{v : a &lt; v }) -&gt; ())]
#[allow(unused, dead_code)]
fn __flux_extern_spec_swap(a: &amp;mut i32, b: &amp;mut i32) {
    std::mem::swap(a, b)
}
</code></pre>
<p>It does this to get information about the function <code>std::mem::swap</code> and its
arguments (this turns out to be difficult to do without giving the compiler
something to inspect and type check).</p>
<h3 id="extern-structs-and-impls"><a class="header" href="#extern-structs-and-impls">Extern structs and impls</a></h3>
<p>An example of refining an extern struct and impl can be found
<a href="https://github.com/flux-rs/flux/blob/d49a74dc59b2b9bb1dda01ee019d0ab9a66cdd89/flux-tests/tests/pos/surface/extern_spec_impl.rs">here</a>.
A simpler example just involving structs can be found
<a href="https://github.com/flux-rs/flux/blob/d49a74dc59b2b9bb1dda01ee019d0ab9a66cdd89/flux-tests/tests/pos/surface/extern_spec_struct.rs">here</a>.</p>
<p>The syntax for an extern spec on a struct is very similar to that for a
function. Once again, each line in the example happens to correspond to a step.</p>
<pre><code>#[extern_spec(std::string)]
#[flux_rs::refined_by(len: int)]
struct String;
</code></pre>
<ol>
<li>Add the <code>#[extern_spec]</code> attribute. This attribute optionally takes a path;
in the above example, this is <code>std::string</code>. You can use this path to qualify
the function. So in the above example, the struct we are targeting has the
full path of <code>std::string::String</code>.</li>
<li>Add a <code>#[flux_rs::refined_by(...)]</code> attribute. This is required for any extern
spec on a struct. Right now these attributes behave as if they were opaque
(<code>#[flux_rs::opaque]</code>), although we may support non-opaque extern structs.</li>
<li>Write a stub for the extern struct.</li>
</ol>
<p>If you do the above, you can use <code>std::string::String</code> as if it were refined by
an integer index.</p>
<p>The syntax for an extern impl is a little different than that for functions or
structs.</p>
<pre><code>#[extern_spec(std::string)]
impl String {
    #[flux_rs::sig(fn() -&gt; String[0])]
    fn new() -&gt; String;

    #[flux_rs::sig(fn(&amp;String[@n]) -&gt; usize[n])]
    fn len(s: &amp;String) -&gt; usize;
}
</code></pre>
<ol>
<li>You still need to add the <code>#[extern_spec]</code> attribute, with the same optional
argument of the path as above.</li>
<li>You need to write out the <code>impl</code> block for the struct you want to refine.
This struct does not need an extern spec, since by refining the <code>impl</code> you're
only refining its methods.</li>
<li>Write an extern spec for each function you wish to refine (this may be a
subset). This is written just like a function extern spec with the caveat
that the <code>self</code> parameter is not presently supported. So for example, instead
of writing <code>fn len(&amp;self) -&gt; usize;</code>, you need to write <code>fn len(s: &amp;String) -&gt; usize;</code>.</li>
</ol>
<p>If you do the above, you can use the above methods of<code>std::string::String</code> as if
they were refined.</p>
<p>You shouldn't need to know the details, but here's how the above two macros expand.</p>
<p>For structs:</p>
<pre><code>#[flux_rs::extern_spec]
#[allow(unused, dead_code)]
#[flux_rs::refined_by(len: int)]
struct __FluxExternSpecString(std::string::String);
</code></pre>
<p>For impls (this was translated manually so there might be some bugs):</p>
<pre><code>#[allow(unused, dead_code)]
struct __FluxExternImplStructString;

#[allow(unused, dead_code)]
impl __FluxExternImplStructString {
    #[flux_rs::extern_spec]
    #[flux_rs::sig(fn() -&gt; String[0])]
    #[allow(unused, dead_code)]
    fn __flux_extern_spec_new() -&gt; String {
       std::string::String::new::&lt;&gt;()
    }
    #[flux_rs::extern_spec]
    #[flux_rs::sig(fn(&amp;String[@n]) -&gt; usize[n])]
    #[allow(unused, dead_code)]
    fn __flux_extern_spec_len(s: &amp;String) -&gt; usize {
       std::string::String::len::&lt;&gt;(s)
    }
}
</code></pre>
<h2 id="grammar-of-refinements"><a class="header" href="#grammar-of-refinements">Grammar of Refinements</a></h2>
<pre><code class="language-text">r ::= n                     // numbers 1,2,3...
    | x                     // identifiers x,y,z...
    | x.f                   // index-field access
    | r + r                 // addition
    | r - r                 // subtraction
    | n * e                 // multiplication by constant
    | if r { r } else { r } // if-then-else
    | f(r...)               // function application
    | true | false          // booleans
    | r == r                // equality
    | r != r                // not equal
    | r &lt; r                 // less than
    | r &lt;= r                // less than or equal
    | r &gt; r                 // greater than
    | r &gt;= r                // greater than or equal
    | r || r                // disjunction
    | r &amp;&amp; r                // conjunction
    | r =&gt; r                // implication
    | !r                    // negation
</code></pre>
<h2 id="ignored-and-trusted-code"><a class="header" href="#ignored-and-trusted-code">Ignored and trusted code</a></h2>
<p>Flux offers two attributes for controlling which parts of your code it analyzes: <code>#[flux_rs::ignore]</code> and <code>#[flux_rs::trusted]</code>.</p>
<ul>
<li><code>#[flux_rs::ignore]</code>: This attribute is applicable to any item, and it instructs Flux to completely skip some code. Flux won't even look at it.</li>
<li><code>#[flux_rs::trusted]</code>: This attribute affects whether Flux checks the body of a function. If a function is marked as trusted, Flux won't verify its body against its signature. However, it will still be able to reason about its signature when used elsewhere.</li>
</ul>
<p>The above means that an <em>ignored</em> function can only be called from ignored or trusted code, while a <em>trusted</em> function can also be called from analyzed code.</p>
<p>Both attributes apply recursively. For instance, if a module is marked as <code>#[flux_rs::ignore]</code>, all its nested elements will also be ignored. This transitive behavior can be disabled by marking an item with <code>#[flux_rs::ignore(no)]</code><sup class="footnote-reference" id="fr-ignore-shorthand-1"><a href="#footnote-ignore-shorthand">1</a></sup>, which will include all nested elements for analysis. Similarly,
the action of <code>#[flux_rs::trusted]</code> can be reverted using <code>#[flux_rs::trusted(no)]</code>.</p>
<p>Consider the following example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux_rs::ignore]
mod A {

   #[flux_rs::ignore(no)]
   mod B {
      mod C {
         fn f1() {}
      }
   }

   mod D {
      fn f2() {}
   }

   fn f3() {}
}
<span class="boring">}</span></code></pre></pre>
<p>In this scenario, functions <code>f2</code> and <code>f3</code> will be ignored, while <code>f1</code> will be analyzed.</p>
<p>A typical pattern when retroactively adding Flux annotations to existing code is to ignore an entire crate (using the inner attribute <code>#![flux_rs::ignore]</code> at the top of the crate) and then selectively include specific sections for analysis.</p>
<h2 id="opaque"><a class="header" href="#opaque">Opaque</a></h2>
<p>Flux offers an attribute <code>opaque</code> which can be used on structs. A module defining an opaque struct should define a trusted API, and clients of the API should not access struct fields directly. This is particularly useful in cases where users need to define a type indexed by a different type than the structs fields. For example, <code>RMap</code> (see below) defines a refined HashMap, indexed by a <code>Map</code> - a primitive sort defined by flux.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use flux_rs::*;

#[opaque]
#[refined_by(vals: Map&lt;K, V&gt;)]
pub struct RMap&lt;K, V&gt; {
    inner: std::collections::HashMap&lt;K, V&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Note that opaque structs <strong>can not</strong> have refined fields.</strong></p>
<p>Now, we can define <code>get</code> for our refined map as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[generics(K as base, V as base)]
impl&lt;K, V&gt; RMap&lt;K, V&gt; {

    #[flux_rs::trusted]
    #[flux_rs::sig(fn(&amp;RMap&lt;K, V&gt;[@m], &amp;K[@k]) -&gt; Option&lt;&amp;V[map_select(m.vals, k)]&gt;)]
    pub fn get(&amp;self, k: &amp;K) -&gt; Option&lt;&amp;V&gt;
    where
        K: Eq + Hash,
    {
        self.inner.get(k)
    }

}
<span class="boring">}</span></code></pre></pre>
<p>Note that if we do not mark these methods as <code>trusted</code>, we will get an error that looks like...</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0999]: cannot access fields of opaque struct `RMap`.
  --&gt; ../opaque.rs:22:9
   |
22 |         self.inner.get(k)
   |         ^^^^^^^^^^
-Ztrack-diagnostics: created at crates/flux-refineck/src/lib.rs:111:14
   |
help: if you'd like to use fields of `RMap`, try annotating this method with `#[flux::trusted]`
  --&gt; ../opaque.rs:18:5
   |
18 | /     pub fn get(&amp;self, k: &amp;K) -&gt; Option&lt;&amp;V&gt;
19 | |     where
20 | |         K: Eq + std::hash::Hash,
   | |________________________________^
   = note: fields of opaque structs can only be accessed inside trusted code
<span class="boring">}</span></code></pre></pre>
<hr>
<ol class="footnote-definition"><li id="footnote-ignore-shorthand">
<p><code>#[flux_rs::ignore]</code> (resp. <code>#[flux_rs::trusted]</code>) is shorthand for <code>#[flux_rs::ignore(yes)]</code> (resp. <code>#[flux_rs::trusted(yes)]</code>). <a href="#fr-ignore-shorthand-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="users-guide"><a class="header" href="#users-guide">User's Guide</a></h1>
<p>One day, this will be an actual user's guide.</p>
<p>For now, it is a collection of various <code>flux</code> features as illustrated by examples from the regression tests.</p>
<h2 id="index-refinements"><a class="header" href="#index-refinements">Index Refinements</a></h2>
<p>Of the form <code>i32[e]</code> (<code>i32</code> equal to <code>e</code>) values.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn(bool[true]))]
pub fn assert(_b: bool) {}

pub fn test00() {
    let x = 1;
    let y = 2;
    assert(x + 1 == y);
}

#[flux::sig(fn five() -&gt; usize[5])]
pub fn five() -&gt; usize {
    let x = 2;
    let y = 3;
    x + y
}

#[flux::sig(fn(n:usize) -&gt; usize[n+1])]
pub fn incr(n: usize) -&gt; usize {
    n + 1
}

pub fn test01() {
    let a = five();
    let b = incr(a);
    assert(b == 6);
}
<span class="boring">}</span></code></pre></pre>
<p><strong>NOTE:</strong> We use the <code>sig(..)</code> annotation to specify the refinement type of a function;
you can optionally also add the <em>name</em> of the function as shown for <code>fn five</code>.</p>
<h2 id="existential-refinements"><a class="header" href="#existential-refinements">Existential Refinements</a></h2>
<p>Of the form <code>i32{v: 0 &lt;= v}</code> (non-negative <code>i32</code>) values.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn(x:i32) -&gt; i32{v: v &gt; x})]
pub fn inc(x: i32) -&gt; i32 {
    x + 1
}

#[flux::sig(fn(x:i32) -&gt; i32{v: v &lt; x})]
pub fn dec(x: i32) -&gt; i32 {
    x - 1
}
<span class="boring">}</span></code></pre></pre>
<h2 id="combining-index-and-existential-refinements"><a class="header" href="#combining-index-and-existential-refinements">Combining Index and Existential Refinements</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn(k: i32{0 &lt;= k}) -&gt; i32[0])]
pub fn test(mut k: i32) -&gt; i32 {
    while toss() &amp;&amp; k &lt; i32::MAX - 1 {
        k += 1;
    }
    while k &gt; 0 {
        k -= 1;
    }
    k
}
<span class="boring">}</span></code></pre></pre>
<h2 id="mutable-references"><a class="header" href="#mutable-references">Mutable References</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn(x: &amp;mut i32{v: 0 &lt;= v}))]
pub fn test4(x: &amp;mut i32) {
    *x += 1;
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn(x: &amp;mut i32{v: 0 &lt;= v}))]
pub fn test4(x: &amp;mut i32) {
    *x -= 1; //~ ERROR assignment might be unsafe
}
<span class="boring">}</span></code></pre></pre>
<h2 id="strong-references"><a class="header" href="#strong-references">Strong References</a></h2>
<p>Like <code>&amp;mut T</code> but which allow <em>strong updates</em> via <code>ensures</code> clauses</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn(x: &amp;strg i32[@n]) ensures x: i32[n+1])]
pub fn inc(x: &amp;mut i32) {
    *x += 1;
}

#[flux::sig(fn() -&gt; i32[1])]
pub fn test_inc() -&gt; i32 {
    let mut x = 0;
    inc(&amp;mut x);
    x
}
<span class="boring">}</span></code></pre></pre>
<h2 id="mixing-mutable-and-strong-references"><a class="header" href="#mixing-mutable-and-strong-references">Mixing Mutable and Strong References</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn (x: &amp;strg i32[@n]) ensures x: i32[n+1])]
pub fn incr(x: &amp;mut i32) {
    *x += 1;
}

#[flux::sig(fn (x: &amp;mut i32{v: 0&lt;=v}))]
pub fn client_safe(z: &amp;mut i32) {
    incr(z);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="refined-arrays"><a class="header" href="#refined-arrays">Refined Arrays</a></h2>
<p><code>flux</code> supports <em>refined arrays</em> of the form <code>[i32{v: 0 &lt;= v}; 20]</code>
denoting arrays of size <code>20</code> of non-negative <code>i32</code> values.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn() -&gt; [i32{v : v &gt;= 0}; 2])]
pub fn array00() -&gt; [i32; 2] {
    [0, 1]
}

pub fn read_u16() -&gt; u16 {
    let bytes: [u8; 2] = [10, 20];
    u16::from_le_bytes(bytes)
}

#[flux::sig(fn() -&gt; i32{v : v &gt; 10})]
pub fn write() -&gt; i32 {
    let bytes: [i32; 2] = [10, 20];
    bytes[0] + bytes[1]
}
<span class="boring">}</span></code></pre></pre>
<h2 id="refined-vectors-rvec"><a class="header" href="#refined-vectors-rvec">Refined Vectors <code>rvec</code></a></h2>
<p><code>RVec</code> specification</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![allow(dead_code)]

<span class="boring">fn main() {
</span>pub mod rslice;

#[macro_export]
macro_rules! rvec {
    () =&gt; { RVec::new() };
    ($($e:expr),+$(,)?) =&gt; {{
        let mut res = RVec::new();
        $( res.push($e); )*
        res
    }};
    ($elem:expr; $n:expr) =&gt; {{
        RVec::from_elem_n($elem, $n)
    }}
}

#[flux::opaque]
#[flux::refined_by(len: int)]
#[flux::invariant(0 &lt;= len)]
pub struct RVec&lt;T&gt; {
    inner: Vec&lt;T&gt;,
}

impl&lt;T&gt; RVec&lt;T&gt; {
    #[flux::trusted]
    #[flux::sig(fn() -&gt; RVec&lt;T&gt;[0])]
    pub fn new() -&gt; Self {
        Self { inner: Vec::new() }
    }

    #[flux::trusted]
    #[flux::sig(fn(self: &amp;strg RVec&lt;T&gt;[@n], T) ensures self: RVec&lt;T&gt;[n+1])]
    pub fn push(&amp;mut self, item: T) {
        self.inner.push(item);
    }

    #[flux::trusted]
    #[flux::sig(fn(&amp;RVec&lt;T&gt;[@n]) -&gt; usize[n])]
    pub fn len(&amp;self) -&gt; usize {
        self.inner.len()
    }

    #[flux::trusted]
    #[flux::sig(fn(&amp;RVec&lt;T&gt;[@n]) -&gt; bool[n == 0])]
    pub fn is_empty(&amp;self) -&gt; bool {
        self.inner.is_empty()
    }

    #[flux::trusted]
    #[flux::sig(fn(&amp;RVec&lt;T&gt;[@n], i: usize{i &lt; n}) -&gt; &amp;T)]
    pub fn get(&amp;self, i: usize) -&gt; &amp;T {
        &amp;self.inner[i]
    }

    #[flux::trusted]
    #[flux::sig(fn(&amp;mut RVec&lt;T&gt;[@n], i: usize{i &lt; n}) -&gt; &amp;mut T)]
    pub fn get_mut(&amp;mut self, i: usize) -&gt; &amp;mut T {
        &amp;mut self.inner[i]
    }

    #[flux::trusted]
    #[flux::sig(fn(self: &amp;strg RVec&lt;T&gt;[@n]) -&gt; T
    		requires n &gt; 0
            ensures self: RVec&lt;T&gt;[n-1])]
    pub fn pop(&amp;mut self) -&gt; T {
        self.inner.pop().unwrap()
    }

    #[flux::trusted]
    #[flux::sig(fn(&amp;mut RVec&lt;T&gt;[@n], a: usize{a &lt; n}, b: usize{b &lt; n}))]
    pub fn swap(&amp;mut self, a: usize, b: usize) {
        self.inner.swap(a, b);
    }

    #[flux::trusted]
    #[flux::sig(fn(&amp;mut RVec&lt;T&gt;[@n]) -&gt; &amp;mut [T][n])]
    pub fn as_mut_slice(&amp;mut self) -&gt; &amp;mut [T] {
        self.inner.as_mut_slice()
    }

    #[flux::trusted]
    #[flux::sig(fn(arr:_) -&gt; RVec&lt;T&gt;[N])]
    pub fn from_array&lt;const N: usize&gt;(arr: [T; N]) -&gt; Self {
        Self { inner: Vec::from(arr) }
    }

    #[flux::trusted]
    #[flux::sig(fn(xs:&amp;[T][@n]) -&gt; RVec&lt;T&gt;[n])]
    pub fn from_slice(xs: &amp;[T]) -&gt; Self
    where
        T: Clone,
    {
        Self { inner: Vec::from(xs) }
    }

    #[flux::trusted]
    #[flux::sig(fn(T, n: usize) -&gt; RVec&lt;T&gt;[n])]
    pub fn from_elem_n(elem: T, n: usize) -&gt; Self
    where
        T: Copy,
    {
        let mut vec = Self::new();
        let mut i = 0;
        while i &lt; n {
            vec.push(elem);
            i += 1;
        }
        vec
    }

    #[flux::trusted]
    #[flux::sig(fn(&amp;RVec&lt;T&gt;[@n]) -&gt; RVec&lt;T&gt;[n])]
    pub fn clone(&amp;self) -&gt; Self
    where
        T: Clone,
    {
        Self { inner: self.inner.clone() }
    }

    #[flux::trusted]
    #[flux::sig(fn(self: &amp;strg RVec&lt;T&gt;[@n], other: &amp;[T][@m]) ensures self: RVec&lt;T&gt;[n + m])]
    pub fn extend_from_slice(&amp;mut self, other: &amp;[T])
    where
        T: Clone,
    {
        self.inner.extend_from_slice(other)
    }

    #[flux::trusted]
    #[flux::sig(fn (&amp;RVec&lt;T&gt;[@n], F) -&gt; RVec&lt;U&gt;[n])]
    pub fn map&lt;U, F&gt;(&amp;self, f: F) -&gt; RVec&lt;U&gt;
    where
        F: Fn(&amp;T) -&gt; U,
    {
        RVec { inner: self.inner.iter().map(f).collect() }
    }

    #[flux::trusted]
    pub fn fold&lt;B, F&gt;(&amp;self, init: B, f: F) -&gt; B
    where
        F: FnMut(B, &amp;T) -&gt; B,
    {
        self.inner.iter().fold(init, f)
    }
}

#[flux::opaque]
pub struct RVecIter&lt;T&gt; {
    vec: RVec&lt;T&gt;,
    curr: usize,
}

impl&lt;T&gt; IntoIterator for RVec&lt;T&gt; {
    type Item = T;
    type IntoIter = RVecIter&lt;T&gt;;

    // TODO: cannot get variant of opaque struct
    #[flux::trusted]
    #[flux::sig(fn(RVec&lt;T&gt;) -&gt; RVecIter&lt;T&gt;)]
    fn into_iter(self) -&gt; RVecIter&lt;T&gt; {
        RVecIter { vec: self, curr: 0 }
    }
}

impl&lt;T&gt; Iterator for RVecIter&lt;T&gt; {
    type Item = T;

    // TODO: cannot get variant of opaque struct
    #[flux::trusted]
    #[flux::sig(fn(&amp;mut RVecIter&lt;T&gt;) -&gt; Option&lt;T&gt;)]
    fn next(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.vec.inner.pop()
    }
}

impl&lt;T&gt; std::ops::Index&lt;usize&gt; for RVec&lt;T&gt; {
    type Output = T;

    #[flux::trusted_impl]
    #[flux::sig(fn(&amp;RVec&lt;T&gt;[@n], usize{v : v &lt; n}) -&gt; &amp;T)]
    fn index(&amp;self, index: usize) -&gt; &amp;T {
        self.get(index)
    }
}

impl&lt;T&gt; std::ops::IndexMut&lt;usize&gt; for RVec&lt;T&gt; {
    #[flux::trusted_impl]
    #[flux::sig(fn(&amp;mut RVec&lt;T&gt;[@n], usize{v : v &lt; n}) -&gt; &amp;mut T)]
    fn index_mut(&amp;mut self, index: usize) -&gt; &amp;mut T {
        self.get_mut(index)
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>RVec</code> clients</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[path = "../../lib/rvec.rs"]
mod rvec;
use rvec::RVec;

#[flux::sig(fn() -&gt; RVec&lt;i32&gt;[0])]
pub fn test0() -&gt; RVec&lt;i32&gt; {
    let mv = rvec![];
    mv
}

#[flux::sig(fn() -&gt; RVec&lt;i32&gt;[5])]
pub fn test1() -&gt; RVec&lt;i32&gt; {
    rvec![ 12; 5 ]
}

#[flux::sig(fn(n:usize) -&gt; RVec&lt;i32&gt;[n])]
pub fn test2(n: usize) -&gt; RVec&lt;i32&gt; {
    rvec![ 12; n ]
}

pub fn test3() -&gt; usize {
    let v = rvec![0, 1];
    let r = v[0];
    let r = r + v[1];
    r
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Binary Search</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![allow(unused_attributes)]

<span class="boring">fn main() {
</span>#[path = "../../lib/rvec.rs"]
pub mod rvec;
use rvec::RVec;

// CREDIT: https://shane-o.dev/blog/binary-search-rust

#[flux::sig(fn(i32, &amp;RVec&lt;i32&gt;) -&gt; usize)]
pub fn binary_search(k: i32, items: &amp;RVec&lt;i32&gt;) -&gt; usize {
    let size = items.len();
    if size &lt;= 0 {
        return size;
    }

    let mut low: usize = 0;
    let mut high: usize = size - 1;

    while low &lt;= high {
        // SAFE   let middle = (high + low) / 2;
        // UNSAFE let middle = high + ((high - low) / 2);
        let middle = low + ((high - low) / 2);
        let current = items[middle];
        if current == k {
            return middle;
        }
        if current &gt; k {
            if middle == 0 {
                return size;
            }
            high = middle - 1
        }
        if current &lt; k {
            low = middle + 1
        }
    }
    size
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Heapsort</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[path = "../../lib/rvec.rs"]
mod rvec;
use rvec::RVec;

#[flux::sig(fn(&amp;mut RVec&lt;i32&gt;[@n]) -&gt; i32)]
pub fn heap_sort(vec: &amp;mut RVec&lt;i32&gt;) -&gt; i32 {
    let len = vec.len();

    if len &lt;= 0 {
        return 0;
    }

    let mut start = len / 2;
    while start &gt; 0 {
        start -= 1;
        shift_down(vec, start, len - 1);
    }

    let mut end = len;
    while end &gt; 1 {
        end -= 1;
        vec.swap(0, end);
        shift_down(vec, 0, end - 1);
    }
    0
}

#[flux::sig(fn(&amp;mut RVec&lt;i32&gt;[@len], usize{v : v &lt; len}, usize{v : v &lt; len}) -&gt; i32)]
pub fn shift_down(vec: &amp;mut RVec&lt;i32&gt;, start: usize, end: usize) -&gt; i32 {
    let mut root = start;
    loop {
        let mut child = root * 2 + 1;
        if child &gt; end {
            break;
        } else {
            if child + 1 &lt;= end {
                let a = vec[child];
                let b = vec[child + 1];
                if a &lt; b {
                    child += 1;
                }
            }
            let a = vec[root];
            let b = vec[child];
            if a &lt; b {
                vec.swap(root, child);
                root = child;
            } else {
                break;
            }
        }
    }
    0
}
<span class="boring">}</span></code></pre></pre>
<h2 id="refined-slices"><a class="header" href="#refined-slices">Refined Slices</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn(&amp;[i32{v : v &gt; 0}]) -&gt; &amp;[i32{v : v &gt;= 0}])]
fn first_half(slice: &amp;[i32]) -&gt; &amp;[i32] {
    let mid = slice.len() / 2;
    let (fst, snd) = slice.split_at(mid);
    fst
}

#[flux::sig(fn(&amp;[i32{v : v &gt; 0}]) -&gt; Option&lt;&amp;i32{v : v &gt;= 0}&gt;)]
fn first(slice: &amp;[i32]) -&gt; Option&lt;&amp;i32&gt; {
    slice.first()
}

#[flux::sig(fn(&amp;mut [i32{v : v &gt; 0}]))]
fn inc_fst(slice: &amp;mut [i32]) {
    if let Some(x) = slice.first_mut() {
        *x += 1;
    }
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[path = "../../lib/rvec.rs"]
mod rvec;
use rvec::{RVec, rslice::RSlice};

#[flux::sig(fn(&amp;mut RVec&lt;T&gt;[10]))]
fn test00&lt;T&gt;(vec: &amp;mut RVec&lt;T&gt;) {
    let mut s = RSlice::from_vec(vec);
    let s1 = s.subslice(0, 3);
    let s2 = s.subslice(4, 5);
}

#[flux::sig(fn(&amp;mut {RVec&lt;i32&gt;[@n] | n % 2 == 0 &amp;&amp; n &gt; 0}))]
fn test01(vec: &amp;mut RVec&lt;i32&gt;) {
    let n = vec.len();
    let mut s = RSlice::from_vec(vec);
    let mut s1 = s.subslice(0, n / 2 - 1);
    let s2 = s.subslice(n / 2, n - 1);
    add(s1.as_mut_slice(), s2.as_slice())
}

#[flux::sig(fn(&amp;mut [i32][@n], &amp;[i32][n]))]
fn add(x: &amp;mut [i32], y: &amp;[i32]) {
    let mut i = 0;
    while i &lt; len(x) {
        x[i] += y[i];
    }
}

#[flux::trusted]
#[flux::sig(fn(x: &amp;[T][@n]) -&gt; usize[n])]
fn len&lt;T&gt;(x: &amp;[T]) -&gt; usize {
    x.len()
}
<span class="boring">}</span></code></pre></pre>
<h2 id="refined-vec"><a class="header" href="#refined-vec">Refined <code>Vec</code></a></h2>
<p>This uses <code>extern_spec</code> which is described in the <a href="guide/specs.html">specifications guide</a>.</p>
<p><strong>Standalone</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(allocator_api)]

<span class="boring">fn main() {
</span>use std::alloc::{Allocator, Global};

use flux_rs::extern_spec;

#[extern_spec]
#[refined_by(len: int)]
struct Vec&lt;T, A: Allocator = Global&gt;;

#[extern_spec]
impl&lt;T&gt; Vec&lt;T&gt; {
    #[sig(fn() -&gt; Vec&lt;T&gt;[0])]
    fn new() -&gt; Vec&lt;T&gt;;
}

#[extern_spec]
impl&lt;T, A: Allocator&gt; Vec&lt;T, A&gt; {
    #[sig(fn(self: &amp;strg Vec&lt;T, A&gt;[@n], T) ensures self: Vec&lt;T, A&gt;[n+1])]
    fn push(&amp;mut self, value: T);

    #[sig(fn(&amp;Vec&lt;T, A&gt;[@n]) -&gt; usize[n])]
    fn len(&amp;self) -&gt; usize;

    #[sig(fn(&amp;Vec&lt;T, A&gt;[@n]) -&gt; bool[n == 0])]
    fn is_empty(&amp;self) -&gt; bool;
}

#[extern_spec]
impl&lt;T&gt; [T] {
    #[sig(fn(self: Box&lt;[T][@n], A&gt;) -&gt; Vec&lt;T, A&gt;[n])]
    fn into_vec&lt;A&gt;(self: Box&lt;[T], A&gt;) -&gt; Vec&lt;T, A&gt;
    where
        A: Allocator;
}

#[flux::sig(fn(bool[true]))]
fn assert(_: bool) {}

#[flux::sig(fn() -&gt; Vec&lt;i32&gt;[3])]
pub fn test_vec_macro() -&gt; Vec&lt;i32&gt; {
    vec![10, 20, 30]
}

#[flux::sig(fn() -&gt; Vec&lt;i32&gt;[3])]
pub fn test_push() -&gt; Vec&lt;i32&gt; {
    let mut res = Vec::new();
    res.push(10);
    res.push(20);
    res.push(30);
    res
}

#[flux::sig(fn() -&gt; usize[3])]
pub fn test_len() -&gt; usize {
    let res = test_push();
    res.len()
}

pub fn test_is_empty() {
    let res = test_push();
    assert(!res.is_empty())
}

// TODO: https://github.com/flux-rs/flux/issues/578
// #[flux::sig(fn (Vec&lt;i32{v:10 &lt;= v}&gt;))]
// pub fn test3(xs: Vec&lt;i32&gt;) {
//     for x in &amp;xs {
//         assert(0 &lt;= *x)
//     }
// }
<span class="boring">}</span></code></pre></pre>
<p><strong>Associated Refinements</strong> for indexing</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::{
    alloc::{Allocator, Global},
    ops::{Index, IndexMut},
    slice::{Iter, SliceIndex},
};

use flux_rs::extern_spec;

#[extern_spec]
#[flux::refined_by(len: int)]
struct Vec&lt;T, A: Allocator = Global&gt;;

#[extern_spec]
#[flux::assoc(fn in_bounds(idx: Self, v: T) -&gt; bool)]
trait SliceIndex&lt;T&gt;
where
    T: ?Sized,
{
}

#[extern_spec]
#[flux::assoc(fn in_bounds(idx: int, len: int) -&gt; bool {idx &lt; len} )]
impl&lt;T&gt; SliceIndex&lt;[T]&gt; for usize {}

#[extern_spec]
impl&lt;T, I: SliceIndex&lt;[T]&gt;, A: Allocator&gt; Index&lt;I&gt; for Vec&lt;T, A&gt; {
    #[flux::sig(fn(&amp;Vec&lt;T, A&gt;[@len], {I[@idx] | &lt;I as SliceIndex&lt;[T]&gt;&gt;::in_bounds(idx, len)}) -&gt; _)]
    fn index(z: &amp;Vec&lt;T, A&gt;, index: I) -&gt; &amp;&lt;I as SliceIndex&lt;[T]&gt;&gt;::Output;
}

#[extern_spec]
impl&lt;T, I: SliceIndex&lt;[T]&gt;, A: Allocator&gt; IndexMut&lt;I&gt; for Vec&lt;T, A&gt; {
    #[flux::sig(fn(&amp;mut Vec&lt;T,A&gt;[@len], {I[@idx] | &lt;I as SliceIndex&lt;[T]&gt;&gt;::in_bounds(idx, len)}) -&gt; _)]
    fn index_mut(z: &amp;mut Vec&lt;T, A&gt;, index: I) -&gt; &amp;mut &lt;I as SliceIndex&lt;[T]&gt;&gt;::Output;
}

//---------------------------------------------------------------------------------------

#[extern_spec]
impl&lt;T&gt; Vec&lt;T&gt; {
    #[flux::sig(fn() -&gt; Vec&lt;T&gt;[0])]
    fn new() -&gt; Vec&lt;T&gt;;
}

#[extern_spec]
impl&lt;T, A: Allocator&gt; Vec&lt;T, A&gt; {
    #[flux::sig(fn(self: &amp;strg Vec&lt;T, A&gt;[@n], T) ensures self: Vec&lt;T, A&gt;[n+1])]
    fn push(v: &amp;mut Vec&lt;T, A&gt;, value: T);

    #[flux::sig(fn(&amp;Vec&lt;T, A&gt;[@n]) -&gt; usize[n])]
    fn len(v: &amp;Vec&lt;T, A&gt;) -&gt; usize;
}

#[extern_spec]
impl&lt;'a, T, A: Allocator&gt; IntoIterator for &amp;'a Vec&lt;T, A&gt; {
    #[flux::sig(fn (&amp;Vec&lt;T, A&gt;[@n]) -&gt; &lt;&amp;Vec&lt;T, A&gt; as IntoIterator&gt;::IntoIter[0,n])]
    fn into_iter(v: &amp;'a Vec&lt;T, A&gt;) -&gt; &lt;&amp;'a Vec&lt;T, A&gt; as IntoIterator&gt;::IntoIter;
}

#[extern_spec]
#[flux::assoc(fn with_size(self: Self, n:int) -&gt; bool { self.len == n })]
impl&lt;T&gt; FromIterator&lt;T&gt; for Vec&lt;T&gt; {}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(allocator_api)]

<span class="boring">fn main() {
</span>use std::ops::Index;

#[path = "../../lib/option.rs"]
mod option;

#[path = "../../lib/slice.rs"]
mod slice;

#[path = "../../lib/vec.rs"]
mod vec;

#[path = "../../lib/iter.rs"]
mod iter;

// ---------------------------------------------------------------------------------------

pub fn test_get0(xs: &amp;Vec&lt;i32&gt;) -&gt; &amp;i32 {
    &lt;Vec&lt;i32&gt; as Index&lt;usize&gt;&gt;::index(xs, 10) //~ ERROR refinement type
}

pub fn test_get1(xs: &amp;Vec&lt;i32&gt;) -&gt; i32 {
    xs[10] //~ ERROR refinement type
}

#[flux::sig(fn (&amp;Vec&lt;i32&gt;[100]) -&gt; &amp;i32)]
pub fn test_get2(xs: &amp;Vec&lt;i32&gt;) -&gt; &amp;i32 {
    &lt;Vec&lt;i32&gt; as Index&lt;usize&gt;&gt;::index(xs, 99)
}

#[flux::sig(fn (&amp;Vec&lt;i32&gt;[100]) -&gt; i32)]
pub fn test_get3(xs: &amp;Vec&lt;i32&gt;) -&gt; i32 {
    xs[99]
}

pub fn test_set0(xs: &amp;mut Vec&lt;i32&gt;) {
    xs[10] = 100; //~ ERROR refinement type
}

#[flux::sig(fn (&amp;mut Vec&lt;i32&gt;[100]))]
pub fn test_set1(xs: &amp;mut Vec&lt;i32&gt;) {
    xs[99] = 100;
}

pub fn test1() {
    let mut xs = Vec::&lt;i32&gt;::new();
    xs.push(10);
    xs.push(20);
    xs.push(30);

    xs[0] = 100;
    xs[1] = 100;
    xs[2] = 100;
    xs[10] = 100; //~ ERROR refinement type
}

pub fn test2(xs: Vec&lt;i32&gt;, i: usize) {
    if i &lt; xs.len() {
        let _ = xs[i];
        let _ = xs[i + 1]; //~ ERROR refinement type
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="named-function-signatures"><a class="header" href="#named-function-signatures">Named Function Signatures</a></h2>
<p>You can also write <em>named</em> function signatures using the <code>spec</code>
annotation (instead of the anonymous <code>sig</code> annotation).</p>
<h2 id="requires-clauses"><a class="header" href="#requires-clauses">Requires Clauses</a></h2>
<p>Used to specify preconditions in a single spot, if needed.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[path = "../../lib/rvec.rs"]
mod rvec;
use rvec::RVec;

#[flux::sig(
    fn(&amp;mut RVec&lt;i32&gt;[@n], b:bool) -&gt; i32[0]
    requires 2 &lt;= n
)]
pub fn test1(vec: &amp;mut RVec&lt;i32&gt;, b: bool) -&gt; i32 {
    let r;
    if b {
        r = &amp;mut vec[0];
    } else {
        r = &amp;mut vec[1];
    }
    *r = 12;
    0
}
<span class="boring">}</span></code></pre></pre>
<h2 id="refining-structs"><a class="header" href="#refining-structs">Refining Structs</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![flux::defs {
<span class="boring">fn main() {
</span>    qualifier Sub2(x: int, a: int, b:int) { x == a - b }
}]
#[path = "../../lib/rvec.rs"]
pub mod rvec;

use rvec::RVec;

#[flux::refined_by(x: int, y:int)]
pub struct Pair {
    #[flux::field(i32[x])]
    pub x: i32,
    #[flux::field(i32[y])]
    pub y: i32,
}

#[flux::sig(fn(a: i32) -&gt; RVec&lt;Pair{v : v.x + v.y &lt;= a }&gt;)]
pub fn mk_pairs_with_bound(a: i32) -&gt; RVec&lt;Pair&gt; {
    let mut i = 0;
    let mut res = RVec::new();
    while i &lt; a {
        let p = Pair { x: i, y: a - i };
        res.push(p);
        i += 1;
    }
    res
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![flux::defs {
<span class="boring">fn main() {
</span>    fn is_btwn(v:int, lo:int, hi: int) -&gt; bool { lo &lt;= v &amp;&amp; v &lt;= hi }
    fn ok_day(d:int) -&gt; bool { is_btwn(d, 1, 31) }
    fn is_month30(m:int) -&gt; bool { m == 4 || m == 6 || m == 9 || m == 11 }
    fn ok_month(d:int, m:int) -&gt; bool { is_btwn(m, 1, 12) &amp;&amp; (is_month30(m) =&gt; d &lt;= 30) }
    fn is_leap_year(y:int) -&gt; bool { y % 400 == 0 || (y % 4 == 0 &amp;&amp; (y % 100) &gt; 0) }
    fn is_feb_day(d:int, y:int) -&gt; bool { d &lt;= 29 &amp;&amp; ( d == 29 =&gt; is_leap_year(y) ) }
    fn ok_year(d:int, m:int, y:int) -&gt; bool { 1 &lt;= y &amp;&amp; (m == 2 =&gt; is_feb_day(d, y)) }
}]

// https://github.com/chrisdone/sandbox/blob/master/liquid-haskell-dates.hs

#[allow(dead_code)]
#[flux::refined_by(d:int, m:int, y:int)]
pub struct Date {
    #[flux::field({ usize[d] | ok_day(d) })]
    day: usize,
    #[flux::field({ usize[m] | ok_month(d, m)})]
    month: usize,
    #[flux::field({ usize[y] | ok_year(d, m, y)})]
    year: usize,
}

pub fn test() {
    let _ok_date = Date { day: 9, month: 8, year: 1977 };
}

// TODO: Tedious to duplicate the definitions if you want to use them in rust code.
// Maybe some macro magic can unify?

#[flux::sig(fn(m:usize) -&gt; bool[is_month30(m)])]
fn is_month30(m: usize) -&gt; bool {
    m == 4 || m == 6 || m == 9 || m == 11
}

#[flux::sig(fn(y:usize) -&gt; bool[is_leap_year(y)])]
fn is_leap_year(y: usize) -&gt; bool {
    y % 400 == 0 || (y % 4 == 0 &amp;&amp; y % 100 != 0)
}

#[flux::sig(fn(d:usize, y:usize) -&gt; bool[is_feb_day(d, y)])]
fn is_feb_day(d: usize, y: usize) -&gt; bool {
    d &lt;= 29 &amp;&amp; (d != 29 || is_leap_year(y))
}

pub fn mk_date(day: usize, month: usize, year: usize) -&gt; Option&lt;Date&gt; {
    if 1 &lt;= year &amp;&amp; 1 &lt;= month &amp;&amp; month &lt;= 12 &amp;&amp; 1 &lt;= day &amp;&amp; day &lt;= 31 {
        if !is_month30(month) || day &lt;= 30 {
            if month != 2 || is_feb_day(day, year) {
                return Some(Date { day, month, year });
            }
        }
    }
    return None;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="invariants-on-structs"><a class="header" href="#invariants-on-structs">Invariants on Structs</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::refined_by(a: int, b: int)]
#[flux::invariant(a &gt; 0)]
#[flux::invariant(b &gt; 0)]
pub struct S {
    #[flux::field({i32[a] | a &gt; 0})]
    fst: i32,
    #[flux::field({i32[b] | b &gt;= a})]
    snd: i32,
}
<span class="boring">}</span></code></pre></pre>
<p>with <code>const</code> generics</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Test that const generics in invariants are properly instantiated

use flux_rs::attrs::*;

#[invariant(N &gt; 0)]
struct S&lt;const N: usize&gt; {}

#[sig(fn(_) -&gt; usize{v : v &gt; 0})]
fn foo&lt;const M: usize&gt;(x: S&lt;M&gt;) -&gt; usize {
    M
}
<span class="boring">}</span></code></pre></pre>
<h3 id="opaque-structs"><a class="header" href="#opaque-structs">Opaque Structs</a></h3>
<p>See the <a href="guide/specs.html">specifications guide</a> for more about the <code>opaque</code> annotation.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::opaque]
#[flux::refined_by(a: int, b: int)]
#[flux::invariant(a &lt;= b)]
pub struct Range {
    a: i32,
    b: i32,
}

impl Range {
    #[flux::trusted]
    #[flux::sig(fn(a: i32, b: i32{b &gt;= a}) -&gt; Range[a, b])]
    pub fn new(a: i32, b: i32) -&gt; Range {
        Range { a, b }
    }

    #[flux::trusted]
    #[flux::sig(fn(&amp;Range[@r]) -&gt; i32[r.a])]
    pub fn fst(&amp;self) -&gt; i32 {
        self.a
    }

    #[flux::trusted]
    #[flux::sig(fn(&amp;Range[@r]) -&gt; i32[r.b])]
    pub fn snd(&amp;self) -&gt; i32 {
        self.b
    }
}

#[flux::sig(fn(Range) -&gt; bool[true])]
fn test(r: Range) -&gt; bool {
    r.snd() - r.fst() &gt;= 0
}
<span class="boring">}</span></code></pre></pre>
<h2 id="refining-enums"><a class="header" href="#refining-enums">Refining Enums</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::refined_by(b:bool)]
pub enum Opt&lt;T&gt; {
    #[flux::variant(Opt&lt;T&gt;[false])]
    None,
    #[flux::variant({T} -&gt; Opt&lt;T&gt;[true])]
    Some(T),
}

#[flux::sig(fn(Opt&lt;T&gt;[@b]) -&gt; bool[b])]
pub fn is_some&lt;T&gt;(x: Opt&lt;T&gt;) -&gt; bool {
    match x {
        Opt::None =&gt; false,
        Opt::Some(_) =&gt; true,
    }
}

#[flux::sig(fn(Opt&lt;T&gt;[@b]) -&gt; bool[b])]
pub fn is_some_flip&lt;T&gt;(x: Opt&lt;T&gt;) -&gt; bool {
    match x {
        Opt::Some(_) =&gt; true,
        Opt::None =&gt; false,
    }
}

#[flux::sig(fn(i32{v:false}) -&gt; T)]
pub fn never&lt;T&gt;(_x: i32) -&gt; T {
    loop {}
}

#[flux::sig(fn(Opt&lt;T&gt;[true]) -&gt; T)]
pub fn unwrap&lt;T&gt;(x: Opt&lt;T&gt;) -&gt; T {
    match x {
        Opt::Some(v) =&gt; v,
        Opt::None =&gt; never(0),
    }
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::refined_by(n: int)]
#[flux::invariant(n &gt; 0)]
pub enum Pos {
    #[flux::variant({Box&lt;Pos[@n]&gt;} -&gt; Pos[2*n])]
    XO(Box&lt;Pos&gt;),
    #[flux::variant({Box&lt;Pos[@n]&gt;} -&gt; Pos[2*n + 1])]
    XI(Box&lt;Pos&gt;),
    #[flux::variant(Pos[1])]
    XH,
}

impl Pos {
    #[flux::spec(fn(&amp;Pos[@n]) -&gt; i32[n])]
    pub fn to_i32(&amp;self) -&gt; i32 {
        match self {
            Pos::XH =&gt; 1,
            Pos::XI(rest) =&gt; 2 * rest.to_i32() + 1,
            Pos::XO(rest) =&gt; 2 * rest.to_i32(),
        }
    }

    #[flux::sig(fn(&amp;Pos[@n]) -&gt; bool[n == 1])]
    pub fn is_one(&amp;self) -&gt; bool {
        match self {
            Pos::XH =&gt; true,
            Pos::XI(_) =&gt; false,
            Pos::XO(_) =&gt; false,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn(i32{v: false}) -&gt; T)]
pub fn never&lt;T&gt;(_: i32) -&gt; T {
    loop {}
}

#[flux::refined_by(n:int)]
#[flux::invariant(n &gt;= 0)]
pub enum List {
    #[flux::variant(List[0])]
    Nil,
    #[flux::variant((i32, Box&lt;List[@n]&gt;) -&gt; List[n+1])]
    Cons(i32, Box&lt;List&gt;),
}

#[flux::sig(fn(&amp;List[@n]) -&gt; bool[n == 0])]
pub fn empty(l: &amp;List) -&gt; bool {
    match l {
        List::Nil =&gt; true,
        List::Cons(_, _) =&gt; false,
    }
}

#[flux::sig(fn(&amp;List[@n]) -&gt; i32[n])]
pub fn len(l: &amp;List) -&gt; i32 {
    match l {
        List::Nil =&gt; 0,
        List::Cons(_, tl) =&gt; 1 + len(tl),
    }
}

#[flux::sig(fn({&amp;List[@n] | 0 &lt; n}) -&gt; i32)]
pub fn head(l: &amp;List) -&gt; i32 {
    match l {
        List::Nil =&gt; never(0),
        List::Cons(h, _) =&gt; *h,
    }
}

#[flux::sig(fn({&amp;List[@n] | 0 &lt; n}) -&gt; &amp;List)]
pub fn tail(l: &amp;List) -&gt; &amp;List {
    match l {
        List::Nil =&gt; never(0),
        List::Cons(_, t) =&gt; t,
    }
}

#[flux::sig(fn(i32, n: usize) -&gt; List[n])]
pub fn clone(val: i32, n: usize) -&gt; List {
    if n == 0 {
        List::Nil
    } else {
        List::Cons(val, Box::new(clone(val, n - 1)))
    }
}

#[flux::sig(fn(List[@n1], List[@n2]) -&gt; List[n1+n2])]
pub fn append(l1: List, l2: List) -&gt; List {
    match l1 {
        List::Nil =&gt; l2,
        List::Cons(h1, t1) =&gt; List::Cons(h1, Box::new(append(*t1, l2))),
    }
}

#[flux::sig(fn(l1: &amp;strg List[@n1], List[@n2]) ensures l1: List[n1+n2])]
pub fn mappend(l1: &amp;mut List, l2: List) {
    match l1 {
        List::Nil =&gt; *l1 = l2,
        List::Cons(_, t1) =&gt; mappend(&amp;mut *t1, l2),
    }
}

#[flux::sig(fn(&amp;List[@n], k:usize{k &lt; n} ) -&gt; i32)]
pub fn get_nth(l: &amp;List, k: usize) -&gt; i32 {
    match l {
        List::Cons(h, tl) =&gt; {
            if k == 0 {
                *h
            } else {
                get_nth(tl, k - 1)
            }
        }
        List::Nil =&gt; never(0),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="invariants-on-enums"><a class="header" href="#invariants-on-enums">Invariants on Enums</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::refined_by(n: int)]
#[flux::invariant(n &gt;= 0)]
pub enum E {
    #[flux::variant({{i32[@n] | n &gt; 0}} -&gt; E[n])]
    Pos(i32),
    #[flux::variant({i32[0]} -&gt; E[0])]
    Zero(i32),
}

#[flux::sig(fn(E[@n], i32[n]) -&gt; i32{v: v &gt; 0})]
pub fn is_zero(_: E, x: i32) -&gt; i32 {
    x + 1
}
<span class="boring">}</span></code></pre></pre>
<h3 id="reflecting-enums"><a class="header" href="#reflecting-enums">Reflecting Enums</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::reflect]
pub enum State {
    On,
    Off,
}

#[flux_rs::sig(fn () -&gt; State[State::On])]
pub fn test00() -&gt; State {
    State::On
}

#[flux_rs::sig(fn () -&gt; State[State::Off])]
pub fn test01() -&gt; State {
    State::Off
}

#[flux::sig(fn () -&gt; State[State::Off])]
pub fn test02() -&gt; State {
    State::On //~ ERROR refinement type
}

#[flux::sig(fn (State[State::On]) -&gt; usize[1])]
pub fn test03(s: State) -&gt; usize {
    match s {
        State::On =&gt; 1,
        State::Off =&gt; 0,
    }
}

#[flux::sig(fn (State[@squig], zig: usize, tag: Day) -&gt; usize[tag])]
pub fn test04(s: State, _zig: usize, tag: Day) -&gt; usize {
    match s {
        State::On =&gt; 1,  //~ ERROR refinement type
        State::Off =&gt; 0, //~ ERROR refinement type
    }
}

#[flux::refined_by(day: int)]
pub enum Day {
    #[flux::variant(Day[0])]
    Mon,
    #[flux::variant(Day[1])]
    Tue,
    #[flux::variant(Day[2])]
    Wed,
}

#[flux::sig(fn (s:State, zig: usize, tag: Day) -&gt; usize[tag])]
pub fn test05(s: State, _zig: usize, _tag: Day) -&gt; usize {
    match s {
        State::On =&gt; 1,  //~ ERROR refinement type
        State::Off =&gt; 0, //~ ERROR refinement type
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="field-syntax-for-indices"><a class="header" href="#field-syntax-for-indices">Field Syntax for Indices</a></h2>
<h3 id="structs"><a class="header" href="#structs">Structs</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::refined_by(x: int, y: int)]
pub struct X {
    #[flux::field(u32[x])]
    x: u32,
    #[flux::field(u32[y])]
    y: u32,
}

#[flux::sig(fn (x: X[@old_x]) -&gt; X[X { y: 2, x: 1 }])]
fn f(mut x: X) -&gt; X {
    x.x = 1;
    x.y = 2;
    x
}
<span class="boring">}</span></code></pre></pre>
<h3 id="enums"><a class="header" href="#enums">Enums</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::refined_by(x: int, y: int)]
pub enum E {
    #[flux::variant(E[0, 1])]
    Variant1,
    #[flux::variant(E[1, 2])]
    Variant2,
    #[flux::variant(E[2, 3])]
    Variant3,
}

#[flux::sig(fn (e: E[@old_enum]) -&gt; E[E { x: 1, y: 2 }])]
fn f(e: E) -&gt; E {
    E::Variant2
}
<span class="boring">}</span></code></pre></pre>
<h3 id="updates"><a class="header" href="#updates">Updates</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::refined_by(x: int, y: int)]
pub struct S {
    #[flux::field(u32[x])]
    x: u32,
    #[flux::field(u32[y])]
    y: u32,
}

impl S {
    #[flux::sig(fn (self: &amp;strg S[@old_x]) ensures self: S[S { x: 1, ..old_x }])]
    pub fn update(&amp;mut self) {
        self.x = 1;
    }
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![flux::defs {
<span class="boring">fn main() {
</span>    fn some_computation(s: S) -&gt; S { s }
}]

#[flux::refined_by(x: int, y: int)]
pub struct S {
    #[flux::field(u32[x])]
    x: u32,
    #[flux::field(u32[y])]
    y: u32,
}

impl S {
    #[flux::sig(fn (self: &amp;strg S[@old_x]) ensures self: S[S { x: 1, ..some_computation(old_x) }])]
    pub fn update(&amp;mut self) {
        self.x = 1;
    }

    #[flux::sig(fn (self: &amp;strg S[@old_x]) ensures self: S[S { x: 1, ..S { x: 2, ..old_x } }])]
    pub fn update2(&amp;mut self) {
        self.x = 1;
    }
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use flux_rs::*;

#[refined_by(start: T, end: T)]
pub struct Range&lt;T&gt; {
    #[flux::field(T[start])]
    pub start: T,
    #[flux::field(T[end])]
    pub end: T,
}

#[sig(fn(r: Range&lt;T&gt;[@old]) -&gt; Range&lt;T&gt;[ Range { ..old } ])]
pub fn foo&lt;T&gt;(r: Range&lt;T&gt;) -&gt; Range&lt;T&gt; {
    r
}

#[sig(fn(r: Range&lt;i32&gt;{v: v == Range { start: 0, end: 0 } }))]
pub fn foo2(_r: Range&lt;i32&gt;) {}

#[sig(fn(r: Range&lt;i32&gt;[Range { start: 0, end: 0 } ]))]
pub fn foo3(_r: Range&lt;i32&gt;) {}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![flux::defs {
<span class="boring">fn main() {
</span>    fn some_computation(s: S) -&gt; S { s }
}]

#[flux::refined_by(x: int, y: int)]
pub struct S {
    #[flux::field(u32[x])]
    x: u32,
    #[flux::field(u32[y])]
    y: u32,
}

impl S {
    #[flux::sig(fn (self: &amp;strg S[@old_x]) ensures self: S[{ x: 1, ..some_computation(old_x) }])]
    pub fn update(&amp;mut self) {
        self.x = 1;
    }

    #[flux::sig(fn (self: &amp;strg S[@old_x]) ensures self: S[{ x: 1, ..S { x: 2, ..old_x } }])]
    pub fn update2(&amp;mut self) {
        self.x = 1;
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="const"><a class="header" href="#const">Const</a></h2>
<p>You can use <code>int</code>-ish <code>const</code> in refinements e.g.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Cow {}

impl Cow {
    const GRASS: usize = 12;

    #[flux_rs::sig(fn () -&gt; usize[12])]
    pub fn test() -&gt; usize {
        Self::GRASS
    }
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(u32)]
pub enum SyscallReturnVariant {
    Failure = 0,
}

#[flux_rs::sig(fn() -&gt; u32[0])]
pub fn test() -&gt; u32 {
    SyscallReturnVariant::Failure as u32
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Cow {}

const GRASS: usize = 12;
impl Cow {
    #[flux_rs::sig(fn () -&gt; usize[12])]
    fn test() -&gt; usize {
        GRASS
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="requires-with-forall"><a class="header" href="#requires-with-forall">Requires with <code>forall</code></a></h2>
<p>We allow a <code>forall</code> on the requires clauses, e.g.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn(bool[true]))]
fn assert(_: bool) {}
#[flux::sig(
    fn(x: i32)
    requires forall y. y &gt;= 0 =&gt; y &gt; x
)]
fn requires_negative(x: i32) {
    assert(x + 1 == 1 + x); // make sure there's something to check to avoid optimizing the entire constraint away
}

fn test2() {
    requires_negative(-1);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="refined-associated-types"><a class="header" href="#refined-associated-types">Refined Associated Types</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use flux_rs::*;

#[sig(fn(bool[true]))]
fn assert(_: bool) {}

trait MyTrait {
    type Assoc;

    #[sig(fn(Self::Assoc[@x]) -&gt; Self::Assoc[x])]
    fn f0(x: Self::Assoc) -&gt; Self::Assoc;

    #[sig(fn(x: Self::Assoc) -&gt; Self::Assoc{ v: v == x })]
    fn f1(x: Self::Assoc) -&gt; Self::Assoc;
}

impl MyTrait for () {
    type Assoc = i32;

    #[sig(fn(x: i32) -&gt; i32[x])]
    fn f0(x: i32) -&gt; i32 {
        x
    }

    #[sig(fn(x: i32) -&gt; i32[x])]
    fn f1(x: i32) -&gt; i32 {
        x
    }
}

fn test00() {
    let x = &lt;() as MyTrait&gt;::f0(0);
    assert(x == 0);
}

fn test01() {
    let x = &lt;() as MyTrait&gt;::f1(0);
    assert(x == 0);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="pragma-ignore"><a class="header" href="#pragma-ignore">Pragma: <code>ignore</code></a></h2>
<p>Used to tell <code>flux</code> to <em>ignore</em> (checking) a bunch of definitions.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![flux::ignore] // default to ignore for the entire crate

<span class="boring">fn main() {
</span>#[flux::ignore(no)] // include this module
mod included {
    #[flux::sig(fn(bool[true]))]
    pub fn assert(_: bool) {}

    pub fn test1() {
        // we are indeed checking this code
        assert(20 &lt; 10); //~ ERROR refinement type error
    }

    pub fn test2() {
        // we cannot use an ignored function in included code
        crate::ignored_fun(); //~ERROR use of ignored function
    }
}

// bad refinement, but no error since we are ignoring this function
#[flux::sig(fn(i32, i32))]
pub fn malformed(_: i32) {}

// an ignored function that cannot be used in included code
pub fn ignored_fun() {}
<span class="boring">}</span></code></pre></pre>
<h2 id="pragma-should_fail"><a class="header" href="#pragma-should_fail">Pragma: <code>should_fail</code></a></h2>
<p>Used to tell <code>flux</code> to <em>expect</em> a failure when checking a function.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This function has an error
// but it's marked as should_fail so that ok.
// flux would yell if instead it verified!

#[flux::should_fail]
#[flux::sig(fn(x: i32) -&gt; i32[x + 1])]
fn test00(x: i32) -&gt; i32 {
    x + 2
}
<span class="boring">}</span></code></pre></pre>
<h2 id="const-generics"><a class="header" href="#const-generics">Const Generics</a></h2>
<p><code>flux</code> lets you use Rust's const-generics inside refinements.</p>
<p><strong>Refining Array Lengths</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// https://github.com/flux-rs/flux/issues/625

const BUFLEN: usize = 100;

pub struct Blob {
    data: [i32; BUFLEN],
}

pub fn test(buf: &amp;[i32; BUFLEN]) -&gt; i32 {
    let x0 = buf[0];
    let x1 = buf[10];
    let x2 = buf[BUFLEN - 1];
    let xbad = buf[BUFLEN]; //~ ERROR assertion might fail
    x0 + x1 + x2 + xbad
}

pub fn test_blob(blob: Blob) -&gt; i32 {
    let x0 = blob.data[0];
    let x1 = blob.data[10];
    let x2 = blob.data[BUFLEN - 1];
    let xbad = blob.data[BUFLEN]; //~ ERROR assertion might fail
    x0 + x1 + x2 + xbad
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Refining Struct Fields</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::invariant(N &gt; 0)]
pub struct MPU&lt;const N: usize&gt; {
    #[flux::field({ i32 | N &gt; 0 })]
    field: i32,
}

pub fn foo&lt;const N: usize&gt;(x: usize, _mpu: MPU&lt;N&gt;) {
    let _x = x % N;
}

#[flux::invariant(N &gt; 0)]
pub struct MPUGOOD&lt;const N: usize&gt; {
    field: i32,
}

pub fn bar&lt;const N: usize&gt;(x: usize, _mpu: MPUGOOD&lt;N&gt;) {
    let _x = x % N;
}

pub fn baz&lt;const N: usize&gt;() -&gt; i32 {
    if N &gt; 0 {
        let mpu = MPUGOOD::&lt;N&gt; { field: 12 };
        mpu.field
    } else {
        0
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Refining Function Signatures</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[path = "../../lib/rvec.rs"]
mod rvec;
use rvec::RVec;

/// A statically sized matrix represented with a linear vector
struct Matrix&lt;const N: usize, const M: usize&gt; {
    #[flux::field(RVec&lt;i32&gt;[N * M])]
    inner: RVec&lt;i32&gt;,
}

impl&lt;const N: usize, const M: usize&gt; Matrix&lt;N, M&gt; {
    fn new() -&gt; Matrix&lt;N, M&gt; {
        Matrix { inner: RVec::from_elem_n(0, N * M) }
    }

    #[flux::sig(fn(&amp;mut Self, i: usize{ i &lt; N }, j: usize{ j &lt; M }, v: i32))]
    fn set(&amp;mut self, i: usize, j: usize, v: i32) {
        self.inner[i * M + j] = v
    }

    #[flux::sig(fn(&amp;Self, i: usize{ i &lt; N }, j: usize{ j &lt; M }) -&gt; i32)]
    fn get(&amp;self, i: usize, j: usize) -&gt; i32 {
        self.inner[i * M + j]
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="type-aliases"><a class="header" href="#type-aliases">Type Aliases</a></h2>
<p>You can define refined <strong>type aliases</strong> for Rust types.</p>
<p><strong>Note</strong></p>
<ol>
<li>They are connected to an underlying Rust type,</li>
<li>They may also be parameterized by refinements, e.g. <code>Lb</code></li>
<li>There are two different kinds of parametrizations
<ul>
<li><em>early</em> (<code>Nat</code>) and</li>
<li><em>late</em> (<code>Lb</code>).</li>
</ul>
</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::alias(type Nat[n: int] = {i32[n] | 0 &lt;= n})]
type Nat = i32;

#[flux::alias(type Lb(n: int)[v: int] = {i32[v] | n &lt;= v})]
type Lb = i32;

#[flux::sig(fn(x: Nat) -&gt; Nat)]
pub fn test1(x: Nat) -&gt; Nat {
    x + 1
}

#[flux::sig(fn(x: Lb(10)) -&gt; Lb(10))]
pub fn test2(x: Lb) -&gt; Lb {
    x + 1
}
<span class="boring">}</span></code></pre></pre>
<h2 id="spec-function-definitions"><a class="header" href="#spec-function-definitions">Spec Function Definitions</a></h2>
<p>You can define <strong>spec functions</strong> that abstract complicated refinements into refinement-level
functions, which can then be used in refinements.</p>
<h3 id="plain-expressions"><a class="header" href="#plain-expressions">Plain Expressions</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![flux::defs {
<span class="boring">fn main() {
</span>    fn is_btwn(v:int, lo:int, hi: int) -&gt; bool { lo &lt;= v &amp;&amp; v &lt;= hi }
    fn ok_day(d:int) -&gt; bool { is_btwn(d, 1, 31) }
    fn is_month30(m:int) -&gt; bool { m == 4 || m == 6 || m == 9 || m == 11 }
    fn ok_month(d:int, m:int) -&gt; bool { is_btwn(m, 1, 12) &amp;&amp; (is_month30(m) =&gt; d &lt;= 30) }
    fn is_leap_year(y:int) -&gt; bool { y % 400 == 0 || (y % 4 == 0 &amp;&amp; (y % 100) &gt; 0) }
    fn is_feb_day(d:int, y:int) -&gt; bool { d &lt;= 29 &amp;&amp; ( d == 29 =&gt; is_leap_year(y) ) }
    fn ok_year(d:int, m:int, y:int) -&gt; bool { 1 &lt;= y &amp;&amp; (m == 2 =&gt; is_feb_day(d, y)) }
}]

// https://github.com/chrisdone/sandbox/blob/master/liquid-haskell-dates.hs

#[allow(dead_code)]
#[flux::refined_by(d:int, m:int, y:int)]
pub struct Date {
    #[flux::field({ usize[d] | ok_day(d) })]
    day: usize,
    #[flux::field({ usize[m] | ok_month(d, m)})]
    month: usize,
    #[flux::field({ usize[y] | ok_year(d, m, y)})]
    year: usize,
}

pub fn test() {
    let _ok_date = Date { day: 9, month: 8, year: 1977 };
}

// TODO: Tedious to duplicate the definitions if you want to use them in rust code.
// Maybe some macro magic can unify?

#[flux::sig(fn(m:usize) -&gt; bool[is_month30(m)])]
fn is_month30(m: usize) -&gt; bool {
    m == 4 || m == 6 || m == 9 || m == 11
}

#[flux::sig(fn(y:usize) -&gt; bool[is_leap_year(y)])]
fn is_leap_year(y: usize) -&gt; bool {
    y % 400 == 0 || (y % 4 == 0 &amp;&amp; y % 100 != 0)
}

#[flux::sig(fn(d:usize, y:usize) -&gt; bool[is_feb_day(d, y)])]
fn is_feb_day(d: usize, y: usize) -&gt; bool {
    d &lt;= 29 &amp;&amp; (d != 29 || is_leap_year(y))
}

pub fn mk_date(day: usize, month: usize, year: usize) -&gt; Option&lt;Date&gt; {
    if 1 &lt;= year &amp;&amp; 1 &lt;= month &amp;&amp; month &lt;= 12 &amp;&amp; 1 &lt;= day &amp;&amp; day &lt;= 31 {
        if !is_month30(month) || day &lt;= 30 {
            if month != 2 || is_feb_day(day, year) {
                return Some(Date { day, month, year });
            }
        }
    }
    return None;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="let-binders"><a class="header" href="#let-binders"><code>let</code> binders</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use flux_rs::attrs::*;

defs! {
    fn times2(x: int) -&gt; int {
        x * 2
    }

    fn test(x: int) -&gt; int {
        let y = times2(x);
        let z = times2(y);
        z * z * y
    }
}

#[sig(fn() -&gt; i32[test(10)])]
fn test() -&gt; i32 {
    32000
}
<span class="boring">}</span></code></pre></pre>
<h3 id="bounded-quantification"><a class="header" href="#bounded-quantification">Bounded Quantification</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![flux::defs {
<span class="boring">fn main() {
</span>    fn magic(xing:int, yonk:int) -&gt; bool;

    fn magic_all(noob:int) -&gt; bool {
        forall i in 0 .. 4 {
            magic(i, noob)
        }
    }

    fn magic_ex(n:int) -&gt; bool {
        exists i in 0 .. 4 {
            i == n
        }
    }
}]

#[flux::trusted]
#[flux::sig(fn(x:i32, y:i32) ensures magic(x, y))]
pub fn do_magic(_x: i32, _y: i32) {}

// forall tests ----------------------------------------------------------------

#[flux::sig(fn({i32[@n] | magic_all(n)}) ensures magic(3, n))]
pub fn test_all_l(_x: i32) {}

#[flux::sig(fn(n:i32) ensures magic_all(n))]
pub fn test_all_r(n: i32) {
    do_magic(0, n);
    do_magic(1, n);
    do_magic(2, n);
    do_magic(3, n);
}

// exists tests ----------------------------------------------------------------
#[flux::sig(fn({i32[@n] | magic_ex(n)}) -&gt; bool[true])]
pub fn test_exi_l(n: i32) -&gt; bool {
    n == 0 || n == 1 || n == 2 || n == 3
}

#[flux::sig(fn(n:i32) -&gt; bool[magic_ex(n)])]
pub fn test_exi_r(n: i32) -&gt; bool {
    n == 0 || n == 1 || n == 2 || n == 3
}
<span class="boring">}</span></code></pre></pre>
<h3 id="no-cycles"><a class="header" href="#no-cycles">No Cycles!</a></h3>
<p>However, there should be no <em>cyclic dependencies</em> in the function definitions.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![flux::defs {
<span class="boring">fn main() {
</span>    fn even(x: int) -&gt; bool { x == 0 || odd(x-1) }
    fn odd(x: int) -&gt; bool { x == 1 || even(x-1) } //~ ERROR cycle
}]

#[flux::sig(fn(x:i32) -&gt; i32[x+1])]
pub fn test(x: i32) -&gt; i32 {
    x + 1
}
<span class="boring">}</span></code></pre></pre>
<h2 id="uninterpreted-function-declarations"><a class="header" href="#uninterpreted-function-declarations">Uninterpreted Function Declarations</a></h2>
<p>You can also declare <em>uninterpreted</em> functions -- about which <code>flux</code> knows nothing
other than the congruence property -- and then use them in refinements. Note that
in this case you have to use a <code>trusted</code> annotation for the function (e.g. <code>is_valid</code>)
that asserts facts over the uninterpreted function</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![flux::defs {
<span class="boring">fn main() {
</span>    fn valid(x:int) -&gt; bool;
}]

#[flux::trusted]
#[flux::sig(fn(x:i32) -&gt; bool[valid(x)])]
fn is_valid(x: i32) -&gt; bool {
    0 &lt;= x &amp;&amp; x &lt;= 100
}

#[flux::sig(fn (i32{v:valid(v)}) -&gt; i32)]
fn bar(a: i32) -&gt; i32 {
    return a;
}

#[flux::sig(fn(i32))]
pub fn test(n: i32) {
    let ok = is_valid(n);
    if ok {
        bar(n);
    }
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![flux::defs {
<span class="boring">fn main() {
</span>    fn foo(x:int, y:int) -&gt; int;
}]

#[flux::trusted]
#[flux::sig(fn(x: i32, y:i32) -&gt; i32[foo(x, y)])]
fn foo(x: i32, y: i32) -&gt; i32 {
    x + y
}

#[flux::sig(fn (i32[foo(10, 20)]) -&gt; i32)]
fn bar(a: i32) -&gt; i32 {
    return a;
}

#[flux::sig(fn())]
pub fn test() {
    let a = 10;
    let b = 20;
    let c = foo(a, b);
    bar(c);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="hiding-and-revealing-function-definitions"><a class="header" href="#hiding-and-revealing-function-definitions">Hiding and Revealing Function Definitions</a></h2>
<p>By default all the function definitions are either <em>inlined</em> or sent to the SMT solver
as <code>define-fun</code> (when run with <code>FLUX_SMT_DEFINE_FUN=1</code>). Sometimes we want to <em>hide</em> the
definition because reasoning about those functions can kill the solver -- or the function
is super complex and we just want to reason about it via congruence. For that you can</p>
<ul>
<li>use the <code>#[hide]</code> attribute at the spec function definition, to make the function <em>uninterpreted</em> by default, and</li>
<li>use the <code>#[reveal]</code> attribute at specific Rust function definition, to indicate you
want to use the actual definition when checking that Rust function.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![flux::defs {
<span class="boring">fn main() {
</span>    #[hide]
    fn mod33(n:int) -&gt; int {
        n % 33
    }

    #[hide]
    fn foo(n:int, k:int) -&gt; bool {
      mod33(n) == k
    }

}]

#[flux::sig(fn (a:i32) requires foo(a, 7))]
pub fn assert_foo(_a: i32) {}

#[flux::reveal(foo, mod33)]
pub fn use_foo(n: i32) {
    if n == 40 {
        assert_foo(n)
        // without `reveal(foo)` we want to see an error in the above line.
    }
}

#[flux::sig(fn (xs: &amp;[i32{v: foo(v, 7)}][100]) -&gt; i32{v : foo(v, 7)})]
pub fn bar(xs: &amp;[i32]) -&gt; i32 {
    xs[0] // `foo` as uninterpreted works fine
}
<span class="boring">}</span></code></pre></pre>
<h2 id="spec-functions-in-smtlib"><a class="header" href="#spec-functions-in-smtlib">Spec Functions in SMTLIB</a></h2>
<p>By default <code>flux</code> inlines all such function definitions.</p>
<p>Monomorphic functions may <em>optionally</em> be encoded
as functions in SMT by using the <code>FLUX_SMT_DEFINE_FUN=1</code>
environment variable.</p>
<h2 id="type-holes"><a class="header" href="#type-holes">Type Holes</a></h2>
<p>You can (sometimes!) use <code>_</code> in the <code>flux</code> signatures to omit the Rust components, e.g.</p>
<h3 id="function-signatures"><a class="header" href="#function-signatures">Function Signatures</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn(_) -&gt; Option&lt;_&gt;)]
fn test00(x: i32) -&gt; Option&lt;i32&gt; {
    Some(x)
}

#[flux::sig(fn(x: &amp;strg _) ensures x: i32[0])]
fn test01(x: &amp;mut i32) {
    *x = 0;
}

#[flux::sig(fn(x: &amp;strg i32) ensures x: _)]
fn test02(x: &amp;mut i32) {
    *x = 0;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="structs-and-enums"><a class="header" href="#structs-and-enums">Structs and Enums</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Type holes in structs and enums

pub struct S {
    #[flux::field(Option&lt;_&gt;)]
    x: Option&lt;i32&gt;,
}

pub fn test_s(s: S) -&gt; Option&lt;i32&gt; {
    s.x
}

pub enum E {
    #[flux::variant((_) -&gt; E)]
    A(i32),
}

pub fn test_e(e: E) -&gt; i32 {
    match e {
        E::A(x) =&gt; x,
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="type-aliases-1"><a class="header" href="#type-aliases-1">Type Aliases</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::alias(type Test = Vec&lt;_&gt;)]
type Test = Vec&lt;i32&gt;;

fn test(x: Test) -&gt; Vec&lt;i32&gt; {
    x
}
<span class="boring">}</span></code></pre></pre>
<h3 id="generic-args"><a class="header" href="#generic-args">Generic Args</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux_rs::refined_by(m: Map&lt;int, int&gt;)]
#[flux_rs::opaque]
pub struct S1&lt;const N: usize&gt; {
    _arr: [usize; N],
}

const MY_N: usize = 10;

#[flux_rs::refined_by(gloop: S1)]
pub struct S2 {
    #[field(S1&lt;_&gt;[gloop])]
    pub s1: S1&lt;MY_N&gt;,
}

#[flux_rs::refined_by(zoo: S1)]
pub struct S3&lt;const M: usize&gt; {
    #[field(S1&lt;_&gt;[zoo])]
    pub s1: S1&lt;M&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="closures"><a class="header" href="#closures">Closures</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn(c: Option&lt;bool&gt;) -&gt; Option&lt;i32{v:0 &lt;= v}&gt;)]
pub fn test0(c: Option&lt;bool&gt;) -&gt; Option&lt;i32&gt; {
    c.map(|b| if b { 1 } else { 2 })
}

// #[flux::sig(fn(c: Option&lt;bool&gt;) -&gt; Option&lt;i32{v:1 &lt;= v}&gt;)]
// pub fn test1(c: Option&lt;bool&gt;) -&gt; Option&lt;i32&gt; {
//     c.map(|b| if b { 1 } else { 2 })
// }

// #[flux::sig(fn(c: Option&lt;bool[true]&gt;) -&gt; Option&lt;i32[1]&gt;)]
// pub fn test2(c: Option&lt;bool&gt;) -&gt; Option&lt;i32&gt; {
//     c.map(|b| if b { 1 } else { 2 })
// }

// #[flux::sig(fn(n:usize) -&gt; usize[n + 2])]
// pub fn test3(n: usize) -&gt; usize {
//     checked_add(n, 1)
//         .and_then(|m| Some(m + 1))
//         .expect("overflow")
// }

// #[flux::trusted]
// #[flux::sig(fn(n:usize, m:usize) -&gt; Option&lt;usize[n + m]&gt;)]
// pub fn checked_add(n: usize, m: usize) -&gt; Option&lt;usize&gt; {
//     n.checked_add(m)
// }
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[path = "../../lib/rvec.rs"]
mod rvec;
use rvec::RVec;

#[flux::trusted]
fn smap&lt;S, F, A, B&gt;(s: S, v: Vec&lt;A&gt;, f: F) -&gt; Vec&lt;B&gt;
where
    F: Fn(S, A) -&gt; B,
    S: Copy,
{
    v.into_iter().map(|x| f(s, x)).collect()
}

#[flux::sig(fn(vs: Vec&lt;i32{v:0&lt;=v}&gt;) -&gt; Vec&lt;i32{v:3&lt;=v}&gt;)]
pub fn test1_old(vs: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    let st = 3;
    smap(st, vs, |s, x| s + x)
}

#[flux::sig(fn(vs: Option&lt;i32{v:0&lt;=v}&gt;) -&gt; Option&lt;i32{v:3&lt;=v}&gt;)]
pub fn test2_old(vs: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    let y = 1;
    let z = 2;
    vs.map(|x| x + y + z)
}

pub struct Foo {
    #[flux::field(i32{v: 10 &lt;= v})]
    pub val: i32,
}

pub fn test1(c: Option&lt;bool&gt;) -&gt; Option&lt;Foo&gt; {
    let x = 6;
    let y = 10;
    c.map(|b| if b { Foo { val: x + y } } else { Foo { val: 20 } })
}

#[flux::sig(fn(vec:&amp;RVec&lt;i32{v: 10 &lt;= v}&gt;{v: 0 &lt; v}) -&gt; Foo)]
fn bob(vec: &amp;RVec&lt;i32&gt;) -&gt; Foo {
    Foo { val: vec[0] }
}

pub fn test2(c: Option&lt;bool&gt;) -&gt; Option&lt;Foo&gt; {
    let vec = rvec![100, 200, 300];
    c.map(|b| if b { bob(&amp;vec) } else { Foo { val: 20 } })
}

#[flux::trusted]
fn frob(_vec: &amp;RVec&lt;RVec&lt;i32&gt;&gt;) -&gt; Foo {
    todo!()
}

pub fn test3(c: Option&lt;bool&gt;, vec: RVec&lt;RVec&lt;i32&gt;&gt;) -&gt; Option&lt;Foo&gt; {
    // let mut vec = rvec![rvec![100, 200, 300]];
    c.map(|b| if b { frob(&amp;vec) } else { Foo { val: 20 } })
}
<span class="boring">}</span></code></pre></pre>
<h2 id="function-pointers"><a class="header" href="#function-pointers">Function Pointers</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![allow(unused)]

<span class="boring">fn main() {
</span>#[flux::sig(fn (x:usize) -&gt; usize[x+1])]
fn inc(x: usize) -&gt; usize {
    x + 1
}

#[flux::sig(fn(c: Option&lt;usize[99]&gt;) -&gt; Option&lt;usize[100]&gt;)]
pub fn test_ok(c: Option&lt;usize&gt;) -&gt; Option&lt;usize&gt; {
    c.map(inc)
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![allow(unused)]

<span class="boring">fn main() {
</span>fn id&lt;T&gt;(x: T) -&gt; T {
    x
}

#[flux::sig(fn(c: Option&lt;usize[99]&gt;) -&gt; Option&lt;usize[99]&gt;)]
pub fn test_ok(c: Option&lt;usize&gt;) -&gt; Option&lt;usize&gt; {
    c.map(id)
}

#[flux::sig(fn(Option&lt;i32[99]&gt;) -&gt; Option&lt;i32[99]&gt;)]
fn test_also_ok(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    let f = id;
    x.map(f)
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use flux_rs::*;

#[sig(fn(x: i32{x != 0}) -&gt; i32[1/x])]
fn div(x: i32) -&gt; i32 {
    1 / x
}

fn apply&lt;A, B&gt;(f: impl FnOnce(A) -&gt; B, x: A) -&gt; B {
    f(x)
}

#[sig(fn() -&gt; i32[0])]
fn test() -&gt; i32 {
    apply(div, 10)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="traits-and-implementations"><a class="header" href="#traits-and-implementations">Traits and Implementations</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait MyTrait {
    fn foo() -&gt; i32;
    fn bar();
}

pub struct MyTy;

impl MyTrait for MyTy {
    #[flux::sig(fn () -&gt; i32[10])]
    fn foo() -&gt; i32 {
        10
    }

    fn bar() {}
}

#[flux::sig(fn () -&gt; i32[10])]
pub fn test() -&gt; i32 {
    let n = MyTy::foo();
    MyTy::bar();
    n
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Mono {
    #[flux::sig(fn (zing: &amp;strg i32[@n]) ensures zing: i32{v:n &lt; v})]
    fn foo(z: &amp;mut i32);
}

pub struct Tiger;

impl Mono for Tiger {
    #[flux::sig(fn (pig: &amp;strg i32[@m]) ensures pig: i32{v:m &lt; v})]
    fn foo(pig: &amp;mut i32) {
        *pig += 1;
    }
}

pub struct Snake;

impl Mono for Snake {
    #[flux::sig(fn (pig: &amp;strg i32[@m]) ensures pig: i32[m+1])]
    fn foo(pig: &amp;mut i32) {
        *pig += 1;
    }
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Mono {
    #[flux::sig(fn (zing: &amp;strg i32[@n])
                  requires 100 &lt; n
                  ensures zing: i32{v:n &lt; v})]
    fn foo(z: &amp;mut i32);
}

pub struct Tiger;

impl Mono for Tiger {
    #[flux::sig(fn (pig: &amp;strg i32[@m])
                  requires 0 &lt; m
                  ensures pig: i32{v:m &lt; v})]
    fn foo(pig: &amp;mut i32) {
        *pig += 1;
    }
}

pub struct Snake;

impl Mono for Snake {
    #[flux::sig(fn (pig: &amp;strg {i32[@m] | 0 &lt; m})
                ensures pig: i32[m+1])]
    fn foo(pig: &amp;mut i32) {
        *pig += 1;
    }
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::generics(Self as base)]
pub trait MyTrait {
    #[flux::sig(fn[hrn p: Self -&gt; bool](&amp;Self{v: p(v)}) -&gt; Self{v: p(v)})]
    fn foo1(&amp;self) -&gt; Self;

    fn foo2(&amp;self) -&gt; Self;
}

impl MyTrait for i32 {
    // TODO: error-message when below is missing (currently: fixpoint crash!) see tests/tests/todo/trait13.rs
    #[flux::sig(fn[hrn p: Self -&gt; bool](&amp;Self{v: p(v)}) -&gt; Self{v: p(v)})]
    fn foo1(&amp;self) -&gt; Self {
        *self
    }

    #[flux::sig(fn[hrn q: Self -&gt; bool](&amp;Self{v: q(v)}) -&gt; Self{v: q(v)})]
    fn foo2(&amp;self) -&gt; Self {
        *self
    }
}

#[flux::sig(fn[hrn q: T -&gt; bool](&amp;T{v:q(v)}) -&gt; T{v: q(v)})]
pub fn bar1&lt;T: MyTrait&gt;(x: &amp;T) -&gt; T {
    x.foo1()
}

#[flux::sig(fn(bool[true]))]
fn assert(_b: bool) {}

pub fn test() {
    let x = 42;
    assert(bar1(&amp;x) == 42);
    assert(x.foo2() == 42);
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Silly&lt;A&gt; {
    #[flux::sig(fn(&amp;Self, z: A) -&gt; i32{v:100 &lt; v})]
    fn bloop(&amp;self, z: A) -&gt; i32;
}

impl Silly&lt;bool&gt; for i32 {
    #[flux::sig(fn(&amp;Self, b : bool) -&gt; i32[2000])]
    fn bloop(&amp;self, _b: bool) -&gt; i32 {
        2000
    }
}

#[flux::sig(fn(i32) -&gt; i32{v: 100 &lt; v})]
pub fn client(x: i32) -&gt; i32 {
    let y = x.bloop(true);
    y + 1
}

#[flux::sig(fn(_, _) -&gt; i32{v:100 &lt; v})]
pub fn client2&lt;A, B: Silly&lt;A&gt;&gt;(x: B, y: A) -&gt; i32 {
    x.bloop(y)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="impl-trait"><a class="header" href="#impl-trait">Impl Trait</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn test1() -&gt; impl Iterator&lt;Item = i32&gt; {
    Some(10).into_iter()
}

#[flux::sig(fn () -&gt; impl Iterator&lt;Item = i32{v:1&lt;=v}&gt;)]
pub fn test2() -&gt; impl Iterator&lt;Item = i32&gt; {
    Some(10).into_iter()
}

#[flux::sig(fn () -&gt; impl Iterator&lt;Item = i32{v:1&lt;=v}&gt;)]
pub fn test_lib() -&gt; impl Iterator&lt;Item = i32&gt; {
    Some(10).into_iter()
}

#[flux::sig(fn () -&gt; Option&lt;i32{v:0&lt;=v}&gt;)]
pub fn test_client() -&gt; Option&lt;i32&gt; {
    let mut it = test_lib();
    it.next()
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn (x:i32) -&gt; impl Iterator&lt;Item = i32{v:x&lt;=v}&gt;)]
pub fn lib(x: i32) -&gt; impl Iterator&lt;Item = i32&gt; {
    Some(x).into_iter()
}

#[flux::sig(fn (k:i32) -&gt; Option&lt;i32{v:k&lt;=v}&gt;)]
pub fn test_client(k: i32) -&gt; Option&lt;i32&gt; {
    let mut it = lib(k);
    it.next()
}
<span class="boring">}</span></code></pre></pre>
<h2 id="dynamic-trait-objects"><a class="header" href="#dynamic-trait-objects">Dynamic Trait Objects</a></h2>
<pre><pre class="playground"><code class="language-rust">#![allow(unused)]

// ------------------------------------------------------

trait Shape {
    #[flux::sig(fn(self: _) -&gt; i32{v: 0 &lt;= v})]
    fn vertices(&amp;self) -&gt; i32;
}

// ------------------------------------------------------

struct Circle {}

impl Shape for Circle {
    #[flux::sig(fn(self: _) -&gt; i32{v: 0 &lt;= v})]
    fn vertices(&amp;self) -&gt; i32 {
        0
    }
}

// ------------------------------------------------------

#[flux::sig(fn(shape: _) -&gt; i32{v: 0 &lt;= v})]
fn count(shape: &amp;dyn Shape) -&gt; i32 {
    shape.vertices()
}

#[flux::sig(fn(shape: _) -&gt; i32{v: 10 &lt;= v})]
fn count_bad(shape: &amp;dyn Shape) -&gt; i32 {
    shape.vertices() //~ ERROR: refinement type
}

fn main() {
    let c = Circle {};
    count(&amp;c);
    count_bad(&amp;c);
}</code></pre></pre>
<h2 id="generic-refinements"><a class="header" href="#generic-refinements">Generic Refinements</a></h2>
<p><code>flux</code> supports <em>generic refinements</em> see <a href="https://dl.acm.org/doi/10.1145/3704885">this paper for details</a></p>
<p><strong>Horn Refinements</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Define a function whose type uses the Horn generic refinement `p`
#[flux::sig(
    fn[hrn p: int -&gt; bool](x: i32, y: i32) -&gt; i32{v: p(v) &amp;&amp; v &gt;= x &amp;&amp; v &gt;= y}
    requires p(x) &amp;&amp; p(y)
)]
fn max(x: i32, y: i32) -&gt; i32 {
    if x &gt; y { x } else { y }
}

// A client of `max` where the generic is instantiated to `|v| {v % 2 == 0}`
#[flux::sig(fn() -&gt; i32{v: v % 2 == 0})]
pub fn test00() -&gt; i32 {
    max(4, 10)
}

// A client of `max` where the generic is instantiated to `|v| {v == 4 || v == 10}`
#[flux::sig(fn() -&gt; i32[10])]
pub fn test01() -&gt; i32 {
    max(4, 10)
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::refined_by(a: int, b: int, hrn p: (int, int) -&gt; bool)]
struct Pair {
    #[flux::field(i32[a])]
    fst: i32,
    #[flux::field({i32[b] | p(a, b)})]
    snd: i32,
}

#[flux::sig(fn() -&gt; Pair)]
fn test00() -&gt; Pair {
    Pair { fst: 0, snd: 1 }
}

#[flux::sig(fn(Pair[@a, @b, |a, b| a &lt; b]) -&gt; i32{v: v &gt; 0})]
fn test01(pair: Pair) -&gt; i32 {
    pair.snd - pair.fst
}

fn test02() {
    let pair = Pair { fst: 0, snd: 1 };
    let x = test01(pair);
}

#[flux::sig(fn(x: i32, Pair[@a, @b, |a, b| a &gt; x]) -&gt; i32{v: v &gt; x})]
fn test03(x: i32, pair: Pair) -&gt; i32 {
    pair.fst
}

fn test04() {
    let pair = Pair { fst: 10, snd: 0 };
    test03(0, pair);
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Copy)]
#[flux::refined_by(hrn p: int -&gt; bool)]
pub struct S;

#[flux::sig(fn(x: i32) -&gt; S[|y| y &gt; x])]
pub fn gt(x: i32) -&gt; S {
    S
}

#[flux::sig(fn(x: i32) -&gt; S[|y| y &lt; x])]
pub fn lt(x: i32) -&gt; S {
    S
}

#[flux::sig(fn(S[@p1], S[@p2]) -&gt; S[|x| p1(x) || p2(x)])]
pub fn or(_: S, _: S) -&gt; S {
    S
}

#[flux::sig(fn(S[@p], x: i32{ p(x) }))]
pub fn check(_: S, x: i32) {}

pub fn test() {
    let s = or(gt(10), lt(0));
    check(s, 11);
    check(s, -1);
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Hindley Refinements</strong></p>
<p>TODO</p>
<h2 id="bitvector-refinements"><a class="header" href="#bitvector-refinements">Bitvector Refinements</a></h2>
<h3 id="operators"><a class="header" href="#operators">Operators</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// https://github.com/flux-rs/flux/issues/1010

use flux_rs::{attrs::*, bitvec::BV32};

#[sig(fn (x:BV32{x == 1}) ensures (bv_shl(x, 3) == 8))]
pub fn test_shl_a(_x: BV32) {}

#[sig(fn (x:BV32{x == 1}) ensures (x &lt;&lt; 3 == 8))]
pub fn test_shl_b(_x: BV32) {}

#[sig(fn (x:BV32{x == 8}) ensures (bv_lshr(x, 3) == 1))]
pub fn test_shr_a(_x: BV32) {}

#[sig(fn (x:BV32{x == 8}) ensures (x &gt;&gt; 3 == 1))]
pub fn test_shr_b(_x: BV32) {}

#[sig(fn (x:BV32{x == 8}) ensures (bv_or(x, 3) == 11))]
pub fn test_or_a(_x: BV32) {}

#[sig(fn (x:BV32{x == 8}) ensures (x | 3 == 11))]
pub fn test_or_b(_x: BV32) {}

#[sig(fn (x:BV32{x == 10}) ensures (bv_and(x, 3) == 2))]
pub fn test_and_a(_x: BV32) {}

#[sig(fn (x:BV32{x == 10}) ensures (x &amp; 3 == 2))]
pub fn test_and_b(_x: BV32) {}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use flux_rs::{attrs::*, bitvec::BV32};

#[sig(fn(x: BV32) -&gt; BV32[bv_add(x, bv_int_to_bv32(1))])]
pub fn test_00(x: BV32) -&gt; BV32 {
    x + BV32::new(1)
}

#[sig(fn(x: BV32) -&gt; BV32[x + bv_int_to_bv32(1)])]
pub fn test_01(x: BV32) -&gt; BV32 {
    x + BV32::new(1)
}

#[sig(fn(x: BV32) -&gt; BV32[x + 1])]
pub fn test_02(x: BV32) -&gt; BV32 {
    x + BV32::new(1)
}

#[sig(fn(x: i32) -&gt; i32[x + (1 + 2)])]
pub fn test_03(x: i32) -&gt; i32 {
    x + 3
}

#[sig(fn() -&gt; BV32[bv_int_to_bv32(0x5)])]
pub fn test_04() -&gt; BV32 {
    BV32::new(0x5)
}

#[sig(fn() -&gt; BV32[5])]
pub fn test_05() -&gt; BV32 {
    BV32::new(0x5)
}

#[sig(fn(x: BV32, y:BV32) -&gt; bool[x + y &gt; 5])]
pub fn test_06(x: BV32, y: BV32) -&gt; bool {
    x + y &gt; BV32::new(5)
}

#[sig(fn(x: BV32, y:BV32) -&gt; bool[x + y &gt; x - y])]
pub fn test_07(x: BV32, y: BV32) -&gt; bool {
    x + y &gt; x - y
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::{Add, Sub};

#[flux::opaque]
#[flux::refined_by(x: bitvec&lt;32&gt;)]
pub struct BV32(u32);

impl BV32 {
    #[flux::trusted]
    #[flux::sig(fn (u32[@x]) -&gt; BV32[bv_int_to_bv32(x)])]
    pub fn new(x: u32) -&gt; Self {
        BV32(x)
    }
}

impl Add for BV32 {
    type Output = BV32;

    #[flux_rs::trusted]
    #[flux_rs::sig(fn (BV32[@val1], BV32[@val2]) -&gt; BV32[bv_add(val1, val2)])]
    fn add(self, rhs: Self) -&gt; BV32 {
        BV32(self.0 + rhs.0)
    }
}

impl Sub for BV32 {
    type Output = BV32;

    #[flux_rs::trusted]
    #[flux_rs::sig(fn (BV32[@val1], BV32[@val2]) -&gt; BV32[bv_sub(val1, val2)])]
    fn sub(self, rhs: Self) -&gt; BV32 {
        BV32(self.0.wrapping_add(!rhs.0))
    }
}

impl PartialEq for BV32 {
    #[flux::trusted]
    #[flux::sig(fn (&amp;BV32[@val1], &amp;BV32[@val2]) -&gt; bool[val1 == val2])]
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        self.0 == other.0
    }

    #[flux::trusted]
    #[flux::sig(fn (&amp;BV32[@val1], &amp;BV32[@val2]) -&gt; bool[val1 != val2])]
    fn ne(&amp;self, other: &amp;Self) -&gt; bool {
        self.0 != other.0
    }
}

impl PartialOrd for BV32 {
    #[flux::trusted]
    fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;std::cmp::Ordering&gt; {
        self.0.partial_cmp(&amp;other.0)
    }

    #[flux::trusted]
    #[flux::sig(fn (&amp;BV32[@x], &amp;BV32[@y]) -&gt; bool[bv_ule(x, y)])]
    fn le(&amp;self, other: &amp;Self) -&gt; bool {
        self.0 &lt;= other.0
    }

    #[flux::trusted]
    #[flux::sig(fn (&amp;BV32[@x], &amp;BV32[@y]) -&gt; bool[bv_ult(x, y)])]
    fn lt(&amp;self, other: &amp;Self) -&gt; bool {
        self.0 &lt; other.0
    }

    #[flux::trusted]
    #[flux::sig(fn (&amp;BV32[@x], &amp;BV32[@y]) -&gt; bool[bv_uge(x, y)])]
    fn ge(&amp;self, other: &amp;Self) -&gt; bool {
        self.0 &gt;= other.0
    }

    #[flux::trusted]
    #[flux::sig(fn (&amp;BV32[@x], &amp;BV32[@y]) -&gt; bool[bv_ugt(x, y)])]
    fn gt(&amp;self, other: &amp;Self) -&gt; bool {
        self.0 &gt; other.0
    }
}

#[flux::sig(fn (BV32[@x]) -&gt; bool[bv_ule(x, x)])]
pub fn trivial_le(x: BV32) -&gt; bool {
    x &lt;= x
}

#[flux::sig(fn (BV32[@x]) -&gt; bool[bv_ult(x, x)])]
pub fn trivial_lt(x: BV32) -&gt; bool {
    x &lt; x
}

#[flux::sig(fn (BV32[@x]) -&gt; bool[bv_uge(x, x)])]
pub fn trivial_ge(x: BV32) -&gt; bool {
    x &lt;= x
}

#[flux::sig(fn (BV32[@x]) -&gt; bool[bv_ugt(x, x)])]
pub fn trivial_gt(x: BV32) -&gt; bool {
    x &lt; x
}

#[flux::sig(fn (BV32[@x], BV32[@y]) -&gt; bool[
    bv_ule(x, bv_int_to_bv32(10))
    &amp;&amp; 
    bv_uge(y, bv_int_to_bv32(20))
    &amp;&amp;
    bv_ult(x, bv_int_to_bv32(11))
    &amp;&amp;
    bv_ugt(y, bv_int_to_bv32(21))
])]
pub fn real_example(x: BV32, y: BV32) -&gt; bool {
    x &lt;= BV32::new(10) &amp;&amp; y &gt;= BV32::new(20) &amp;&amp; x &lt; BV32::new(11) &amp;&amp; y &gt; BV32::new(21)
}


#[flux_rs::sig(fn (BV32[@x], BV32[@y]) -&gt; bool[true] requires bv_ult(x, y) &amp;&amp; bv_ugt(x, bv_int_to_bv32(0x20)) &amp;&amp; bv_ult(y, bv_int_to_bv32(0xFF)))]
fn lt_imp(x: BV32, y: BV32) -&gt; bool {
    x - BV32::new(0x20) &lt; y + BV32::new(0x20)
}

#[flux_rs::sig(fn (BV32[@x], BV32[@y]) -&gt; bool[true] requires bv_ule(x, y) &amp;&amp; bv_uge(x, bv_int_to_bv32(0x20)) &amp;&amp; bv_ule(y, bv_int_to_bv32(0xFF)))]
fn le_imp(x: BV32, y: BV32) -&gt; bool {
    x - BV32::new(0x20) &lt;= y + BV32::new(0x20)
}

#[flux_rs::sig(fn (BV32[@x], BV32[@y]) -&gt; bool[true] requires bv_ugt(x, y) &amp;&amp; bv_ugt(y, bv_int_to_bv32(0x20)) &amp;&amp; bv_ult(x, bv_int_to_bv32(0xFF)))]
fn gt_imp(x: BV32, y: BV32) -&gt; bool {
    x + BV32::new(0x20) &gt; y - BV32::new(0x20)
}

#[flux_rs::sig(fn (BV32[@x], BV32[@y]) -&gt; bool[true] requires bv_uge(x, y) &amp;&amp; bv_uge(y, bv_int_to_bv32(0x20)) &amp;&amp; bv_ule(x, bv_int_to_bv32(0xFF)))]
fn ge_imp(x: BV32, y: BV32) -&gt; bool {
    x + BV32::new(0x20) &gt;= y - BV32::new(0x20)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="specification-functions"><a class="header" href="#specification-functions">Specification functions</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use flux_rs::{attrs::*, bitvec::BV32};

defs! {
    fn is_pow2(x: bitvec&lt;32&gt;) -&gt; bool {
        (x &gt; 0) &amp;&amp; ((x &amp; x - 1) == 0)
    }
}

#[sig(fn(x: BV32) requires is_pow2(x) &amp;&amp; 8 &lt;= x ensures x % 8 == 0)]
fn theorem_pow2_octet(x: BV32) {}
<span class="boring">}</span></code></pre></pre>
<h3 id="extensions"><a class="header" href="#extensions">Extensions</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// https://github.com/flux-rs/flux/issues/686

#[allow(dead_code)]
#[flux::sig(fn(x: bool[true]))]
pub fn assert(_x: bool) {}

#[flux::opaque]
#[flux::refined_by(v: bitvec&lt;32&gt;)]
struct Register {
    inner: u32,
}

impl Register {
    #[flux::sig(fn(u32[@n]) -&gt; Register[bv_int_to_bv32(n)])]
    #[flux::trusted]
    fn new(v: u32) -&gt; Self {
        Register { inner: v }
    }

    #[flux::sig(fn(&amp;Register[@n]) -&gt; u64[bv_bv64_to_int(bv_zero_extend_32_to_64(n))])]
    #[flux::trusted]
    fn zero_extend(&amp;self) -&gt; u64 {
        self.inner as u64
    }

    #[flux::sig(fn(&amp;Register[@n]) -&gt; u64[bv_bv64_to_int(bv_sign_extend_32_to_64(n))])]
    #[flux::trusted]
    fn sign_extend(&amp;self) -&gt; u64 {
        self.inner as i32 as i64 as u64
    }
}

pub fn test_bv_extensions() {
    let r = Register::new(u32::MAX);
    assert(r.zero_extend() == u32::MAX as u64);
    assert(r.zero_extend() == 12); //~ ERROR refinement type
    assert(r.sign_extend() == u64::MAX);
    assert(r.sign_extend() == 12); //~ ERROR refinement type
}
<span class="boring">}</span></code></pre></pre>
<h3 id="bitvector-constants"><a class="header" href="#bitvector-constants">Bitvector Constants</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![flux::defs(
<span class="boring">fn main() {
</span>    fn is_start(x:bitvec&lt;32&gt;) -&gt; bool { x == START }
)]

#[flux::opaque]
#[flux::refined_by(val: bitvec&lt;32&gt;)]
pub struct BV32(u32);

impl BV32 {
    #[flux::trusted]
    #[flux::sig(fn (x:u32) -&gt; BV32[bv_int_to_bv32(x)])]
    const fn new(val: u32) -&gt; Self {
        BV32(val)
    }
}

#[flux_rs::constant(bv_int_to_bv32(0x4567))]
pub const START: BV32 = BV32::new(0x4567);

#[flux_rs::sig(fn () -&gt; BV32[START])]
pub fn test1() -&gt; BV32 {
    BV32::new(0x4567)
}

#[flux_rs::sig(fn () -&gt; BV32{v: is_start(v)})]
pub fn test2() -&gt; BV32 {
    BV32::new(0x4567)
}

#[flux_rs::sig(fn () -&gt; BV32{v: is_start(v)})]
pub fn test3() -&gt; BV32 {
    BV32::new(0x4568) //~ ERROR: refinement type
}
<span class="boring">}</span></code></pre></pre>
<h2 id="char-literals"><a class="header" href="#char-literals"><code>char</code> Literals</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn() -&gt; char['a'])]
pub fn char00() -&gt; char {
    'a'
}

#[flux::sig(fn(c: char{v: 'a' &lt;= v &amp;&amp; v &lt;= 'z'}) -&gt; bool[true])]
pub fn lowercase(c: char) -&gt; bool {
    'c' == 'c'
}
<span class="boring">}</span></code></pre></pre>
<h2 id="string-literals"><a class="header" href="#string-literals"><code>String</code> Literals</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn (&amp;str["cat"]))]
fn require_cat(_x: &amp;str) {}

pub fn test_cat() {
    require_cat("cat");
    require_cat("dog"); //~ ERROR refinement type
}

#[flux::sig(fn (&amp;str[@a], &amp;{str[@b] | a == b}))]
fn require_eq(_x: &amp;str, _y: &amp;str) {}

pub fn test_eq() {
    require_eq("a", "a");
    require_eq("a", "b"); //~ ERROR refinement type
}
<span class="boring">}</span></code></pre></pre>
<h2 id="extern-specs-1"><a class="header" href="#extern-specs-1">Extern Specs</a></h2>
<p>The <code>extern_spec</code> is used to provide <code>flux</code> signatures for functions defined in <em>external</em> crates. See the <a href="guide/specs.html">specifications guide</a> for more details.</p>
<h3 id="functions"><a class="header" href="#functions">Functions</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::slice::from_ref;

use flux_rs::extern_spec;

#[extern_spec]
#[flux::sig(fn(&amp;T) -&gt; &amp;[T][1])]
fn from_ref&lt;T&gt;(s: &amp;T) -&gt; &amp;[T];

#[flux::sig(fn(&amp;i32) -&gt; &amp;[i32]{n: n &gt; 0})]
pub fn test(x: &amp;i32) -&gt; &amp;[i32] {
    from_ref(x)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="options"><a class="header" href="#options">Options</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use flux_rs::extern_spec;

#[extern_spec]
#[flux::refined_by(b:bool)]
enum Option&lt;T&gt; {
    #[flux::variant(Option&lt;T&gt;[false])]
    None,
    #[flux::variant({T} -&gt; Option&lt;T&gt;[true])]
    Some(T),
}

#[extern_spec]
impl&lt;T&gt; Option&lt;T&gt; {
    #[sig(fn(&amp;Option&lt;T&gt;[@b]) -&gt; bool[b])]
    const fn is_some(&amp;self) -&gt; bool;

    #[sig(fn(&amp;Option&lt;T&gt;[@b]) -&gt; bool[!b])]
    const fn is_none(&amp;self) -&gt; bool;
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[path = "../../lib/option.rs"]
mod option;

#[flux::trusted]
#[flux::sig(fn(i32{v: false}) -&gt; T)]
pub fn never&lt;T&gt;(_: i32) -&gt; T {
    loop {}
}

#[flux::sig(fn(x:Option&lt;T&gt;[true]) -&gt; T)]
pub fn my_unwrap&lt;T&gt;(x: Option&lt;T&gt;) -&gt; T {
    match x {
        Option::Some(v) =&gt; v,
        Option::None =&gt; never(0),
    }
}

#[flux::sig(fn(T) -&gt; Option&lt;T&gt;[true])]
fn my_some&lt;T&gt;(x: T) -&gt; Option&lt;T&gt; {
    Option::Some(x)
}

#[flux::sig(fn(bool[true]))]
fn assert(_b: bool) {}

pub fn test1() {
    let x = my_some(42);
    let y = my_unwrap(x);
    assert(y == 42);
}

pub fn test3() {
    let x = Option::Some(42);
    let y = my_unwrap(x);
    assert(y == 42);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="vec"><a class="header" href="#vec">Vec</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use flux_rs::extern_spec;

#[extern_spec]
#[flux::refined_by(b:bool)]
enum Option&lt;T&gt; {
    #[flux::variant(Option&lt;T&gt;[false])]
    None,
    #[flux::variant({T} -&gt; Option&lt;T&gt;[true])]
    Some(T),
}

#[extern_spec]
impl&lt;T&gt; Option&lt;T&gt; {
    #[sig(fn(&amp;Option&lt;T&gt;[@b]) -&gt; bool[b])]
    const fn is_some(&amp;self) -&gt; bool;

    #[sig(fn(&amp;Option&lt;T&gt;[@b]) -&gt; bool[!b])]
    const fn is_none(&amp;self) -&gt; bool;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="structs-1"><a class="header" href="#structs-1">Structs</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Testing we can add external specs to "transparent" structs.

use flux_rs::extern_spec;

#[extern_spec(std::ops)]
#[refined_by(start: Idx, end: Idx)]
struct Range&lt;Idx&gt; {
    #[field(Idx[start])]
    start: Idx,
    #[field(Idx[end])]
    end: Idx,
}

#[extern_spec(std::ops)]
#[generics(Idx as base)]
impl&lt;Idx: PartialOrd&lt;Idx&gt;&gt; Range&lt;Idx&gt; {
    // This specification is actually unsound for `Idx`s where the `PartialOrd` implementation doesn't
    // match the logical `&lt;`.
    #[sig(fn(&amp;Range&lt;Idx&gt;[@r]) -&gt; bool[!(r.start &lt; r.end)])]
    fn is_empty(&amp;self) -&gt; bool;
}

#[flux::sig(fn(bool[true]))]
fn assert(_: bool) {}

fn test00() {
    let r = 0..1;
    assert(!r.is_empty());
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Extern spec of a type with a lifetime

use std::slice::Iter;

use flux_rs::*;

#[extern_spec]
#[refined_by(len: int)]
struct Iter&lt;'a, T&gt;;

#[extern_spec]
impl&lt;'a, T&gt; Iter&lt;'a, T&gt; {
    #[spec(fn as_slice(&amp;Iter&lt;T&gt;[@n]) -&gt; &amp;[T][n])]
    fn as_slice(v: &amp;Iter&lt;'a, T&gt;) -&gt; &amp;'a [T];
}

#[extern_spec]
impl&lt;T&gt; [T] {
    #[spec(fn iter(&amp;[T][@n]) -&gt; Iter&lt;T&gt;[n])]
    fn iter(v: &amp;[T]) -&gt; Iter&lt;'_, T&gt;;
}

#[spec(fn test00(x: &amp;[i32][@n]) -&gt; &amp;[i32][n])]
fn test00(x: &amp;[i32]) -&gt; &amp;[i32] {
    x.iter().as_slice()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="impls"><a class="header" href="#impls">Impls</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use flux_rs::extern_spec;

#[extern_spec]
#[flux::refined_by(len: int)]
struct String;

#[extern_spec]
impl String {
    #[flux::sig(fn() -&gt; String[0])]
    fn new() -&gt; String;

    #[flux::sig(fn(&amp;String[@n]) -&gt; usize[n])]
    fn len(s: &amp;String) -&gt; usize;

    #[flux::sig(fn(&amp;String[@n]) -&gt; bool[n == 0])]
    fn is_empty(s: &amp;String) -&gt; bool;

    #[flux::sig(fn(s: &amp;strg String[@n], char) ensures s: String[n+1])]
    fn push(s: &amp;mut String, c: char);

    #[flux::sig(fn(s: &amp;strg String[@n]) -&gt; Option&lt;char&gt;
                requires n &gt; 0
                ensures s: String[n-1])]
    fn pop(s: &amp;mut String) -&gt; Option&lt;char&gt;;

    #[flux::sig(fn(&amp;String[@n]) -&gt; &amp;[u8][n])]
    fn as_bytes(s: &amp;String) -&gt; &amp;[u8];
}

#[extern_spec]
impl&lt;T&gt; [T] {
    #[flux::sig(fn(&amp;[T][@n]) -&gt; usize[n])]
    fn len(v: &amp;[T]) -&gt; usize;

    #[flux::sig(fn(&amp;[T][@n]) -&gt; bool[n == 0])]
    fn is_empty(v: &amp;[T]) -&gt; bool;
}

#[flux::sig(fn(bool[@b]) requires b)]
pub fn assert_true(_: bool) {}

pub fn test_string() {
    let mut s = String::new();
    assert_true(s.is_empty());
    assert_true(s.as_bytes().is_empty());
    s.push('h');
    s.push('i');
    assert_true(s.len() == 2);
    s.pop();
    assert_true(s.len() == 1);
    s.pop();
    assert_true(s.is_empty());
    assert_true(s.as_bytes().is_empty());
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//@aux-build:extern_spec_impl01_aux.rs

extern crate extern_spec_impl01_aux;

use extern_spec_impl01_aux::MyTrait;
use flux_rs::extern_spec;

#[extern_spec]
impl&lt;T&gt; MyTrait for Vec&lt;T&gt; {
    #[flux::sig(fn() -&gt; i32[10])]
    fn foo() -&gt; i32;
}

#[flux::sig(fn () -&gt; i32[10])]
pub fn test_ok() -&gt; i32 {
    &lt;Vec&lt;i32&gt; as MyTrait&gt;::foo()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="traits"><a class="header" href="#traits">Traits</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use flux_rs::*;

#[extern_spec(std::cmp)]
#[generics(Self as base, Rhs as base)]
#[assoc(fn eq_rel(lhs: Self, rhs: Rhs) -&gt; bool)]
trait PartialEq&lt;Rhs&gt; {
    #[sig(fn(&amp;Self[@lhs], &amp;Rhs[@rhs]) -&gt; bool[&lt;Self as PartialEq&lt;Rhs&gt;&gt;::eq_rel(lhs, rhs)])]
    fn eq(&amp;self, other: &amp;Rhs) -&gt; bool;
}

#[refined_by(n: int)]
struct MyInt(#[field(i32[n])] i32);

#[assoc(fn eq_rel(lhs: MyInt, rhs: MyInt) -&gt; bool { lhs == rhs })]
impl PartialEq for MyInt {
    #[sig(fn(&amp;Self[@lhs], &amp;MyInt[@rhs]) -&gt; bool[&lt;MyInt as PartialEq&lt;MyInt&gt;&gt;::eq_rel(lhs, rhs)])]
    fn eq(&amp;self, other: &amp;MyInt) -&gt; bool {
        self.0 == other.0
    }
}

#[sig(fn(x: T, y: T) -&gt; bool[&lt;T as PartialEq&lt;T&gt;&gt;::eq_rel(x, y)])]
fn test00&lt;T: PartialEq&gt;(x: T, y: T) -&gt; bool {
    x == y
}

#[sig(fn(x: MyInt, y: MyInt) -&gt; bool[x == y])]
fn test01(x: MyInt, y: MyInt) -&gt; bool {
    test00(x, y)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="for-loops-with-range-ij"><a class="header" href="#for-loops-with-range-ij"><code>for</code> loops with range <code>i..j</code></a></h3>
<p>To see how <code>flux</code> handles <code>for i in 0..n</code> style loops:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(step_trait)]
#![allow(unused)]

<span class="boring">fn main() {
</span>#[path = "../../lib/iterator.rs"]
mod iterator;

#[flux_rs::sig(fn (bool[true]))]
fn assert(b: bool) {}

fn donald() {
    let n: i32 = 10;
    let mut thing = 0..n;
    let a = thing.next().unwrap();
    assert(a == 0);
    let b = thing.next().unwrap();
    assert(b == 1);
    let c = thing.next().unwrap();
    assert(c == 2);
}

#[flux_rs::sig(fn (n:i32{n == 99}))]
fn goofy(n: i32) {
    let mut thing = 0..n;
    let a0 = thing.end;
    assert(a0 == n);
    while let Some(i) = thing.next() {
        assert(0 &lt;= i);
        assert(i &lt; n);
    }
}

#[flux_rs::sig(fn (n:i32{n == 99}))]
fn mickey(n: i32) {
    for i in 0..n {
        assert(0 &lt;= i);
        assert(i &lt; n);
    }
}

#[flux_rs::trusted]
fn cond() -&gt; bool {
    todo!()
}

fn test(len: i32) {
    if len &gt;= 0 {
        let mut del = 0;
        for i in 0..len {
            assert(del &lt;= i);
            if cond() {
                del += 1;
            }
        }
        assert(del &lt;= len)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="associated-refinements"><a class="header" href="#associated-refinements">Associated Refinements</a></h2>
<h3 id="basic"><a class="header" href="#basic">Basic</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![allow(dead_code)]

<span class="boring">fn main() {
</span>use flux_rs::attrs::*;

trait MyTrait {
    #![reft(fn f(x: int) -&gt; int)]
    //
}

struct Add1;

impl MyTrait for Add1 {
    #![reft(fn f(x: int) -&gt; int { x + 1 })]
    //
}

#[sig(fn(x: i32{v: v == &lt;Add1 as MyTrait&gt;::f(0) }))]
fn test00(_x: i32) {}

fn test01() {
    test00(1);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="check-subtyping-at-impl"><a class="header" href="#check-subtyping-at-impl">Check Subtyping at Impl</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// test that implementations with extra const generics work as expected

use flux_rs::attrs::*;

#[reft(fn p(x: int) -&gt; bool)]
trait MyTrait {
    #[sig(fn() -&gt; i32{ v: &lt;Self as MyTrait&gt;::p(v) })]
    fn method() -&gt; i32;
}

struct MyStruct&lt;const N: i32&gt;;

// This implementation requires proving `x == N =&gt; x &gt;= N`
#[reft(fn p(x: int) -&gt; bool { x &gt;= N })]
impl&lt;const N: i32&gt; MyTrait for MyStruct&lt;N&gt; {
    #[sig(fn() -&gt; i32{v: v == N})]
    fn method() -&gt; i32 {
        N
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="default"><a class="header" href="#default">Default</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use flux_rs::attrs::*;

pub trait MyTrait {
    #![reft(fn f(x: int) -&gt; int { x + 1 })]
    //
}

// -----------------------------------------------------------------------------

pub struct Add1;

// Use the "default" assoc reft for Add1
impl MyTrait for Add1 {}

#[flux::sig(fn() -&gt; i32{v: v == &lt;Add1 as MyTrait&gt;::f(0)})]
pub fn test1_ok() -&gt; i32 {
    1
}

#[flux::sig(fn() -&gt; i32{v: v == &lt;Add1 as MyTrait&gt;::f(0)})]
pub fn test1_fail() -&gt; i32 {
    99 //~ ERROR: refinement type error
}

// -----------------------------------------------------------------------------

pub struct Add2;

// Specify a custom assoc reft for Add2
impl MyTrait for Add2 {
    #![reft(fn f(x: int) -&gt; int { x + 2 })]
    //
}

#[flux::sig(fn() -&gt; i32{v: v == &lt;Add2 as MyTrait&gt;::f(0)})]
pub fn test2() -&gt; i32 {
    2
}
<span class="boring">}</span></code></pre></pre>
<h3 id="use-in-extern-spec"><a class="header" href="#use-in-extern-spec">Use in Extern Spec</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use flux_rs::*;

#[extern_spec(std::cmp)]
#[generics(Self as base, Rhs as base)]
#[assoc(fn eq_rel(lhs: Self, rhs: Rhs) -&gt; bool)]
trait PartialEq&lt;Rhs&gt; {
    #[sig(fn(&amp;Self[@lhs], &amp;Rhs[@rhs]) -&gt; bool[&lt;Self as PartialEq&lt;Rhs&gt;&gt;::eq_rel(lhs, rhs)])]
    fn eq(&amp;self, other: &amp;Rhs) -&gt; bool;
}

#[refined_by(n: int)]
struct MyInt(#[field(i32[n])] i32);

#[assoc(fn eq_rel(lhs: MyInt, rhs: MyInt) -&gt; bool { lhs == rhs })]
impl PartialEq for MyInt {
    #[sig(fn(&amp;Self[@lhs], &amp;MyInt[@rhs]) -&gt; bool[&lt;MyInt as PartialEq&lt;MyInt&gt;&gt;::eq_rel(lhs, rhs)])]
    fn eq(&amp;self, other: &amp;MyInt) -&gt; bool {
        self.0 == other.0
    }
}

#[sig(fn(x: T, y: T) -&gt; bool[&lt;T as PartialEq&lt;T&gt;&gt;::eq_rel(x, y)])]
fn test00&lt;T: PartialEq&gt;(x: T, y: T) -&gt; bool {
    x == y
}

#[sig(fn(x: MyInt, y: MyInt) -&gt; bool[x == y])]
fn test01(x: MyInt, y: MyInt) -&gt; bool {
    test00(x, y)
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::{
    alloc::{Allocator, Global},
    ops::{Index, IndexMut},
    slice::{Iter, SliceIndex},
};

use flux_rs::extern_spec;

#[extern_spec]
#[flux::refined_by(len: int)]
struct Vec&lt;T, A: Allocator = Global&gt;;

#[extern_spec]
#[flux::assoc(fn in_bounds(idx: Self, v: T) -&gt; bool)]
trait SliceIndex&lt;T&gt;
where
    T: ?Sized,
{
}

#[extern_spec]
#[flux::assoc(fn in_bounds(idx: int, len: int) -&gt; bool {idx &lt; len} )]
impl&lt;T&gt; SliceIndex&lt;[T]&gt; for usize {}

#[extern_spec]
impl&lt;T, I: SliceIndex&lt;[T]&gt;, A: Allocator&gt; Index&lt;I&gt; for Vec&lt;T, A&gt; {
    #[flux::sig(fn(&amp;Vec&lt;T, A&gt;[@len], {I[@idx] | &lt;I as SliceIndex&lt;[T]&gt;&gt;::in_bounds(idx, len)}) -&gt; _)]
    fn index(z: &amp;Vec&lt;T, A&gt;, index: I) -&gt; &amp;&lt;I as SliceIndex&lt;[T]&gt;&gt;::Output;
}

#[extern_spec]
impl&lt;T, I: SliceIndex&lt;[T]&gt;, A: Allocator&gt; IndexMut&lt;I&gt; for Vec&lt;T, A&gt; {
    #[flux::sig(fn(&amp;mut Vec&lt;T,A&gt;[@len], {I[@idx] | &lt;I as SliceIndex&lt;[T]&gt;&gt;::in_bounds(idx, len)}) -&gt; _)]
    fn index_mut(z: &amp;mut Vec&lt;T, A&gt;, index: I) -&gt; &amp;mut &lt;I as SliceIndex&lt;[T]&gt;&gt;::Output;
}

//---------------------------------------------------------------------------------------

#[extern_spec]
impl&lt;T&gt; Vec&lt;T&gt; {
    #[flux::sig(fn() -&gt; Vec&lt;T&gt;[0])]
    fn new() -&gt; Vec&lt;T&gt;;
}

#[extern_spec]
impl&lt;T, A: Allocator&gt; Vec&lt;T, A&gt; {
    #[flux::sig(fn(self: &amp;strg Vec&lt;T, A&gt;[@n], T) ensures self: Vec&lt;T, A&gt;[n+1])]
    fn push(v: &amp;mut Vec&lt;T, A&gt;, value: T);

    #[flux::sig(fn(&amp;Vec&lt;T, A&gt;[@n]) -&gt; usize[n])]
    fn len(v: &amp;Vec&lt;T, A&gt;) -&gt; usize;
}

#[extern_spec]
impl&lt;'a, T, A: Allocator&gt; IntoIterator for &amp;'a Vec&lt;T, A&gt; {
    #[flux::sig(fn (&amp;Vec&lt;T, A&gt;[@n]) -&gt; &lt;&amp;Vec&lt;T, A&gt; as IntoIterator&gt;::IntoIter[0,n])]
    fn into_iter(v: &amp;'a Vec&lt;T, A&gt;) -&gt; &lt;&amp;'a Vec&lt;T, A&gt; as IntoIterator&gt;::IntoIter;
}

#[extern_spec]
#[flux::assoc(fn with_size(self: Self, n:int) -&gt; bool { self.len == n })]
impl&lt;T&gt; FromIterator&lt;T&gt; for Vec&lt;T&gt; {}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use flux_rs::extern_spec;

// Specs for std::slice::Iter and Enumerate
#[extern_spec(std::slice)]
#[refined_by(idx: int, len: int)]
struct Iter&lt;'a, T&gt;;

#[extern_spec(std::iter)]
#[refined_by(idx: int, inner: I)]
struct Enumerate&lt;I&gt;;

#[extern_spec(std::iter)]
#[refined_by(inner: I)]
struct Map&lt;I, F&gt;;

#[extern_spec]
#[flux::assoc(fn with_size(self: Self, n:int) -&gt; bool { true })] // default: don't know!
trait FromIterator&lt;A&gt; {}

#[extern_spec(std::iter)]
#[flux::assoc(fn size(self: Self) -&gt; int)]
#[flux::assoc(fn done(self: Self) -&gt; bool )]
#[flux::assoc(fn step(self: Self, other: Self) -&gt; bool )]
trait Iterator {
    #[flux::sig(fn(self: &amp;strg Self[@curr_s]) -&gt; Option&lt;Self::Item&gt;[!&lt;Self as Iterator&gt;::done(curr_s)] ensures self: Self{next_s: &lt;Self as Iterator&gt;::step(curr_s, next_s)})]
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    #[flux::sig(fn(Self[@s]) -&gt; Enumerate&lt;Self&gt;[0, s])]
    fn enumerate(self) -&gt; Enumerate&lt;Self&gt;
    where
        Self: Sized;

    #[flux::sig(fn(Self[@s], f: F) -&gt; Map&lt;Self, F&gt;[s])]
    fn map&lt;B, F&gt;(self, f: F) -&gt; Map&lt;Self, F&gt;
    where
        Self: Sized,
        F: FnMut(Self::Item) -&gt; B;

    #[flux::sig(fn (Self[@s]) -&gt; B{v: &lt;B as FromIterator&lt;Self::Item&gt;&gt;::with_size(v, &lt;Self as Iterator&gt;::size(s))})]
    fn collect&lt;B: FromIterator&lt;Self::Item&gt;&gt;(self) -&gt; B
    where
        Self: Sized;
}

#[extern_spec(std::slice)]
#[flux::assoc(fn size(x: Iter) -&gt; int { x.len - x.idx })]
#[flux::assoc(fn done(x: Iter) -&gt; bool { x.idx &gt;= x.len })]
#[flux::assoc(fn step(x: Iter, y: Iter) -&gt; bool { x.idx + 1 == y.idx &amp;&amp; x.len == y.len})]
impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    #[flux::sig(fn(self: &amp;strg Iter&lt;T&gt;[@curr_s]) -&gt; Option&lt;_&gt;[curr_s.idx &lt; curr_s.len] ensures self: Iter&lt;T&gt;{next_s: curr_s.idx + 1 == next_s.idx &amp;&amp; curr_s.len == next_s.len})]
    fn next(&amp;mut self) -&gt; Option&lt;&amp;'a T&gt;;
}

#[extern_spec(std::iter)]
#[flux::assoc(fn size(x: Enumerate&lt;I&gt;) -&gt; int { &lt;I as Iterator&gt;::size(x.inner) })]
#[flux::assoc(fn done(x: Enumerate&lt;I&gt;) -&gt; bool { &lt;I as Iterator&gt;::done(x.inner)})]
#[flux::assoc(fn step(x: Enumerate&lt;I&gt;, y: Enumerate&lt;I&gt;) -&gt; bool { &lt;I as Iterator&gt;::step(x.inner, y.inner)})]
impl&lt;I: Iterator&gt; Iterator for Enumerate&lt;I&gt; {
    #[flux::sig(fn(self: &amp;strg Enumerate&lt;I&gt;[@curr_s]) -&gt; Option&lt;(usize[curr_s.idx], _)&gt;[!&lt;I as Iterator&gt;::done(curr_s.inner)]
    ensures self: Enumerate&lt;I&gt;{next_s: curr_s.idx + 1 == next_s.idx &amp;&amp; &lt;I as Iterator&gt;::step(curr_s.inner, next_s.inner)})]
    fn next(&amp;mut self) -&gt; Option&lt;(usize, &lt;I as Iterator&gt;::Item)&gt;;
}

#[extern_spec(std::iter)]
#[flux::assoc(fn size(x: Map&lt;I&gt;) -&gt; int { &lt;I as Iterator&gt;::size(x.inner) })]
#[flux::assoc(fn done(x: Map&lt;I&gt;) -&gt; bool { &lt;I as Iterator&gt;::done(x.inner)})]
#[flux::assoc(fn step(x: Map&lt;I&gt;, y: Map&lt;I&gt;) -&gt; bool { &lt;I as Iterator&gt;::step(x.inner, y.inner)})]
impl&lt;B, I: Iterator, F: FnMut(I::Item) -&gt; B&gt; Iterator for Map&lt;I, F&gt; {} // orig: where F: FnMut(I::Item) -&gt; B {}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![allow(unused)]
#![feature(allocator_api)]

<span class="boring">fn main() {
</span>use std::{iter::Enumerate, slice::Iter};

#[path = "../../lib/option.rs"]
mod option;

#[path = "../../lib/slice.rs"]
mod slice;

#[path = "../../lib/vec.rs"]
mod vec;

#[path = "../../lib/iter.rs"]
mod iter;

#[flux::sig(fn(bool[true]))]
pub fn assert(_b: bool) {}

// Tests
#[flux::sig(fn(slice: &amp;[u8]{n: n &gt; 0}))]
fn test_iter1(slice: &amp;[u8]) {
    let mut iter = slice.iter();
    let next = iter.next();
    assert(next.is_some());
}

#[flux::sig(fn(slice: &amp;[u8]{n: n &gt; 1}))]
fn test_enumerate1(slice: &amp;[u8]) {
    assert(slice.len() &gt; 0);
    let mut enumer = slice.iter().enumerate();

    let next = enumer.next();
    assert(next.is_some());
    let (idx, _) = next.unwrap();
    assert(idx == 0);

    let next_next = enumer.next();
    assert(next_next.is_some());
    let (idx, _) = next_next.unwrap();
    assert(idx == 1);
}

#[flux::sig(fn(&amp;[usize][1]) )]
pub fn test_enumer2(slice: &amp;[usize]) {
    assert(slice.len() == 1);
    let mut enumer = slice.iter().enumerate();

    let next = enumer.next();
    assert(next.is_some());

    let next_next = enumer.next();
    assert(next_next.is_none())
}

#[flux::sig(fn(&amp;[usize][@n]) )]
pub fn test_enumer3(slice: &amp;[usize]) {
    let mut e = slice.iter().enumerate();
    while let Some((idx, _)) = e.next() {
        assert(idx &lt; slice.len())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="associated-types"><a class="header" href="#associated-types">Associated Types</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use flux_rs::attrs::*;

trait MyTrait {
    #![reft(fn f(x: int) -&gt; int)]
    //
}

struct Add1;

#[assoc(fn f(x: int) -&gt; int { x + 1 })]
impl MyTrait for Add1 {}

#[sig(fn(x: i32{v: v == &lt;Add1 as MyTrait&gt;::f(0) }))]
fn test00(x: i32) {}

fn test01() {
    test00(0); //~ ERROR refinement type error
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Testing that we properly map generics in trait's default associated refinement
// body into the impl.

use flux_rs::attrs::*;

trait MyTrait {
    #![reft(fn p(x: Self) -&gt; bool { true })]

    #[sig(fn(&amp;Self{v: &lt;Self as MyTrait&gt;::p(v)}))]
    fn method(&amp;self);
}

impl MyTrait for i32 {
    #[sig(fn(&amp;Self{v: &lt;Self as MyTrait&gt;::p(v)}))]
    fn method(&amp;self) {}
}

impl&lt;T&gt; MyTrait for S&lt;T&gt; {
    #[sig(fn(&amp;Self{v: &lt;Self as MyTrait&gt;::p(v)}))]
    fn method(&amp;self) {}
}

struct S&lt;T&gt; {
    f: T,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="refined-associated-types-1"><a class="header" href="#refined-associated-types-1">Refined Associated Types</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use flux_rs::*;

#[assoc(fn can_fit(self: Self, animal: Self::Animal) -&gt; bool)]
trait Barn {
    type Animal;

    #[sig(fn(self: &amp;mut Self[@barn], animal: Self::Animal{ &lt;Self as Barn&gt;::can_fit(barn, animal) }))]
    fn put_animal_in_house(&amp;mut self, animal: Self::Animal);
}

#[refined_by(size: int)]
struct Horse {
    #[field(i32[size])]
    size: i32,
}

#[refined_by(max_size: int)]
struct HorseBarn {
    #[field(i32[max_size])]
    max_size: i32,
}

#[assoc(fn can_fit(self: HorseBarn, horse: Horse) -&gt; bool { horse.size &lt;= self.max_size })]
impl Barn for HorseBarn {
    type Animal = Horse;

    #[trusted]
    #[sig(fn(self: &amp;mut Self[@barn], horse: Horse { horse.size &lt;= barn.max_size}))]
    fn put_animal_in_house(&amp;mut self, horse: Horse) {}
}

fn test00() {
    let mut barn = HorseBarn { max_size: 20 };
    let horse = Horse { size: 10 };

    barn.put_animal_in_house(horse);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="checking-overflows"><a class="header" href="#checking-overflows">Checking Overflows</a></h2>
<p>You can switch on overflow checking</p>
<ul>
<li><em>globally</em> <a href="http://localhost:3000/guide/run.html?highlight=cache#flux-flags">with a flag</a> or</li>
<li><em>locally</em> with an attribute as shown below</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const MAX: u32 = std::u32::MAX;

// Error on this as it may overflow
#[flux::opts(check_overflow = true)]
#[flux::sig(fn (u32[@x], u32[@y], u32[@z]) -&gt; u32[x + y + z] requires x + y + z &lt;= MAX)]
fn add_three(x: u32, y: u32, z: u32) -&gt; u32 {
    x + y + z
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::opts(check_overflow = true)]
mod my_mod {
    const MAX: u32 = std::u32::MAX;

    #[flux::sig(fn(u32[@x], u32[@y]) -&gt; u32[x + y] requires x + y &lt;= MAX)]
    fn add(x: u32, y: u32) -&gt; u32 {
        x + y
    }

    #[flux::sig(fn(u32[@x]) -&gt; u32[x + 2] requires x + 2 &lt;= MAX)]
    fn add2(x: u32) -&gt; u32 {
        x + 2
    }
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const MAX: u32 = std::u32::MAX;

#[flux_rs::refined_by(inner: int)]
struct MyStruct {
    #[field(u32[inner])]
    inner: u32,
}

impl MyStruct {
    fn add1(&amp;self) -&gt; u32 {
        self.inner + 1
    }

    // Error as this may overflow
    #[flux::opts(check_overflow = true)]
    #[flux::sig(fn (&amp;MyStruct[@inner]) -&gt; u32[inner + 2] requires inner + 2 &lt;= MAX)]
    fn add2(&amp;self) -&gt; u32 {
        self.inner + 2
    }
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const MAX: u32 = std::u32::MAX;

struct MyStruct {
    inner: u32,
}

#[flux::opts(check_overflow = true)]
trait MyTrait {
    #[flux::sig(fn(u32[@x], { u32[@y] | x + y &lt;= MAX }) -&gt; u32[x + y] )]
    fn add(x: u32, y: u32) -&gt; u32;
}

impl MyTrait for MyStruct {
    #[flux::sig(fn(u32[@x], { u32[@y] | x + y &lt;= MAX }) -&gt; u32[x + y] )]
    fn add(x: u32, y: u32) -&gt; u32 {
        x + y
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="developers-guide"><a class="header" href="#developers-guide">Developer's Guide</a></h1>
<h2 id="regression-tests"><a class="header" href="#regression-tests">Regression Tests</a></h2>
<p>You can run the various regression tests in the <code>tests/pos</code> and <code>tests/neg</code> directories using
<code>cargo xtask test</code></p>
<p>This will build the flux binary and then run it against the entire test suite.
You can optionally pass a <em>filter</em> to only run tests containing some substring.
For example:</p>
<pre><code class="language-console">$ cargo xtask test impl_trait
   Compiling xtask v0.1.0 (/path/to/flux/xtask)
    Finished dev [unoptimized + debuginfo] target(s) in 0.29s
     Running `target/debug/xtask test impl_trait`
$ cargo build
    Finished dev [unoptimized + debuginfo] target(s) in 0.05s
$ cargo test -p tests -- --test-args impl_trait
   Compiling fluxtests v0.1.0 (/path/to/flux/tests)
    Finished test [unoptimized + debuginfo] target(s) in 0.62s
     Running tests/compiletest.rs (target/debug/deps/compiletest-1241128f1f51caa4)

running 5 tests
test [ui] pos/surface/impl_trait04.rs ... ok
test [ui] pos/surface/impl_trait03.rs ... ok
test [ui] pos/surface/impl_trait01.rs ... ok
test [ui] pos/surface/impl_trait00.rs ... ok
test [ui] pos/surface/impl_trait02.rs ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 191 filtered out; finished in 0.10s


running 2 tests
test [compile-fail] neg/surface/impl_trait00.rs ... ok
test [compile-fail] neg/surface/impl_trait02.rs ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 207 filtered out; finished in 0.09s
</code></pre>
<h2 id="testing-flux-on-a-file"><a class="header" href="#testing-flux-on-a-file">Testing Flux on a File</a></h2>
<p>When working on Flux, you may want to test your changes by running it against a test file.
You can use <code>cargo xtask run &lt;input&gt;</code> to run Flux on a single input file.
The command will set appropriate flags to be able to use custom Flux attributes and macros,
plus some extra flags useful for debugging.
For example:</p>
<pre><code class="language-console">$ cat test.rs
#[flux::sig(fn(x: i32) -&gt; i32[x + 1])]
fn add1(x: i32) -&gt; i32 {
    x + 1
}
$ cargo xtask run test.rs
</code></pre>
<p>The command will use a super set of the flags passed when running regression tests.
Thus, a common workflow is to identify a failing test and run it directly with <code>cargo xtask run</code>,
or alternatively copy it to a different file.</p>
<p>You may also find useful to create a directory in the root of the project and add it to
<a href="https://git-scm.com/docs/gitignore"><code>.git/info/exclude</code></a>.
You can keep files there, outside of version control, and test Flux against them.
I have a directory called <code>attic/</code> where I keep a file named <code>playground.rs</code>.
To run Flux on it, I do <code>cargo xtask run attic/playground.rs</code>.</p>
<h2 id="reporting-locations-where-errors-are-emitted"><a class="header" href="#reporting-locations-where-errors-are-emitted">Reporting locations where errors are emitted</a></h2>
<p>When you use <code>cargo xtask run</code> you'll see that we report the location an error was emitted, e.g.,</p>
<pre><code class="language-console">error[FLUX]: refinement type error
 --&gt; attic/playground.rs:4:5
  |
4 |     0
  |     ^ a postcondition cannot be proved
-Ztrack-diagnostics: created at crates/flux-refineck/src/lib.rs:114:15   &lt;------- this
</code></pre>
<p>You can also pass <code>-Ztrack-diagnostics=y</code> to enable it if you are not using <code>cargo xtask run</code></p>
<h2 id="macro-expansion"><a class="header" href="#macro-expansion">Macro expansion</a></h2>
<p>For example if you have code like in <code>path/to/file.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[extern_spec]
#[flux::refined_by(elems: Set&lt;T&gt;)]
struct HashSet&lt;T, S = RandomState&gt;;
<span class="boring">}</span></code></pre></pre>
<p>and you want to see what the <code>extern_spec</code> macro expands it out to, then run</p>
<pre><code class="language-shell">cargo x run -- -Zunpretty=expanded path/to/file.rs
</code></pre>
<p>Or you can run the <code>xtask</code> command directly</p>
<pre><code class="language-shell">cargo x expand path/to/file.rs
</code></pre>
<h2 id="reporting-and-dealing-with-bugs"><a class="header" href="#reporting-and-dealing-with-bugs">Reporting and dealing with bugs</a></h2>
<p>As Flux is under active development, there are many aspects of Rust that Flux does not yet support, are
only partially implemented, or where the implementation may contain bugs. These issues typically manifest
as unreachable arms in a match statement (that turn out not to be unreachable) or preemtive assertions to
guard against code we don't yet support. To help identify the code that triggers these bugs, there are a few
recommended methods for reporting them:</p>
<ul>
<li><code>QueryErr::bug</code>: Use this method to report a bug if the code already returns a <code>QueryResult</code>. This
approach is preferred because we will correctly recover from the error.</li>
<li><code>span_bug!</code>: When you have a <code>Span</code> at hand, you can use this macro in place of <code>panic!</code> to report
the span before panicking.</li>
<li><code>tracked_span_bug!</code>: This macro is similar to <code>span_bug!</code>, but it uses a span stored in a thread local
variable (if one exists). To track a span in the thread local variable you can use <code>flux_common::bug::track_span</code>.</li>
<li><code>bug!</code>: For other cases where none of the above applies, you can use the <code>bug!</code> macro. This behaves
mostly like <code>panic!</code> but with nicer formatting.</li>
</ul>
<p>When running Flux in a new code base, consider setting the flag <code>FLUX_CATCH_BUGS=1</code>. If this flag is set,
Flux will try to catch and recover from panics emitted with one of the bug macros (using
<code>std::panic::catch_unwind</code>). Bugs are caught at item boundaries. This may leave Flux or rustc
in an inconsistent state, so there are no guarantees that Flux will behave correctly after recovering
from a panic. However, this may still be useful to gather as many errors as possible. Code can
be selectively ignored later.</p>
<h2 id="dumping-the-checker-trace"><a class="header" href="#dumping-the-checker-trace">Dumping the Checker Trace</a></h2>
<pre><code>cargo x install --debug
FLUX_DUMP_CHECKER_TRACE=1 FLUX_CHECK_DEF=mickey cargo flux
python3  path/to/flux/tools/logreader.py
</code></pre>
<h2 id="debugging-extern-specs"><a class="header" href="#debugging-extern-specs">Debugging Extern Specs</a></h2>
<p>To see the expanded code of an <code>extern_spec</code> macro, you can do</p>
<pre><code>cargo x expand path/to/file.rs
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="high-level-architecture"><a class="header" href="#high-level-architecture">High-level Architecture</a></h1>
<p>Flux is implemented as a compiler <a href="https://rustc-dev-guide.rust-lang.org/rustc-driver.html?highlight=Callbacks%5C#rustc_driver-and-rustc_interface">driver</a>. We hook into the compiler by implementing the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_driver/trait.Callbacks.html"><code>Callbacks</code></a> trait. The implementation is located is in the <code>flux-driver</code> crate, and it is the main entry point to Flux.</p>
<h2 id="crates"><a class="header" href="#crates">Crates</a></h2>
<ul>
<li><code>crates/flux-bin</code>: Contains the <code>cargo-flux</code> and <code>flux</code> binaries used to launch the <code>flux-driver</code>.</li>
<li><code>crates/flux-common</code>: Common utility definitions used across all crates.</li>
<li><code>crates/flux-config</code>: Crate containing logic associated with global configuration flags that change the behavior of Flux, e.g, to enable or disable overflow checking.</li>
<li><code>crates/flux-desugar</code>: Implementation of name resolution and desugaring from Flux surface syntax into Flux high-level intermediate representation (<code>fhir</code>). This includes name resolution.</li>
<li><code>crates/flux-driver</code>: Main entry point to Flux. It contains the <code>flux-driver</code> binary and the implementation of the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_driver/trait.Callbacks.html"><code>Callbacks</code></a> trait.</li>
<li><code>crates/flux-errors</code>: Utility definitions for user facing error reporting.</li>
<li><code>crates/flux-fhir-analysis</code>: Implements the "analyses" performed in the <code>fhir</code>, most notably well-formedness checking and conversion from <code>fhir</code> into <code>rty</code>.</li>
<li><code>crates/flux-fixpoint</code>: Code to interact with the Liquid Fixpoint binary.</li>
<li><code>crates/flux-macros</code>: Procedural macros used internally to implement Flux.</li>
<li><code>crates/flux-metadata</code>: Logic for saving Flux crate metadata that can be used to import refined signatures from external crates.</li>
<li><code>crates/flux-middle</code>: This crate contains common type definitions that are used by the rest of Flux like the <code>rty</code> and <code>fhir</code> intermediate representations. Akin to <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/index.html"><code>rustc_middle</code></a>.</li>
<li><code>crates/flux-refineck</code>: Implementation of refinement type checking.</li>
<li><code>crates/flux-syntax</code>: Definition of the surface syntax AST and parser.</li>
<li><code>tests</code>: Flux regression tests.</li>
<li><code>lib/flux-attrs</code>: Implementation of user facing procedural macros for annotating programs with Flux specs.</li>
<li><code>lib/flux-rs</code>: This is just a re-export of the macros implemented in <code>flux-attrs</code>. The intention is to eventually put Flux "standard library" here, i.e., a set of definitions that are useful when working with Flux.</li>
</ul>
<h2 id="intermediate-representations"><a class="header" href="#intermediate-representations">Intermediate Representations</a></h2>
<p>Flux has several intermediate representations (IR) for types. They represent a refined version of an equivalent type in some <code>rustc</code> IR. We have picked a distinct <em>verb</em> to refer to the process of going between these different representations to make it easier to refer to them. The following image summarizes all the IRs and the process for going between them.</p>
<p><img src="dev/../img/irs.svg" alt="IRs diagram" /></p>
<h3 id="surface"><a class="header" href="#surface">Surface</a></h3>
<p>The surface IR represents source level Flux annotations. It corresponds to the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/index.html"><code>rustc_ast</code></a> data structures in <code>rustc</code>. The definition as well as the parser is located in the <code>flux-syntax</code> crate.</p>
<h3 id="fhir"><a class="header" href="#fhir">Fhir</a></h3>
<p>The Flux High-Level Intermediate Representation (fhir) is a refined version of <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/index.html"><code>rustc</code>'s hir</a>. The definition is located in the <code>flux_middle</code> crate inside the <code>fhir</code> module. The process of going from <code>surface</code> to <code>fhir</code> is called <em>desugaring</em>, and it is implemented in the <code>flux-desugar</code> crate.</p>
<h3 id="rty"><a class="header" href="#rty">Rty</a></h3>
<p>The definition in the <code>flux_middle::rty</code> module correspond to a refined version of the main <code>rustc</code> representation for types defined in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/index.html"><code>rustc_middle::ty</code></a>. The process of going from <code>fhir</code> to <code>rty</code> is called <em>conversion</em>, and it is implemented in the <code>flux_fhir_analysis::conv</code> module.</p>
<h3 id="simplified-rustc"><a class="header" href="#simplified-rustc">Simplified Rustc</a></h3>
<p>The definition in the <code>flux_middle::rustc</code> module correspond to simplified version of data structures in <code>rustc</code>. They can be understood as the currently supported subset of Rust. The process of going from a definition in <code>rustc_middle</code> into <code>flux_middle::rustc</code> is called <em>lowering</em> and it is implemented in <code>flux_middle::rustc::lowering</code>.</p>
<h3 id="lifting-and-refining"><a class="header" href="#lifting-and-refining">Lifting and Refining</a></h3>
<p>Besides the different translation between Flux intermediate representations, there are two ways to get a refined version from a rust type. The process of going from a type in <code>hir</code> into a type in <code>fhir</code> is called <em>lifting</em>, and it is implemented in <code>flux_middle::fhir::lift</code>. The process for going from a type in <code>flux_middle::rustc::ty</code> into a <code>flux_middle::rty</code> is called <em>refining</em>, and it is implemented <code>flux_middle::rty::refining</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introducing-flux"><a class="header" href="#introducing-flux">Introducing Flux</a></h1>
<p><a href="https://flux.goto.ucsd.edu/?example=refinements.rs">Online demo</a></p>
<p>Types bring order to code. For example, if a variable <code>i:usize</code>
then we know <code>i</code> is a number that can be used to index a vector.
Similarly, if <code>v: vec&lt;&amp;str&gt;</code> then we can be sure that <code>v</code> is a
collection of strings which may <em>be</em> indexed but of course,
not used <em>as</em> an index. However, by itself <code>usize</code> doesn't
tell us how big or small the number and hence the programmer
must still rely on their own wits, a lot of tests, and a dash
of optimism, to ensure that all the different bits fit properly
at run-time.</p>
<p><a href="https://arxiv.org/abs/2010.07763">Refinements</a> are a promising new way to extend
type checkers with logical constraints that <em>specify</em> additional
correctness requirements that can be <em>verified</em> by the compiler,
thereby entirely eliminating various classes of run-time problems.</p>
<p>We're excited to introduce <a href="https://github.com/liquid-rust/flux/">Flux</a>, a refinement type
checker plugin that brings this technology to <code>Rust</code>.</p>
<!-- more -->
<h2 id="indexed-types"><a class="header" href="#indexed-types">Indexed Types</a></h2>
<p>The most basic form of refinement type in <code>flux</code> is a type that is
<em>indexed</em> by a logical value. For example</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left"><strong>Type</strong></th><th style="text-align: left"><strong>Meaning</strong></th></tr></thead><tbody>
<tr><td style="text-align: left"><code>i32[10]</code></td><td style="text-align: left">The (singleton) set of <code>i32</code> values equal to <code>10</code></td></tr>
<tr><td style="text-align: left"><code>bool[true]</code></td><td style="text-align: left">The (singleton) set of <code>bool</code> values equal to <code>true</code></td></tr>
</tbody></table>
</div>
<h3 id="post-conditions"><a class="header" href="#post-conditions">Post-Conditions</a></h3>
<p>We can already start using these indexed types to start writing (and checking)
code. For example, we can write the following specification which says that
the value <em>returned</em> by <code>mk_ten</code> must in fact be <code>10</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux_rs::sig(fn() -&gt; i32[10])]
pub fn mk_ten() -&gt; i32 {
    5 + 4
}
<span class="boring">}</span></code></pre></pre>
<p>but when you compile it, <code>flux</code> will say</p>
<pre><code class="language-bash">error[FLUX]: postcondition might not hold
 --&gt; src/basics.rs:7:5
  |
7 |     5 + 4
  |     ^^^^^
</code></pre>
<p>The error says that that the <em>postcondition might not hold</em> which means
that the <em>output</em> produced by <code>mk_ten</code> may not in fact be an <code>i32[10]</code>
as indeed, in this case, the result is <code>9</code>! You can eliminate the error
by replacing the body with <code>5 + 5</code> or just <code>10</code>.</p>
<img src="blog/../img/mk10.gif" width="100%">
<h3 id="pre-conditions"><a class="header" href="#pre-conditions">Pre-Conditions</a></h3>
<p>Here's a second example that shows how you can use an index to restrict
the space of <em>inputs</em> that a function expects.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux_rs::sig(fn (b:bool[true]))]
pub fn assert(b:bool) {
  if !b { panic!("assertion failed") }
}
<span class="boring">}</span></code></pre></pre>
<p>Here, the refined specification for <code>assert</code> says that you can <em>only</em> call
it with <code>true</code> as the input. So if you write</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn test(){
  assert(2 + 2 == 4);
  assert(2 + 2 == 5); // fails to type check
}
<span class="boring">}</span></code></pre></pre>
<p>then <code>flux</code> will complain that</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[FLUX]: precondition might not hold
  --&gt; src/basics.rs:12:5
   |
12 |     assert(2 + 2 == 5); // fails to type check
   |     ^^^^^^^^^^^^^^^^^^
<span class="boring">}</span></code></pre></pre>
<p>meaning that the call to <code>assert</code> fails to establish that
the input is indeed <code>true</code> (as of course, in this case, it is not!)</p>
<img src="blog/../img/assert.gif" width="100%">
<h2 id="index-parameters-and-expressions"><a class="header" href="#index-parameters-and-expressions">Index Parameters and Expressions</a></h2>
<p>It's not terribly exciting to only talk about <em>fixed</em> values
like <code>10</code> or <code>true</code>. To be more useful, <code>flux</code> lets you index
types by refinement <em>parameters</em>. For example, you can write</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux_rs::sig(fn(n:i32) -&gt; bool[0 &lt; n])]
pub fn is_pos(n: i32) -&gt; bool {
    if 0 &lt; n {
        true
    } else {
        false
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Here, the type says that <code>is_pos</code></p>
<ul>
<li>takes as <em>input</em> some <code>i32</code> <em>indexed by</em> <code>n</code></li>
<li>returns as <em>output</em> the <code>bool</code> <em>indexed by</em> <code>0 &lt; n</code></li>
</ul>
<p>in other words, the output is <code>true</code> <em>exactly when</em> <code>0 &lt; n</code>.</p>
<p>We might use this function to check that:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn test_pos(n: i32) {
  let m = if is_pos(n) { n - 1 } else { 0 };
  assert(0 &lt;= m);
}
<span class="boring">}</span></code></pre></pre>
<img src="blog/../img/test_pos.gif" width="100%">
<h2 id="existential-types"><a class="header" href="#existential-types">Existential Types</a></h2>
<p>Often we don't care about the <em>exact</em> value of a thing -- but just
care about some <em>properties</em> that it may have. For example, we don't
care that an <code>i32</code> is equal to <code>5</code> or <code>10</code> or <code>n</code> but that it is
non-negative.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left"><strong>Type</strong></th><th style="text-align: left"><strong>Meaning</strong></th></tr></thead><tbody>
<tr><td style="text-align: left"><code>i32{v: 0 &lt;  v}</code></td><td style="text-align: left">The set of <code>i32</code> values that positive</td></tr>
<tr><td style="text-align: left"><code>i32{v: n &lt;= v}</code></td><td style="text-align: left">The set of <code>i32</code> values greater than or equal to <code>n</code></td></tr>
</tbody></table>
</div>
<p>Flux allows such specifications by pairing plain Rust types
with <em>assertions</em> <sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup> that constrain the value. For example, we can rewrite
<code>mk_10</code> with the output type <code>i32{v:0&lt;v}</code> that specifies a weaker property:
the value returned by <code>mk_ten</code> is positive.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux_rs::sig(fn() -&gt; i32{v: 0 &lt; v})]
pub fn mk_ten() -&gt; i32 {
    5 + 5
}
<span class="boring">}</span></code></pre></pre>
<p>Similarly, you might specify that a function that computes the <em>absolute</em>
value of an <code>i32</code> with a type which says the result is non-negative <em>and</em>
exceeds the input <code>n</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux_rs::sig(fn (n:i32) -&gt; i32{v:0&lt;=v &amp;&amp; n&lt;=v})]
pub fn abs(n: i32) -&gt; i32 {
    if 0 &lt;= n {
        n
    } else {
        0 - n
    }
}
<span class="boring">}</span></code></pre></pre>
<p>As a last example, you might write a function to compute the factorial of <code>n</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux_rs::sig(fn (n:i32) -&gt; i32{v:1&lt;=v &amp;&amp; n&lt;=v})]
pub fn factorial(n: i32) -&gt; i32 {
    let mut i = 0;
    let mut res = 1;
    while i &lt; n {
        i += 1;
        res = res * i;
    }
    res
}
<span class="boring">}</span></code></pre></pre>
<p>Here the specification says the input must be non-negative, and the
output is at least as large as the input. Note, that unlike the previous
examples, here we're actually <em>changing</em> the values of <code>i</code> and <code>res</code>.</p>
<img src="blog/../img/factorial.gif" width="100%">
<p>Can you guess why the copilot suggestions <em>failed</em> to pass flux, and
what refinements were <em>inferred</em> for <code>i</code> and <code>res</code> in the <em>fixed</em> code
at the end?</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>In this post, we saw how Flux lets you</p>
<ol>
<li>
<p><em>decorate</em> basic Rust types like <code>i32</code> and <code>bool</code> with
<strong>indices</strong> and <strong>constraints</strong> that let you respectively
<em>refine</em> the sets of values that inhabit that type, and</p>
</li>
<li>
<p><em>specify</em> contracts on functions that state <strong>pre-conditions</strong> on
the sets of legal inputs that they accept, and <strong>post-conditions</strong>
that describe the outputs that they produce.</p>
</li>
</ol>
<p>The whole point of Rust, of course, is to allow for efficient <em>imperative</em>
sharing and updates, without sacrificing thread- or memory-safety. Next time,
we'll see how Flux melds refinements and Rust's ownership to make refinements
happily coexist with imperative code.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<p>These are not arbitrary Rust expressions but a subset of expressions
from logics that can be efficiently decided by <a href="https://github.com/flux-rs/flux/blob/main/book/src/guide/specs.md#grammar-of-refinements">SMT Solvers</a> <a href="#fr-1-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="ownership-in-flux"><a class="header" href="#ownership-in-flux">Ownership in Flux</a></h1>
<p><a href="https://flux.goto.ucsd.edu/?example=ownership.rs">Online demo</a></p>
<p><a href="https://liquid-rust.github.io/2022/11/14/introducing-flux/">Previously</a> we saw how to refine basic Rust
types like <code>i32</code> and <code>bool</code> with <em>indices</em> and <em>constraints</em> to
constrain the set of values described by those types.</p>
<p>The whole point of Rust, of course, is to allow for efficient
imperative <em>sharing</em> and <em>updates</em>, via the clever type system
that keeps an eye on the <em>ownership</em> of resources to make sure
that aliasing and mutation cannot happen at the same time.</p>
<p>Next, lets see how Flux melds refinements and Rust's ownership
mechanisms to make refinements work in the imperative setting.</p>
<h2 id="exclusive-ownership"><a class="header" href="#exclusive-ownership">Exclusive Ownership</a></h2>
<p>Rust's most basic form of ownership is <em>exclusive</em> ownership,
in which exactly one variable in a function has the right to
mutate a memory location. When a location is exclusively
owned, we can be sure that there are <em>no other references</em>
to it, which lets flux <em>update</em> the type whenever the location
is changed. For example, consider the program</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux_rs::sig(fn () -&gt; i32[3])]
pub fn mk_three() -&gt; i32 {
    let mut r = 0;  // r: i32[0]
    r += 1;
    assert(r == 1); // r: i32[1]
    r += 1;
    assert(r == 2); // r: i32[2]
    r += 1;
    assert(r == 3); // r: i32[3]
    r
}
<span class="boring">}</span></code></pre></pre>
<p>The variable <code>r</code> has <em>different types</em> at each point inside <code>mk_three</code>.
It starts off as <code>i32[0]</code>. The first increment changes it to <code>i32[1]</code>,
then <code>i32[2]</code> and finally, the returned type <code>i32[3]</code>.</p>
<img src="blog/../img/mk_three.gif" width="100%">
<p>This exclusive ownership mechanism is at work in the <code>factorial</code> example
we signed off with <a href="https://liquid-rust.github.io/2022/11/14/introducing-flux/">previously</a></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux_rs::sig(fn (n:i32{0 &lt;= n}) -&gt; i32{v:n &lt;= v})]
pub fn factorial(n: i32) -&gt; i32 {
    let mut i = 0;  // i: i32[0]
    let mut r = 1;  // r: i32[1]
    while i &lt; n {
                    // i: i32{v:0&lt;=v&lt;=n}
                    // r: i32{v:1&lt;=v &amp;&amp; i&lt;=v}
        i += 1;
        r = r * i;
    }
    r
}
<span class="boring">}</span></code></pre></pre>
<p>In the above code, <code>i</code> and <code>r</code> start off at <code>0</code> and <code>1</code> but then
Rust <em>infers</em> (a story for another day) that inside the <code>while</code>-loop<sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup></p>
<ul>
<li><code>i</code> has type <code>i32{v:0&lt;=v &amp;&amp; v &lt; n}</code></li>
<li><code>r</code> has type <code>i32{v:1&lt;=v &amp;&amp; i &lt;= v}</code></li>
</ul>
<p>and hence, upon exit since <code>i == n</code> we get that the result is at least <code>n</code>.</p>
<h2 id="borrowing-shared-references"><a class="header" href="#borrowing-shared-references">Borrowing: Shared References</a></h2>
<p>Exclusive ownership suffices for simple local updates like in <code>factorial</code>.
However, for more complex data, functions must temporarily relinquish
ownership to allow <em>other</em> functions to mutate the data. Rust cleverly
allows this via the notion of <em>borrowing</em> using two kinds of references
that give callees temporary access to a memory location.</p>
<p>The simplest kind of references are of the form <code>&amp;T</code> which denote <em>read-only</em>
access to a value of type <code>T</code>. For example, we might write <code>abs</code> to take
a shared reference to an <code>i32</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux_rs::sig(fn (p: &amp;i32[@n]) -&gt; i32{v:0&lt;=v &amp;&amp; n&lt;=v})]
pub fn abs(p: &amp;i32) -&gt; i32 {
    let n = *p;
    if 0 &lt;= n {
        n
    } else {
        0 - n
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Notice that the <em>input</em> type has changed: the function now</p>
<ul>
<li>Accepts <code>p</code> a <em>reference</em> to an <code>i32</code> whose value is <code>n</code> as denoted by <code>@n</code></li>
<li>Returns an <code>i32</code> that is non-negative and larger than <code>n</code></li>
</ul>
<p>The <code>@</code> marks the <code>n</code> as a <em>refinement parameter</em> whose value
is automatically computed by flux during type checking.</p>
<p>So, for example, Flux can check the below code by automatically
determining that the refinement parameter at the call-site is <code>10</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn test_abs() {
    let z = 10;
    assert(0 &lt;= abs(&amp;z))
    assert(10 &lt;= abs(&amp;z))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="refinement-parameters"><a class="header" href="#refinement-parameters">Refinement Parameters</a></h3>
<p>As an aside, we have secretly been using <em>refinement parameters</em>
like <code>@n</code> all along. For example, Flux automatically <em>desugars</em> the signature <code>fn(n:i32{0 &lt;= n} -&gt; ...</code> that we wrote for <code>factorial</code> into</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn ({i32[@n] : 0 &lt;= n}) -&gt; i32{v:n &lt;= v}
<span class="boring">}</span></code></pre></pre>
<p>where <code>@n</code> is a refinement parameter that is <em>implicitly</em> determined
from the rust parameter <code>n:i32</code>. However, <em>explicit</em> parameters are
essential to <em>name</em> the value of what a reference points to.
In <code>abs</code> the <code>rust</code> parameter <code>p</code> names the reference but the
<code>@n</code> names the (input) <em>value</em> and lets us use it to provide
more information about the output of <code>abs</code>.</p>
<p>Flux is <em>modular</em> in that the <em>only</em> information it
knows about the implementation of <code>abs</code> is the signature: for example
if we remove the fact that the output exceeds <code>n</code> then Flux will
reject the assertion <code>10 &lt;= abs(&amp;z)</code>.</p>
<img src="blog/../img/test_abs.gif" width="100%">
<h2 id="borrowing-mutable-references"><a class="header" href="#borrowing-mutable-references">Borrowing: Mutable References</a></h2>
<p>References of type <code>&amp;mut T</code> denote <em>mutable</em> references that can be
used to (read and) write or update the contents of a <code>T</code> value.
Crucially, Rust ensures that while there may be multiple read-only (shared)
references to a location, there is at most one <em>active</em> writeable (mutable)
reference at any point in time.</p>
<p>Flux exploits the semantics of <code>&amp;mut T</code> to treat <code>T</code> as an <em>invariant</em>
of the underlying data. As an example, consider the following function
that <em>decrements</em> the value of a mutable reference while ensuring the
data is non-negative:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux_rs::sig(fn(p: &amp;mut i32{v:0 &lt;= v}))]
pub fn decr(p: &amp;mut i32) {
    *p = *p - 1;
}
<span class="boring">}</span></code></pre></pre>
<p>Flux will complain with the following message</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[FLUX]: assignment might be unsafe
  --&gt; src/basics.rs:13:9
   |
13 |         *p = *p - 1;
   |         ^^^^^^^^^^^
<span class="boring">}</span></code></pre></pre>
<p>as in fact, we <em>may</em> be writing a negative value into <code>*p</code>
if, for example, the old value was zero. We can fix this
code by guarding the update with a test that ensures the
original contents are in fact <em>non-zero</em></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux_rs::sig(fn(p: &amp;mut i32{v:0 &lt;= v}))]
pub fn decr(p: &amp;mut i32) {
    let n = *p;
    if n != 0 {
        *p = n - 1;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>at which point Flux is happy to sign off on the code.</p>
<img src="blog/../img/decr.gif" width="100%">
<h2 id="aliased-references"><a class="header" href="#aliased-references">Aliased References</a></h2>
<p>Flux uses Rust's borrowing rules to track invariants even when
there may be aliasing. As an example, consider the function</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux_rs::sig(fn (bool) -&gt; i32{v:0 &lt;= v})]
fn test_alias(z: bool) -&gt; i32 {
    let mut x = 1;  // x: i32[1]
    let mut y = 2;  // y: i32[2]
    let r = if z { &amp;mut x } else { &amp;mut y };
                    // r: &amp;mut i32{v:0 &lt;= v}
    decr(r);
    *r
}
<span class="boring">}</span></code></pre></pre>
<p>The reference <code>r</code> could point to <em>either</em> <code>x</code> or <code>y</code> depending
on the (unknown) value of the boolean <code>z</code>. Nevertheless, Flux
determines that <em>both</em> references <code>&amp;mut x</code> and <code>&amp;mut y</code> point
to values of the more general type <code>i32{v:0&lt;=v}</code> and hence,
infers <code>r : &amp;mut i32{v:0&lt;=v}</code> which allows us it to then call
<code>decr</code> with the reference and guarantee the result (after <code>decr</code>)
is still non-negative.</p>
<h2 id="borrowing-strong-references"><a class="header" href="#borrowing-strong-references">Borrowing: Strong References</a></h2>
<p>In many situations, we want to lend a value to another function
that actually <em>changes</em> the value's (refinement) type upon exit.
For example, consider the following function to increment a reference
to a non-negative <code>i32</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux_rs::sig(fn (p: &amp;mut i32{v:0 &lt;= v}))]
fn incr(p: &amp;mut i32) {
  *p += 1
}
<span class="boring">}</span></code></pre></pre>
<p>Recall that Flux is <em>modular</em> in that the <em>only</em> information it
has about <code>incr</code> is what is said in the signature. The signature
for <code>incr</code> only says <code>p</code> remains non-negative: Flux does <em>not</em>
know that <code>incr</code> actually <em>increments</em> the value of <code>p</code>.</p>
<p>Hence, Flux fusses that the following <code>assert</code> may fail even though
its patently obvious that it will succeed!</p>
<img src="blog/../img/test_incr.gif" width="100%">
<p>To verify <code>test_incr</code> we need a signature for <code>incr</code> that says
that its <em>output</em> is indeed one greater<sup class="footnote-reference" id="fr-2-1"><a href="#footnote-2">2</a></sup> than its input.
Flux extends Rust with the notion of <strong>strong references</strong>
of the form <code>&amp;strg T</code> which refine Rust's <code>&amp;mut T</code> to grant
<em>exclusive</em> access to the underlying <code>T</code>. Crucially, strong
references also let us specify how the type is <em>updated</em> when
the function exits<sup class="footnote-reference" id="fr-3-1"><a href="#footnote-3">3</a></sup>. Thus, we can use strong references to
type <code>incr</code> as</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux_rs::sig(fn(p: &amp;strg i32[@n]) ensures p:i32[n+1])]
fn incr(p: &amp;mut i32) {
  *p += 1
}
<span class="boring">}</span></code></pre></pre>
<p>The Flux signature refines the plain Rust one to specify that</p>
<ol>
<li><code>p</code> is a strong reference to an <code>i32</code>,</li>
<li>the <em>input type</em> of <code>*p</code> is <code>i32[n]</code>, and</li>
<li>the <em>output type</em> of <code>*p</code> is <code>i32[n+1]</code>.</li>
</ol>
<p>With this specification, Flux merrily checks <code>test_incr</code>, by
determining that the refinement parameter <code>@n</code> is <code>10</code> and
hence, that upon return <code>x: i32[11]</code>.</p>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>To sum up, Flux exploits Rust's ownership mechanisms to track properties
of <em>shared</em> (<code>&amp;T</code>) and <em>mutable</em> (<code>&amp;mut T</code>) references, and additionally
adds a <em>strong</em> (<code>&amp;strg T</code>) reference -- a special case of <code>&amp;mut</code> -- to
support the cases where the type itself is <em>changed</em> by a call.</p>
<p>Next, we'll see how refinements and ownership yield a simple refined API
for <em>vectors</em> that lets Flux check bounds safety at compile time...</p>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<p>For those familiar with the term, these types are <em>loop invariants</em> <a href="#fr-1-1">↩</a></p>
</li>
<li id="footnote-2">
<p>Setting aside the issue of overflows for now <a href="#fr-2-1">↩</a></p>
</li>
<li id="footnote-3">
<p>Thereby allowing so-called <em>strong updates</em> in the type specifications <a href="#fr-3-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="refined-vectors"><a class="header" href="#refined-vectors">Refined Vectors</a></h1>
<p><a href="https://flux.goto.ucsd.edu/index.html#?demo=vectors.rs">Online demo</a></p>
<p>While <code>rustc</code> has a keen eye for spotting nasty bugs at
compile time, it is not omniscient. We've all groaned in
dismay at seeing deployed code crash with messages like</p>
<pre><code>panicked at 'index out of bounds: the len is ... but the index is ...'
</code></pre>
<p>Next, lets see how flux's <a href="https://liquid-rust.github.io/2022/11/14/introducing-flux/">refinement</a> and <a href="https://liquid-rust.github.io/2022/11/16/ownership-in-flux/">ownership</a>
mechanisms let us write a <em>refined vector</em> API whose types track vector sizes
and ensure --- at compile time --- that vector accesses <em>cannot</em> fail at runtime.</p>
<h2 id="refining-vectors-to-track-their-size"><a class="header" href="#refining-vectors-to-track-their-size">Refining Vectors to Track their Size</a></h2>
<p>To begin with, we will defined a <em>refined</em> vector type which is simply a wrapper
around the standard <code>Vec</code> type</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux_rs::refined_by(len: int)]
pub struct RVec&lt;T&gt; {
    inner: Vec&lt;T&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>#[flux_rs::refined_by(len: int)]</code> attribute tells flux that the type <code>RVec&lt;T&gt;</code> struct
is indexed by a <code>len</code> refinement which tracks the <em>size</em> of the underlying vector, just
like the indices for <code>i32</code> and <code>bool</code> tracked the actual <em>value</em> of the underlying
<a href="https://liquid-rust.github.io/2022/11/14/introducing-flux/">integer or boolean</a>). The idea is that the type</p>
<ul>
<li><code>RVec&lt;i32&gt;[10]</code> represents a vector of <code>i32</code> size 10, and</li>
<li><code>RVec&lt;bool&gt;{v:0 &lt; v}</code> represents a <em>non-empty</em> vector of <code>bool</code>, and</li>
<li><code>RVec&lt;RVec&lt;f32&gt;[n]&gt;[m]</code> represents a vector of vectors of <code>f32</code> of size <code>m</code> and
<em>each of</em> whose elements is a vector of size <code>n</code>.</li>
</ul>
<h3 id="creating-vectors"><a class="header" href="#creating-vectors">Creating Vectors</a></h3>
<p>Now that we can talk about the size of a vector, lets build up an API for creating and
manipulating vectors. I suppose one must start with nothing: an empty vector.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; RVec&lt;T&gt; {
    #[flux_rs::trusted]
    #[flux_rs::sig(fn() -&gt; RVec&lt;T&gt;[0])]
    pub fn new() -&gt; Self {
        Self { inner: Vec::new() }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The above implements <code>RVec::new</code> as a wrapper around <code>Vec::new</code>.
The <code>#[flux_rs::trusted]</code> attribute tells Flux there is nothing to
"check" here, as we are <em>defining</em> the API itself and trusting
that the implementation (using <code>vec</code> is correct).
However, the signature says that <em>callers</em> of the <code>RVec::new</code> get
back a vector indexed with <code>0</code> i.e. an empty vector.</p>
<h3 id="pushing-values"><a class="header" href="#pushing-values">Pushing Values</a></h3>
<p>An empty vector is a rather desolate thing.</p>
<p>To be of any use, we need to be able to <code>push</code> values into the container, like so</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux_rs::trusted]
#[flux_rs::sig(fn(self: &amp;strg RVec&lt;T&gt;[@n], T)
            ensures self: RVec&lt;T&gt;[n+1])]
pub fn push(&amp;mut self, item: T) {
    self.inner.push(item);
}
<span class="boring">}</span></code></pre></pre>
<p>The refined type for <code>push</code> says that it takes a <em>strong</em> reference (<code>self</code>)
--- where <code>strg</code> means the refined type may be <a href="blog/blog-owners">changed by the function</a> ---
to an <code>RVec&lt;T&gt;</code> of size <code>n</code> and a value <code>T</code> and upon exit, the size of <code>self</code>
is increased by <code>1</code>.</p>
<h3 id="popping-values"><a class="header" href="#popping-values">Popping Values</a></h3>
<p>Not much point stuffing things into a vector if we can't get them out again.</p>
<p>For that, we might implement a <code>pop</code> method that returns the last element
of the vector. Aha, but what if the vector is empty? You could return an
<code>Option&lt;T&gt;</code> <em>or</em> since we're tracking sizes, we could <em>require</em> that <code>pop</code>
only be called with non-empty vectors.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux_rs::trusted]
#[flux_rs::sig(fn(self: &amp;strg {RVec&lt;T&gt;[@n] | 0 &lt; n}) -&gt; T
            ensures self: RVec&lt;T&gt;[n-1])]
pub fn pop(&amp;mut self) -&gt; T {
  self.inner.pop().unwrap()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="using-the-api"><a class="header" href="#using-the-api">Using the API</a></h3>
<p>Now already <code>flux</code> can start checking some code, for example if you <code>push</code> two
elements, then you can <code>pop</code> twice, but flux will reject the third <code>pop</code> at
compile-time</p>
<img src="blog/../img/push_pop.gif" width="100%">
<p>In fact, the error message from <code>flux</code> will point to exact condition that
does not hold</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[FLUX]: precondition might not hold
  --&gt; src/vectors.rs:24:5
   |
24 |     v.pop();
   |     ^^^^^^^ call site
   |
   = note: a precondition cannot be proved at this call site
note: this is the condition that cannot be proved
  --&gt; src/rvec.rs:78:47
   |
78 |     #[flux_rs::sig(fn(self: &amp;strg {RVec&lt;T&gt;[@n] | 0 &lt; n}) -&gt; T
   |                                               ^^^^^
<span class="boring">}</span></code></pre></pre>
<!--
We can use `push` to implement an `rvec!` macro for constructing vectors
and then test that lengths are tracked correctly

<img src="blog/../img/test_macro_pop.gif" width="100%"> -->
<h3 id="querying-the-size"><a class="header" href="#querying-the-size">Querying the Size</a></h3>
<p>Perhaps we should <em>peek</em> at the size of the vector to make sure its not empty <em>before</em>
we <code>pop</code> it. We can do that with a <code>len</code> method whose type says that the returned <code>usize</code>
is, in fact, the size of the input vector</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux_rs::trusted]
#[flux_rs::sig(fn(&amp;RVec&lt;T&gt;[@n]) -&gt; usize[n])]
pub fn len(&amp;self) -&gt; usize {
    self.inner.len()
}
<span class="boring">}</span></code></pre></pre>
<p>Now, flux "knows" that after two <code>push</code>es, the size of the vector is <code>2</code> and after
the two <code>pop</code>s, the size is <code>0</code> again</p>
<img src="blog/../img/push_pop_len.gif" width="100%">
<h3 id="random-access"><a class="header" href="#random-access">Random Access</a></h3>
<p>Of course, vectors are not just <em>stacks</em>, they also allow
<em>random</em> access to their elements which is where those
pesky panics occur, and where the refined vector API
gets rather useful. Since we're tracking sizes, we can
<em>require</em> that the method to <code>get</code> an element only be
called with a <em>valid index</em> that is between <code>0</code> and the
vector's size</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux_rs::sig(fn(&amp;RVec&lt;T&gt;[@n], i: usize{i &lt; n}) -&gt; &amp;T)]
pub fn get(&amp;self, i: usize) -&gt; &amp;T {
    &amp;self.inner[i]
}

#[flux_rs::sig(fn(&amp;mut RVec&lt;T&gt;[@n], i: usize{i &lt; n}) -&gt; &amp;mut T)]
pub fn get_mut(&amp;mut self, i: usize) -&gt; &amp;mut T {
    &amp;mut self.inner[i]
}
<span class="boring">}</span></code></pre></pre>
<p>With these refined <code>get</code> methods, flux can now spot the
``off-by-one'' error in the following code and accepts
the fix <sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup></p>
<img src="blog/../img/vec_sum.gif" width="100%">
<p>Its a bit gross to use <code>get</code> and <code>get_mut</code> directly, so instead we implement
the <code>Index</code> and <code>IndexMut</code> traits for <code>RVec</code> which allows us to use the
<code>[]</code> operator to access elements</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; std::ops::Index&lt;usize&gt; for RVec&lt;T&gt; {
    type Output = T;
    #[flux_rs::sig(fn(&amp;RVec&lt;T&gt;[@n], i:usize{i &lt; n}) -&gt; &amp;T)]
    fn index(&amp;self, index: usize) -&gt; &amp;T {
        self.get(index)
    }
}

impl&lt;T&gt; std::ops::IndexMut&lt;usize&gt; for RVec&lt;T&gt; {
    #[flux_rs::sig(fn(&amp;mut RVec&lt;T&gt;[@n], i:usize{i &lt; n}) -&gt; &amp;mut T)]
    fn index_mut(&amp;mut self, index: usize) -&gt; &amp;mut T {
        self.get_mut(index)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>And now the above <code>vec_sum</code> example looks a little nicer</p>
<img src="blog/../img/vec_sum_index.gif" width="100%">
<h2 id="memoization"><a class="header" href="#memoization">Memoization</a></h2>
<p>Lets put the whole API to work in this "memoized" version of the fibonacci
function which uses a vector to store the results of previous calls</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn fib(n: usize) -&gt; i32 {
    let mut r = RVec::new();
    let mut i = 0;
    while i &lt; n {
        if i == 0 {
            r.push(0);
        } else if i == 1 {
            r.push(1);
        } else {
            let a = r[i - 1];
            let b = r[i - 2];
            r.push(a + b);
        }
        i += 1;
    }
    r.pop()
}
<span class="boring">}</span></code></pre></pre>
<p>Oops, flux is not happy with the call to <code>pop</code> at the end of the function
which returns the <em>last</em> value as the result.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[FLUX]: precondition might not hold
  --&gt; src/vectors.rs:40:5
   |
40 |     r.pop()
   |     ^^^^^^^
<span class="boring">}</span></code></pre></pre>
<p>Flux complains that the vector may be <em>empty</em> and so the <code>pop</code> call may
fail ... but why? Can you spot the problem?</p>
<p>Indeed, we missed a "corner" case -- when <code>n</code> is <code>0</code> we skip the loop and
so the vector is empty! Once we add a test for that, flux is happy.</p>
<img src="blog/../img/fib.gif" width="100%">
<h2 id="binary-search"><a class="header" href="#binary-search">Binary Search</a></h2>
<p>As a last example, lets look at a simplified version of the
<a href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#2423-2425"><code>binary_search</code> method from <code>std::vec</code></a>, into which I've snuck a tiny little bug</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn binary_search(vec: &amp;RVec&lt;i32&gt;, x: i32) -&gt; Result&lt;usize, usize&gt; {
    let mut size = vec.len();
    let mut left = 0;
    let mut right = size;
    while left &lt;= right {
        let mid = left + size / 2;
        let val = vec[mid];
        if val &lt; x {
            left = mid + 1;
        } else if x &lt; val {
            right = mid;
        } else {
            return Ok(mid);
        }
        size = right - left;
    }
    Err(left)
}
<span class="boring">}</span></code></pre></pre>
<p>Flux complains in <em>two</em> places</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[FLUX]: precondition might not hold
   --&gt; src/vectors.rs:152:19
    |
152 |         let val = vec[mid];
    |                   ^^^^^^^^ call site
    |
    = note: a precondition cannot be proved at this call site
note: this is the condition that cannot be proved
   --&gt; src/rvec.rs:189:44
    |
189 |     #[flux_rs::sig(fn(&amp;RVec&lt;T&gt;[@n], usize{v : v &lt; n}) -&gt; &amp;T)]
    |                                            ^^^^^

error[FLUX]: arithmetic operation may overflow
   --&gt; src/vectors.rs:160:9
    |
160 |         size = right - left;
    |         ^^^^^^^^^^^^^^^^^^^
<span class="boring">}</span></code></pre></pre>
<ul>
<li>
<p>The vector access may be <em>unsafe</em> as <code>mid</code> could be out of bounds!</p>
</li>
<li>
<p>The <code>size</code> variable may <em>underflow</em> as <code>left</code> may exceed <code>right</code>!</p>
</li>
</ul>
<p>Can you the spot off-by-one and figure out a fix?</p>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<p>So, we saw how Flux's index and constraint mechanisms combine
with Rust's ownership to let us write a <em>refined vector API</em>
that ensures the safety of all accesses at compile time.</p>
<p>Next time, we'll see how these mechanisms are <em>compositional</em>
in that we can use standard type machinery to build up
compound structures and APIs from simple ones.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<p>Why not use an iterator? We'll get there in due course! <a href="#fr-1-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="arrays-and-const-generics"><a class="header" href="#arrays-and-const-generics">Arrays and Const Generics</a></h1>
<p><a href="https://flux.goto.ucsd.edu/index.html#?demo=arrays.rs">Online demo</a></p>
<p>Rust has a built-in notion of <em>arrays</em> : collections of objects of
the same type <code>T</code> whose size is known at compile time. The fact that
the sizes are known allows them to be allocated contiguously in memory,
which makes for fast access and manipulation.</p>
<p>When I asked ChatGPT what arrays were useful for, it replied
with several nice examples, including low-level systems programming (e.g.
packets of data represented as <code>struct</code>s with array-valued fields), storing configuration data, or small sets of related values (e.g. RGB values for a pixel).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Pixel = [u8; 3]; // RGB values

let pix0: Pixel = [255,   0, 127];
let pix1: Pixel = [  0, 255, 127];
<span class="boring">}</span></code></pre></pre>
<h2 id="compile-time-safety"><a class="header" href="#compile-time-safety">Compile-time Safety...</a></h2>
<p>As the size of the array is known at compile time, Rust can make sure that
we don't <em>create</em> arrays of the wrong size, or <em>access</em> them out of bounds.</p>
<p>For example, <code>rustc</code> will grumble if you try to make a <code>Pixel</code> with 4 elements:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   |
52 | let pix2 : Pixel = [0,0,0,0];
   |            -----   ^^^^^^^^^ expected an array with a fixed size of 3 elements, found one with 4 elements
   |            |
   |            expected due to this
<span class="boring">}</span></code></pre></pre>
<p>Similarly, <code>rustc</code> will wag a finger if you try to access a <code>Pixel</code> at an invalid index.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   |
54 |  let blue0 = pix0[3];
   |              ^^^^^^^ index out of bounds: the length is 3 but the index is 3
   |
<span class="boring">}</span></code></pre></pre>
<h2 id="-run-time-panic"><a class="header" href="#-run-time-panic">... Run-time Panic!</a></h2>
<p>However, the plain type system works only upto a point. For example, consider the
following function to compute the average <code>color</code> value of a collection of <code>&amp;[Pixel]</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn average_color(pixels: &amp;[Pixel], i: usize) -&gt; u64 {
    let mut sum = 0;
    for p in pixels {
        sum += p[i] as u64;
    }
    sum / pixels.len() as u64
}
<span class="boring">}</span></code></pre></pre>
<p>Now, <code>rustc</code> will not complain about the above code, even though it may panic if
<code>color</code> is out of bounds (or of course, if the slice <code>pixels</code> is empty!).
For example, the following code</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let pixels = [ [255, 0, 0], [0, 255, 0], [0, 0, 255] ];
    let avg = average(&amp;pixels, 3);
    println!("Average: {}", avg);
}</code></pre></pre>
<p>panics at runtime:</p>
<pre><code>thread 'main' panicked ... index out of bounds: the len is 3 but the index is 3
</code></pre>
<h2 id="refined-compile-time-safety"><a class="header" href="#refined-compile-time-safety">Refined Compile-time Safety</a></h2>
<p>Fortunately, <code>flux</code> knows about the sizes of arrays and slices. At compile time,
<code>flux</code> warns about two possible errors in <code>average_color</code></p>
<img src="blog/../img/04-arrays-average-error.png" width="100%">
<ol>
<li>The index <code>i</code> may be out of bounds when accessing <code>p[i]</code> and</li>
<li>The division can panic as <code>pixels</code> may be empty (i.e. have length <code>0</code>).</li>
</ol>
<p>We can fix these errors by requiring that the input</p>
<ul>
<li><code>i</code> be a valid color index, i.e. <code>i &lt; 3</code> and</li>
<li><code>pixels</code> be non-empty, i.e. have size <code>n</code> where <code>n &gt; 0</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[sig(fn(pixels: &amp;[Pixel][@n], i:usize{i &lt; 3}) -&gt; u64 requires n &gt; 0)]
<span class="boring">}</span></code></pre></pre>
<img src="blog/../img/04-arrays-average-fix.gif" width="100%">
<h2 id="const-generics-1"><a class="header" href="#const-generics-1">Const Generics</a></h2>
<p>Rust also lets us write arrays that are <em>generic</em> over the size. For example,
suppose we want to take two input arrays <code>x</code> and <code>y</code> of the same size <code>N</code> and
compute their dot product. We can write</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn dot&lt;const N:usize&gt;(x: [f32;N], y: [f32;N]) -&gt; f32 {
    let mut sum = 0.0;
    for i in 0..N {
        sum += x[i] * y[i];
    }
    sum
}
<span class="boring">}</span></code></pre></pre>
<p>This is very convenient because <code>rustc</code> will prevent us from calling <code>dot</code> with
arrays of different sizes, for example we get a compile-time error</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   |
68 |     dot([1.0, 2.0], [3.0, 4.0, 5.0]);
   |     ---             ^^^^^^^^^^^^^^^ expected an array with a fixed size of 2 elements, found one with 3 elements
   |     |
   |     arguments to this function are incorrect
   |
<span class="boring">}</span></code></pre></pre>
<p>However, suppose we wanted to compute the <code>dot</code> product of just the first <code>k</code> elements</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn dot_k&lt;const N:usize&gt;(x: [f32;N], y: [f32;N], k: usize) -&gt; f32 {
    let mut sum = 0.0;
    for i in 0..k {
        sum += x[i] * y[i];
    }
    sum
}
<span class="boring">}</span></code></pre></pre>
<p>Now, unfortunately, <code>rustc</code> will not prevent us from calling <code>dot_k</code> with <code>k</code> set to a value that is too large!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>thread 'main' panicked at ... index out of bounds: the len is 2 but the index is 2
<span class="boring">}</span></code></pre></pre>
<p>Yikes.</p>
<h2 id="refined-const-generics"><a class="header" href="#refined-const-generics">Refined Const Generics</a></h2>
<p>Fortunately, <code>flux</code> understands const-generics as well!</p>
<p>First off, it warns us about the fact that the accesses with the index may be out of bounds.</p>
<img src="blog/../img/04-arrays-dotk-error.png" width="100%">
<p>We can fix it in two ways.</p>
<ul>
<li>The <strong>permissive</strong> approach is to accept any <code>k</code> but restrict the iteration to the valid elements</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn dot_k&lt;const N:usize&gt;(x: [f32;N], y: [f32;N], k: usize) -&gt; f32 {
    let mut sum = 0.0;
    let n = if k &lt; N { k } else { N };
    for i in 0..n {
        sum += x[i] * y[i];
    }
    sum
}
<span class="boring">}</span></code></pre></pre>
<img src="blog/../img/04-arrays-dotk-permissive.gif" width="100%">
<ul>
<li>The <strong>strict</strong> approach is to require that <code>k</code> be less than or equal to <code>N</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[sig(fn(x: [f32;N], y: [f32;N], k:usize{k &lt;= N}) -&gt; f32)]
fn dot_k&lt;const N:usize&gt;(x: [f32;N], y: [f32;N], k: usize) -&gt; f32 {
    let mut sum = 0.0;
    for i in 0..k {
        sum += x[i] * y[i];
    }
    sum
}
<span class="boring">}</span></code></pre></pre>
<img src="blog/../img/04-arrays-dotk-strict.gif" width="100%">
<p>Do you understand why</p>
<p>(1) Adding the type signature moved the error from the body of <code>dot_k</code> into the call-site inside <code>test</code>?
(2) Then editing <code>test</code> to call <code>dot_k</code> with <code>k=2</code> fixed the error?</p>
<h2 id="summary-3"><a class="header" href="#summary-3">Summary</a></h2>
<p>Rust's (sized) arrays are great, and <code>flux</code>'s refinements make them even better,
by ensuring indices are guaranteed to be within the arrays bounds. Const generics
let us write functions that are polymorphic over array sizes, and again, refinements
let us precisely track those sizes to prevent out-of-bounds errors!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="about-flux"><a class="header" href="#about-flux">About Flux</a></h1>
<img src="img/logo-wide.svg" class="flux-logo" alt="Flux Logo">
<h2 id="team"><a class="header" href="#team">Team</a></h2>
<p>Flux is being developed by</p>
<ul>
<li><a href="https://github.com/nilehmann">Nico Lehmann</a>,</li>
<li><a href="https://www.cs.ubc.ca/~atgeller/">Adam Geller</a></li>
<li><a href="https://www.cole-k.com/">Cole Kurashige</a></li>
<li><a href="https://gbarthe.github.io/">Gilles Barthe</a></li>
<li><a href="https://nikivazou.github.io/">Niki Vazou</a></li>
<li><a href="https://cseweb.ucsd.edu/~rjhala">Ranjit Jhala</a></li>
</ul>
<h2 id="code"><a class="header" href="#code">Code</a></h2>
<p>Flux is open-source and available <a href="http://github.com/liquid-rust/flux">here</a></p>
<h2 id="publications"><a class="header" href="#publications">Publications</a></h2>
<ul>
<li><a href="https://dl.acm.org/doi/pdf/10.1145/3591283">Lehmann, Nico, Adam T. Geller, Niki Vazou, and Ranjit Jhala. "Flux: Liquid types for rust."  PLDI (2023)</a></li>
<li><a href="https://dl.acm.org/doi/pdf/10.1145/3704885">Lehmann, Nico, Cole Kurashige, Nikhil Akiti, Niroop Krishnakumar, and Ranjit Jhala. "Generic Refinement Types." POPL (2025)</a></li>
</ul>
<h2 id="talks"><a class="header" href="#talks">Talks</a></h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=3iYt2JTXCwM">PLDI'23</a></li>
<li><a href="https://www.youtube.com/watch?v=NIJtZ0yUDX0">SOAP'23</a></li>
</ul>
<h2 id="thanks"><a class="header" href="#thanks">Thanks</a></h2>
<p>This work was supported by the National Science Foundation, European Research Council,
and by generous gifts from Microsoft Research.</p>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<p>This is a prototype! Use at your own risk. Everything could break and it will break.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="js/flux.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
