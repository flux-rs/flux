<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Flux Documentation</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Guide</li><li class="chapter-item expanded "><a href="guide/install.html"><strong aria-hidden="true">1.</strong> Install</a></li><li class="chapter-item expanded "><a href="guide/run.html"><strong aria-hidden="true">2.</strong> Run</a></li><li class="chapter-item expanded "><a href="guide/develop.html"><strong aria-hidden="true">3.</strong> Develop</a></li><li class="chapter-item expanded affix "><li class="part-title">Examples</li><li class="chapter-item expanded "><a href="blog/01-introducing-flux.html"><strong aria-hidden="true">4.</strong> Introducing Flux</a></li><li class="chapter-item expanded "><a href="blog/02-ownership.html"><strong aria-hidden="true">5.</strong> Ownership in Flux</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Refined Vectors</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Iterators</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Structs</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Enums</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="about.html">About</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Flux Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><img src="img/flux-logo.png" alt="Flux" /></p>
<p>Flux is a <strong>refinement type checker</strong> for Rust that lets you <em>specify</em>
a range of correctness properties and have them be <em>verified</em> at compile
time.</p>
<p>See <a href="SUMMARY.html#examples">these examples</a> to learn about Refinement types and Rust.</p>
<p>You can try it online <a href="https://flux.programming.systems">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing-flux"><a class="header" href="#installing-flux">Installing Flux</a></h1>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<ul>
<li><a href="https://rustup.rs/">rustup</a></li>
<li><a href="https://github.com/ucsd-progsys/liquid-fixpoint">liquid-fixpoint</a></li>
<li><a href="https://github.com/Z3Prover/z3">z3</a></li>
</ul>
<p>Be sure that the <code>liquid-fixpoint</code> and <code>z3</code> executables are in your $PATH.</p>
<h2 id="installing"><a class="header" href="#installing">Installing</a></h2>
<p>The only way to use <code>flux</code> is to build it from source.</p>
<p>First you need to clone the repository</p>
<pre><code class="language-bash">git clone https://github.com/liquid-rust/flux
cd flux
</code></pre>
<p>To build the source you need a nightly version of rustc.
We pin the version using a <a href="guide//rust-toolchain">toolchain file</a> (more info <a href="https://rust-lang.github.io/rustup/overrides.html#the-toolchain-file">here</a>).
If you are using rustup, no special action is needed as it should install the correct rustc version and components based on the information on that file.</p>
<p>Next, run the following to build and install <code>flux</code> binaries</p>
<pre><code class="language-bash">cargo install --path flux
cargo install --path flux-bin
</code></pre>
<p>This will install <code>flux-driver</code>, <code>rustc-flux</code> and <code>cargo-flux</code>. Note that you should not call <code>flux-driver</code> directly, but rather use <code>rustc-flux</code> and <code>cargo-flux</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-flux"><a class="header" href="#running-flux">Running Flux</a></h1>
<p>You can run <code>flux</code> on a single file or entire crate.</p>
<h2 id="running-on-a-file-rustc-flux"><a class="header" href="#running-on-a-file-rustc-flux">Running on a File: <code>rustc-flux</code></a></h2>
<p>You can use <code>rustc-flux</code> as you would use <code>rustc</code>.
For example, the following command checks the file <code>test.rs</code>.</p>
<pre><code class="language-bash">rustc-flux path/to/test.rs
</code></pre>
<p>The flux binary accepts the same flags as rustc.
You could for example check a file as a library instead of a binary like so</p>
<pre><code class="language-bash">rustc-flux --crate-type=lib path/to/test.rs
</code></pre>
<p>Additionally, at the moment flux passes some default flags (like <code>-O</code> and
<code>-Cpanic=abort</code>) because otherwise the resulting mir will have features not yet
supported.</p>
<h2 id="running-on-a-crate-cargo-flux"><a class="header" href="#running-on-a-crate-cargo-flux">Running on a Crate: <code>cargo-flux</code></a></h2>
<p>You can use <code>cargo-flux</code> as you would use <code>cargo</code>. For the most part this means
instead of running <code>cargo check</code>, you should run</p>
<pre><code class="language-bash">cargo-flux check
</code></pre>
<p>in order to get <code>flux</code> to check your code.</p>
<h2 id="developing-locally"><a class="header" href="#developing-locally">Developing locally</a></h2>
<p>You can set the <code>FLUX_DRIVER_PATH</code> environment variable to <code>./target/debug/flux</code> if you
want <code>cargo-flux</code> and <code>rustc-flux</code> to use the version of <code>flux-driver</code> that is built
when you run <code>cargo build</code>. This is useful if you want to run <code>cargo build</code> instead
of <code>cargo install --path flux</code> every time you make a change.</p>
<h2 id="a-tiny-example"><a class="header" href="#a-tiny-example">A tiny example</a></h2>
<p>The following example declares a function <code>inc</code>
that returns an integer greater than the input.
We use the nightly feature <code>register_tool</code>
to register the <code>flux</code> tool in order to
add refinement annotations to functions.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(register_tool)]
#![register_tool(flux)]

<span class="boring">fn main() {
</span>#[flux::sig(fn(x: i32) -&gt; i32{v: x &lt; v})]
pub fn inc(x: i32) -&gt; i32 {
    x - 1
}
<span class="boring">}</span></code></pre></pre>
<p>You can save the above snippet in say <code>test0.rs</code> and then run</p>
<pre><code class="language-bash">rustc-flux --crate-type=lib path/to/test0.rs
</code></pre>
<p>you should see in your output</p>
<pre><code class="language-text">error[FLUX]: postcondition might not hold
 --&gt; test0.rs:6:5
  |
6 |     x - 1
  |     ^^^^^
</code></pre>
<p>as indeed <code>x - 1</code> is <em>not</em> greater than <code>x</code> as required by the output refinement <code>i32{v: x &lt; v}</code>.</p>
<p>If you fix the error by replacing <code>x - 1</code> with <code>x + 1</code>, you should get no errors
in the output (the output may be empty, but in this case no output is a good
thing).</p>
<p>Read <a href="guide/SUMMARY.html#learn">these chapters</a> to learn more about what you specify and verify with <code>flux</code>.</p>
<h2 id="a-note-about-the-flux-driver-binary"><a class="header" href="#a-note-about-the-flux-driver-binary">A note about the flux-driver binary</a></h2>
<p>The <code>flux-driver</code> binary is a <a href="https://rustc-dev-guide.rust-lang.org/rustc-driver.html?highlight=driver#the-rustc-driver-and-interface">rustc
driver</a>
(similar to how clippy works) meaning it uses rustc as a library to &quot;drive&quot;
compilation performing additional analysis along the way. Running the binary
requires dynamically linking a correct version of <code>librustc</code>. Thus, to avoid the
hassle you should never execute it directly.  Instead, use <code>rustc-flux</code> or <code>cargo-flux</code>.</p>
<h2 id="editor-support"><a class="header" href="#editor-support">Editor Support</a></h2>
<p>This section assumes you have installed <code>flux</code>, <code>cargo-flux</code>, and <code>rustc-flux</code>.</p>
<h3 id="rust-analyzer-in-vscode"><a class="header" href="#rust-analyzer-in-vscode">Rust-Analyzer in VSCode</a></h3>
<p>Add this to the workspace settings i.e. <code>.vscode/settings.json</code></p>
<pre><code class="language-json">{
  &quot;rust-analyzer.checkOnSave.overrideCommand&quot;: [
    &quot;cargo-flux&quot;,
    &quot;check&quot;,
    &quot;--workspace&quot;,
    &quot;--message-format=json&quot;
  ]
}
</code></pre>
<p>If you want to change the <code>flux</code> used by <code>cargo-flux</code>, then also specify the
<code>FLUX_PATH</code> like in the example below, which uses the version generated when you
run <code>cargo build</code>.</p>
<pre><code class="language-json">{
  &quot;rust-analyzer.checkOnSave.extraEnv&quot;: {
    &quot;FLUX_PATH&quot;: &quot;/path/to/flux-repo/target/debug/flux&quot;,
  }
}
</code></pre>
<p><strong>Note:</strong> Make sure to edit the paths in the above snippet to point to the correct locations on your machine.</p>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<h3 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h3>
<p>You can set various <code>env</code> variables to customize the behavior of <code>flux</code>.</p>
<ul>
<li><code>FLUX_CONFIG</code> tells <code>flux</code> where to find a config file for these settings.
<ul>
<li>By default, <code>flux</code> searches its directory for a <code>flux.toml</code> or <code>.flux.toml</code>.</li>
</ul>
</li>
<li><code>FLUX_DRIVER_PATH=path/to/flux-driver</code> tells <code>cargo-flux</code> and <code>rustc-flux</code> where to find the <code>flux</code> binary.
<ul>
<li>Defaults to the default <code>flux-driver</code> installation (typically found in <code>~/.cargo/bin</code>).</li>
</ul>
</li>
<li><code>FLUX_LOG_DIR=path/to/log/</code> with default <code>./log/</code></li>
<li><code>FLUX_DUMP_CONSTRAINT=1</code> sets the directory where constraints, timing and cache are saved.</li>
<li><code>FLUX_DUMP_CHECKER_TRACE=1</code> saves the checker's trace (useful for debugging!)</li>
<li><code>FLUX_DUMP_TIMINGS=1</code> saves the profile information</li>
<li><code>FLUX_DUMP_MIR=1</code> saves the low-level MIR for each analyzed function</li>
<li><code>FLUX_CHECK_ASSERTS={ignore, assume, check}</code> TODO</li>
<li><code>FLUX_POINTER_WIDTH=N</code> TODO (default <code>64</code>)</li>
<li><code>FLUX_CHECK_DEF=name</code> only checks definitions containing <code>name</code> as a substring</li>
<li><code>FLUX_CACHE=1&quot;</code> switches on query caching and saves the cache in <code>FLUX_CACHE_FILE</code></li>
<li><code>FLUX_CACHE_FILE=file.json</code> customizes the cache file, default <code>FLUX_LOG_DIR/cache.json</code></li>
</ul>
<h3 id="config-file"><a class="header" href="#config-file">Config file</a></h3>
<p>The config file is a <code>.toml</code> file that contains on each line the lowercase name
of a <code>flux</code> command line flag without the <code>FLUX_</code> prefix. Set environment
variables take priority over the config file.</p>
<p>The config file should be in the project root.</p>
<p>For example, suppose your project root contains the following <code>flux.toml</code>.</p>
<pre><code class="language-toml">log_dir = &quot;./test&quot;
dump_timings = true
dump_mir = true
</code></pre>
<p>and you run in the project root</p>
<pre><code class="language-bash">FLUX_DUMP_MIR=0 cargo-flux check
</code></pre>
<p>then <code>flux</code> will create the directory <code>./test/</code> and write <code>./test/timings</code>, a file
containing profiling information. It will <em>not</em> dump the MIR because that setting
was overridden by setting the environment variable <code>FLUX_DUMP_MIR=0</code>.</p>
<h3 id="query-caching"><a class="header" href="#query-caching">Query Caching</a></h3>
<p><code>FLUX_CACHE=1</code> persistently caches the safe fixpoint queries for each <code>DefId</code> in
<code>FLUX_LOG_DIR/FLUX_CACHE_FILE</code>, and on subsequent runs, skips queries that are
already in the cache, which considerably speeds up <code>cargo-flux check</code> on an
entire crate.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="developers-guide"><a class="header" href="#developers-guide">Developer's Guide</a></h1>
<h2 id="regression-tests"><a class="header" href="#regression-tests">Regression Tests</a></h2>
<p>You can run the various regression tests in the <code>tests/pos</code> and <code>tests/neg</code> directory using</p>
<pre><code>$ cargo test -p flux-tests
</code></pre>
<h2 id="profiling-flux"><a class="header" href="#profiling-flux">Profiling Flux</a></h2>
<p>Set <code>FLUX_DUMP_TIMINGS=true</code> to have flux write timing diagnostics to <code>./log/timings</code>.</p>
<p>Right now this is <em>extremely</em> simple, it just provides some details for the spans under <code>flux_typeck</code> and <code>flux_driver</code>.</p>
<h3 id="sample-output"><a class="header" href="#sample-output">Sample output</a></h3>
<p>Below is a sample output for an invocation of <code>cargo-flux check</code> that took 19 seconds. The missing 2 seconds approximately accounts for the time it takes for <code>cargo check</code> to run.</p>
<p>Note that <code>check_crate</code> contains everything running under <code>check_top</code>, which is why the sum of the spans is greater than 19 seconds.</p>
<pre><code>check_top
  Checker::infer
    num events:   205
    min non-zero: 0.52ms
    1st quartile: 0.52ms
    2nd quartile: 1.05ms
    3rd quartile: 2.62ms
    max:          24.12ms
    total time:   229.64ms
  Checker::check
    num events:   205
    min non-zero: 0.52ms
    1st quartile: 0.52ms
    2nd quartile: 1.05ms
    3rd quartile: 5.24ms
    max:          159.91ms
    total time:   2028.47ms
  FixpointCtx::check
    num events:   205
    min non-zero: 22.02ms
    1st quartile: 26.21ms
    2nd quartile: 28.31ms
    3rd quartile: 40.37ms
    max:          1867.51ms
    total time:   9106.36ms
total time: 11364.47ms

check_crate
  Callbacks::check_wf
    num events:   1
    min non-zero: 18.35ms
    1st quartile: 18.87ms
    2nd quartile: 18.87ms
    3rd quartile: 18.87ms
    max:          18.87ms
    total time:   18.87ms
  Callbacks::check_crate
    num events:   1
    min non-zero: 16986.93ms
    1st quartile: 16995.32ms
    2nd quartile: 16995.32ms
    3rd quartile: 16995.32ms
    max:          16995.32ms
    total time:   16995.32ms
total time: 17014.19ms
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introducing-flux"><a class="header" href="#introducing-flux">Introducing Flux</a></h1>
<p><a href="https://flux.programming.systems">Online demo</a></p>
<p>Types bring order to code. For example, if a variable <code>i:usize</code>
then we know <code>i</code> is a number that can be used to index a vector.
Similarly, if <code>v:vec&lt;&amp;str&gt;</code> then we can be sure that <code>v</code> is a
collection of strings which may <em>be</em> indexed but of course,
not used <em>as</em> an index. However, by itself <code>usize</code> doesn't
tell us how big or small the number and hence the programmer
must still rely on their own wits, a lot of tests, and a dash
of optimism, to ensure that all the different bits fit properly
at run-time.</p>
<p><a href="https://arxiv.org/abs/2010.07763">Refinements</a> are a promising new way to extend
type checkers with logical constraints that <em>specify</em> additional
correctness requirements that can be <em>verified</em> by the compiler,
thereby entirely eliminating various classes of run-time problems.</p>
<p>We're excited to introduce <a href="https://github.com/liquid-rust/flux/">Flux</a>, a refinement type
checker plugin that brings this technology to <code>Rust</code>.</p>
<!-- more -->
<h2 id="indexed-types"><a class="header" href="#indexed-types">Indexed Types</a></h2>
<p>The most basic form of refinement type in <code>flux</code> is a type that is
<em>indexed</em> by a logical value. For example</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left"><strong>Type</strong></th><th style="text-align: left"><strong>Meaning</strong></th></tr></thead><tbody>
<tr><td style="text-align: left"><code>i32[10]</code></td><td style="text-align: left">The (singleton) set of <code>i32</code> values equal to <code>10</code></td></tr>
<tr><td style="text-align: left"><code>bool[true]</code></td><td style="text-align: left">The (singleton) set of <code>bool</code> values equal to <code>true</code></td></tr>
</tbody></table>
</div>
<h3 id="post-conditions"><a class="header" href="#post-conditions">Post-Conditions</a></h3>
<p>We can already start using these indexed types to start writing (and checking)
code. For example we can write the following specification which says that
the value <em>returned</em> by <code>mk_ten</code> must in fact be <code>10</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn() -&gt; i32[10])]
pub fn mk_ten() -&gt; i32 {
    5 + 4
}
<span class="boring">}</span></code></pre></pre>
<p>but when you compile it, <code>flux</code> will say</p>
<pre><code class="language-bash">error[FLUX]: postcondition might not hold
 --&gt; src/basics.rs:7:5
  |
7 |     5 + 4
  |     ^^^^^
</code></pre>
<p>The error says that that the <em>postcondition might not hold</em> which means
that the <em>output</em> produced by <code>mk_ten</code> may not in fact be an <code>i32[10]</code>
as indeed, in this case, the result is <code>9</code>! You can eliminate the error
by replacing the body with <code>5 + 5</code> or just <code>10</code>.</p>
<img src="blog/../img/mk10.gif" width="100%">
<h3 id="pre-conditions"><a class="header" href="#pre-conditions">Pre-Conditions</a></h3>
<p>Here's a second example that shows how you can use an index to restrict
the space of <em>inputs</em> that a function expects.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn (b:bool[true]))]
pub fn assert(b:bool) {
  if !b { panic!(&quot;assertion failed&quot;) }
}
<span class="boring">}</span></code></pre></pre>
<p>Here, the refined specification for <code>assert</code> says that you can <em>only</em> call
it with <code>true</code> as the input. So if you write</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn test(){
  assert(2 + 2 == 4);
  assert(2 + 2 == 5); // fails to type check
}
<span class="boring">}</span></code></pre></pre>
<p>then <code>flux</code> will complain that</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[FLUX]: precondition might not hold
  --&gt; src/basics.rs:12:5
   |
12 |     assert(2 + 2 == 5); // fails to type check
   |     ^^^^^^^^^^^^^^^^^^
<span class="boring">}</span></code></pre></pre>
<p>meaning that the call to <code>assert</code> fails to establish that
the input is indeed <code>true</code> (as of course, in this case, it is not!)</p>
<img src="blog/../img/assert.gif" width="100%">
<h2 id="index-parameters-and-expressions"><a class="header" href="#index-parameters-and-expressions">Index Parameters and Expressions</a></h2>
<p>Its not terribly exciting to only talk about <em>fixed</em> values
like <code>10</code> or <code>true</code>. To be more useful, <code>flux</code> lets you index
types by refinement <em>parameters</em>. For example you can write</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn(n:i32) -&gt; bool[0 &lt; n])]
pub fn is_pos(n: i32) -&gt; bool {
    if 0 &lt; n {
        true
    } else {
        false
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Here, the type says that <code>is_pos</code></p>
<ul>
<li>takes as <em>input</em> some <code>i32</code> <em>indexed by</em> <code>n</code></li>
<li>returns as <em>output</em> the <code>bool</code> <em>indexed by</em> <code>0 &lt; n</code></li>
</ul>
<p>in other words, the output is <code>true</code> <em>exactly when</em> <code>0 &lt; n</code>.</p>
<p>We might use this function to check that:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn test_pos(n: i32) {
  let m = if is_pos(n) { n - 1 } else { 0 };
  assert(0 &lt;= m);
}
<span class="boring">}</span></code></pre></pre>
<img src="blog/../img/test_pos.gif" width="100%">
<h2 id="existential-types"><a class="header" href="#existential-types">Existential Types</a></h2>
<p>Often we don't care about the <em>exact</em> value of a thing -- but just
care about some <em>properties</em> that it may have. For example, we don't
care that an <code>i32</code> is equal to <code>5</code> or <code>10</code> or <code>n</code> but that it is
non-negative.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left"><strong>Type</strong></th><th style="text-align: left"><strong>Meaning</strong></th></tr></thead><tbody>
<tr><td style="text-align: left"><code>i32{v: 0 &lt;  v}</code></td><td style="text-align: left">The set of <code>i32</code> values that positive</td></tr>
<tr><td style="text-align: left"><code>i32{v: n &lt;= v}</code></td><td style="text-align: left">The set of <code>i32</code> values greater than or equal to <code>n</code></td></tr>
</tbody></table>
</div>
<p>Flux allows such specifications by pairing plain Rust types
with <em>assertions</em> <sup class="footnote-reference"><a href="#1">1</a></sup> that constrain the value. For example, we can rewrite
<code>mk_10</code> with the output type <code>i32{v:0&lt;v}</code> that specifies a weaker property:
the value returned by <code>mk_ten</code> is positive.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn() -&gt; i32{v: 0 &lt; v})]
pub fn mk_ten() -&gt; i32 {
    5 + 5
}
<span class="boring">}</span></code></pre></pre>
<p>Similarly, you might specify that a function that computes the <em>absolute</em>
value of an <code>i32</code> with a type which says the result is non-negative <em>and</em>
exceeds the input <code>n</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn (n:i32) -&gt; i32{v:0&lt;=v &amp;&amp; n&lt;=v})]
pub fn abs(n: i32) -&gt; i32 {
    if 0 &lt;= n {
        n
    } else {
        0 - n
    }
}
<span class="boring">}</span></code></pre></pre>
<p>As a last example, you might write a function to compute the factorial of <code>n</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn (n:i32) -&gt; i32{v:1&lt;=v &amp;&amp; n&lt;=v})]
pub fn factorial(n: i32) -&gt; i32 {
    let mut i = 0;
    let mut res = 1;
    while i &lt; n {
        i += 1;
        res = res * i;
    }
    res
}
<span class="boring">}</span></code></pre></pre>
<p>Here the specification says the input must be non-negative, and the
output is at least as large as the input. Note, that unlike the previous
examples, here we're actually <em>changing</em> the values of <code>i</code> and <code>res</code>.</p>
<img src="blog/../img/factorial.gif" width="100%">
<p>Can you guess why the copilot suggestions <em>failed</em> to pass flux, and
what refinements were <em>inferred</em> for <code>i</code> and <code>res</code> in the <em>fixed</em> code
at the end?</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>In this post, we saw how Flux lets you</p>
<ol>
<li>
<p><em>decorate</em> basic Rust types like <code>i32</code> and <code>bool</code> with
<strong>indices</strong> and <strong>constraints</strong> that let you respectively
<em>refine</em> the sets of values that inhabit that type, and</p>
</li>
<li>
<p><em>specify</em> contracts on functions that state <strong>pre-conditions</strong> on
the sets of legal inputs that they accept, and <strong>post-conditions</strong>
that describe the outputs that they produce.</p>
</li>
</ol>
<p>The whole point of Rust, of course, is to allow for efficient <em>imperative</em>
sharing and updates, without sacrificing thread- or memory-safety. Next time,
we'll see how Flux melds refinements and Rust's ownership to make refinements
happily coexist with imperative code.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>These are not arbitrary Rust expressions but a subset of expressions
from logics that can be efficiently decided by <a href="https://github.com/liquid-rust/flux/blob/main/README.md#grammar-of-refinements">SMT Solvers</a></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership-in-flux"><a class="header" href="#ownership-in-flux">Ownership in Flux</a></h1>
<p><a href="http://flux.programming.systems">Online demo</a></p>
<p><a href="https://liquid-rust.github.io/2022/11/14/introducing-flux/">Previously</a> we saw how to refine basic Rust
types like <code>i32</code> and <code>bool</code> with <em>indices</em> and <em>constraints</em> to
constrain the set of values described by those types.</p>
<p>The whole point of Rust, of course, is to allow for efficient
imperative <em>sharing</em> and <em>updates</em>, via the clever type system
that keeps an eye on the <em>ownership</em> of resources to make sure
that aliasing and mutation cannot happen at the same time.</p>
<p>Next, lets see how Flux melds refinements and Rust's ownership
mechanisms to make refinements work in the imperative setting.</p>
<h2 id="exclusive-ownership"><a class="header" href="#exclusive-ownership">Exclusive Ownership</a></h2>
<p>Rust's most basic form of ownership is <em>exclusive</em> ownership,
in which exactly one variable in a function has the right to
mutate a memory location. When a location is exclusively
owned, we can be sure that there are <em>no other references</em>
to it, which lets flux <em>update</em> the type whenever the location
is changed. For example, consider the program</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn () -&gt; i32[3])]
pub fn mk_three() -&gt; i32 {
    let mut r = 0;  // r: i32[0]
    r += 1;
    assert(r == 1); // r: i32[1]
    r += 1;
    assert(r == 2); // r: i32[2]
    r += 1;
    assert(r == 3); // r: i32[3]
    r
}
<span class="boring">}</span></code></pre></pre>
<p>The variable <code>r</code> has <em>different types</em> at each point inside <code>mk_three</code>.
It starts off as <code>i32[0]</code>. The first increment changes it to <code>i32[1]</code>,
then <code>i32[2]</code> and finally, the returned type <code>i32[3]</code>.</p>
<img src="blog/../img/mk_three.gif" width="100%">
<p>This exclusive ownership mechanism is at work in the <code>factorial</code> example
we signed off with <a href="https://liquid-rust.github.io/2022/11/14/introducing-flux/">previously</a></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn (n:i32{0 &lt;= n}) -&gt; i32{v:n &lt;= v})]
pub fn factorial(n: i32) -&gt; i32 {
    let mut i = 0;  // i: i32[0]
    let mut r = 1;  // r: i32[1]
    while i &lt; n {
                    // i: i32{v:0&lt;=v&lt;=n}
                    // r: i32{v:1&lt;=v &amp;&amp; i&lt;=v}
        i += 1;
        r = r * i;
    }
    r
}
<span class="boring">}</span></code></pre></pre>
<p>In the above code, <code>i</code> and <code>r</code> start off at <code>0</code> and <code>1</code> but then
Rust <em>infers</em> (a story for another day) that inside the <code>while</code>-loop<sup class="footnote-reference"><a href="#1">1</a></sup></p>
<ul>
<li><code>i</code> has type <code>i32{v:0&lt;=v &amp;&amp; v &lt; n}</code></li>
<li><code>r</code> has type <code>i32{v:1&lt;=v &amp;&amp; i &lt;= v}</code></li>
</ul>
<p>and hence, upon exit since <code>i == n</code> we get that the result is at least <code>n</code>.</p>
<h2 id="borrowing-shared-references"><a class="header" href="#borrowing-shared-references">Borrowing: Shared References</a></h2>
<p>Exclusive ownership suffices for simple local updates like in <code>factorial</code>.
However, for more complex data, functions must temporarily relinquish
ownership to allow <em>other</em> functions to mutate the data. Rust cleverly
allows this via the notion of <em>borrowing</em> using two kinds of references
that give callees temporary access to a memory location.</p>
<p>The simplest kind of references are of the form <code>&amp;T</code> which denote <em>read-only</em>
access to a value of type <code>T</code>. For example, we might write <code>abs</code> to take
a shared reference to an <code>i32</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn (p: &amp;i32[@n]) -&gt; i32{v:0&lt;=v &amp;&amp; n&lt;=v})]
pub fn abs(p: &amp;i32) -&gt; i32 {
    let n = *p;
    if 0 &lt;= n {
        n
    } else {
        0 - n
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Notice that the <em>input</em> type has changed: the function now</p>
<ul>
<li>Accepts <code>p</code> a <em>reference</em> to an <code>i32</code> whose value is <code>n</code> as denoted by <code>@n</code></li>
<li>Returns an <code>i32</code> that is non-negative and larger than <code>n</code></li>
</ul>
<p>The <code>@</code> marks the <code>n</code> as a <em>refinement parameter</em> whose value
is automatically computed by flux during type checking.</p>
<p>So, for example, Flux can check the below code by automatically
determining that the refinement parameter at the call-site is <code>10</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn test_abs() {
    let z = 10;
    assert(0 &lt;= abs(&amp;z))
    assert(10 &lt;= abs(&amp;z))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="refinement-parameters"><a class="header" href="#refinement-parameters">Refinement Parameters</a></h3>
<p>As an aside, we have secretly been using <em>refinement parameters</em>
like <code>@n</code> all along. For example, Flux automatically <em>desugars</em> the signature <code>fn(n:i32{0 &lt;= n} -&gt; ...</code> that we wrote for <code>factorial</code> into</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn ({i32[@n] : 0 &lt;= n}) -&gt; i32{v:n &lt;= v}
<span class="boring">}</span></code></pre></pre>
<p>where <code>@n</code> is a refinement parameter that is <em>implicitly</em> determined
from the rust parameter <code>n:i32</code>. However, <em>explicit</em> parameters are
essential to <em>name</em> the value of what a reference points to.
In <code>abs</code> the <code>rust</code> parameter <code>p</code> names the reference but the
<code>@n</code> names the (input) <em>value</em> and lets us use it to provide
more information about the output of <code>abs</code>.</p>
<p>Flux is <em>modular</em> in that the <em>only</em> information it
knows about the implementation of <code>abs</code> is the signature: for example
if we remove the fact that the output exceeds <code>n</code> then Flux will
reject the assertion <code>10 &lt;= abs(&amp;z)</code>.</p>
<img src="blog/../img/test_abs.gif" width="100%">
<h2 id="borrowing-mutable-references"><a class="header" href="#borrowing-mutable-references">Borrowing: Mutable References</a></h2>
<p>References of type <code>&amp;mut T</code> denote <em>mutable</em> references that can be
used to (read and) write or update the contents of a <code>T</code> value.
Crucially, Rust ensures that while there may be multiple read-only (shared)
references to a location, there is at most one <em>active</em> writeable (mutable)
reference at any point in time.</p>
<p>Flux exploits the semantics of <code>&amp;mut T</code> to treat <code>T</code> as an <em>invariant</em>
of the underlying data. As an example, consider the following function
that <em>decrements</em> the value of a mutable reference while ensuring the
data is non-negative:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn(p: &amp;mut i32{v:0 &lt;= v}))]
pub fn decr(p: &amp;mut i32) {
    *p = *p - 1;
}
<span class="boring">}</span></code></pre></pre>
<p>Flux will complain with the following message</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[FLUX]: assignment might be unsafe
  --&gt; src/basics.rs:13:9
   |
13 |         *p = *p - 1;
   |         ^^^^^^^^^^^
<span class="boring">}</span></code></pre></pre>
<p>as in fact, we <em>may</em> be writing a negative value into <code>*p</code>
if, for example, the old value was zero. We can fix this
code by guarding the update with a test that ensures the
original contents are in fact <em>non-zero</em></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn(p: &amp;mut i32{v:0 &lt;= v}))]
pub fn decr(p: &amp;mut i32) {
    let n = *p;
    if n != 0 {
        *p = n - 1;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>at which point Flux is happy to sign off on the code.</p>
<img src="blog/../img/decr.gif" width="100%">
<h2 id="aliased-references"><a class="header" href="#aliased-references">Aliased References</a></h2>
<p>Flux uses Rust's borrowing rules to track invariants even when
there may be aliasing. As an example, consider the function</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn (bool) -&gt; i32{v:0 &lt;= v})]
fn test_alias(z: bool) -&gt; i32 {
    let mut x = 1;  // x: i32[1]
    let mut y = 2;  // y: i32[2]
    let r = if z { &amp;mut x } else { &amp;mut y };
                    // r: &amp;mut i32{v:0 &lt;= v}
    decr(r);
    *r
}
<span class="boring">}</span></code></pre></pre>
<p>The reference <code>r</code> could point to <em>either</em> <code>x</code> or <code>y</code> depending
on the (unknown) value of the boolean <code>z</code>. Nevertheless, Flux
determines that <em>both</em> references <code>&amp;mut x</code> and <code>&amp;mut y</code> point
to values of the more general type <code>i32{v:0&lt;=v}</code> and hence,
infers <code>r : &amp;mut i32{v:0&lt;=v}</code> which allows us it to then call
<code>decr</code> with the reference and guarantee the result (after <code>decr</code>)
is still non-negative.</p>
<h2 id="borrowing-strong-references"><a class="header" href="#borrowing-strong-references">Borrowing: Strong References</a></h2>
<p>In many situations, we want to lend a value to another function
that actually <em>changes</em> the value's (refinement) type upon exit.
For example, consider the following function to increment a reference
to a non-negative <code>i32</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn (p: &amp;mut i32{v:0 &lt;= v}))]
fn incr(p: &amp;mut i32) {
  *p += 1
}
<span class="boring">}</span></code></pre></pre>
<p>Recall that Flux is <em>modular</em> in that the <em>only</em> information it
has about <code>incr</code> is what is said in the signature. The signature
for <code>incr</code> only says <code>p</code> remains non-negative: Flux does <em>not</em>
know that <code>incr</code> actually <em>increments</em> the value of <code>p</code>.</p>
<p>Hence, Flux fusses that the following <code>assert</code> may fail even though
its patently obvious that it will succeed!</p>
<img src="blog/../img/test_incr.gif" width="100%">
<p>To verify <code>test_incr</code> we need a signature for <code>incr</code> that says
that its <em>output</em> is indeed one greater<sup class="footnote-reference"><a href="#2">2</a></sup> than its input.
Flux extends Rust with the notion of <strong>strong references</strong>
of the form <code>&amp;strg T</code> which refine Rust's <code>&amp;mut T</code> to grant
<em>exclusive</em> access to the underlying <code>T</code>. Crucially, strong
references also let us specify how the type is <em>updated</em> when
the function exits<sup class="footnote-reference"><a href="#3">3</a></sup>. Thus, we can use strong references to
type <code>incr</code> as</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::sig(fn(p: &amp;strg i32[@n]) ensures p:i32[n+1])]
fn incr(p: &amp;mut i32) {
  *p += 1
}
<span class="boring">}</span></code></pre></pre>
<p>The Flux signature refines the plain Rust one to specify that</p>
<ol>
<li><code>p</code> is a strong reference to an <code>i32</code>,</li>
<li>the <em>input type</em> of <code>*p</code> is <code>i32[n]</code>, and</li>
<li>the <em>output type</em> of <code>*p</code> is <code>i32[n+1]</code>.</li>
</ol>
<p>With this specification, Flux merrily checks <code>test_incr</code>, by
determining that the refinement parameter <code>@n</code> is <code>10</code> and
hence, that upon return <code>x: i32[11]</code>.</p>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>To sum up, Flux exploits Rust's ownership mechanisms to track properties
of <em>shared</em> (<code>&amp;T</code>) and <em>mutable</em> (<code>&amp;mut T</code>) references, and additionally
adds a <em>strong</em> (<code>&amp;strg T</code>) reference -- a special case of <code>&amp;mut</code> -- to
support the cases where the type itself is <em>changed</em> by a call.</p>
<p>Next, we'll see how refinements and ownership yield a simple refined API
for <em>vectors</em> that lets Flux check bounds safety at compile time...</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>For those familiar with the term, these types are <em>loop invariants</em>
<sup class="footnote-reference"><a href="#2">2</a></sup>: Setting aside the issue of overflows for now
<sup class="footnote-reference"><a href="#3">3</a></sup>: Thereby allowing so-called <em>strong updates</em> in the type specifications</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="about-flux"><a class="header" href="#about-flux">About Flux</a></h1>
<p><img src="img/flux-logo.png" alt="" /></p>
<p>Flux is a research project described in <a href="https://arxiv.org/abs/2207.04034">the paper</a></p>
<h2 id="team"><a class="header" href="#team">Team</a></h2>
<p>Flux is being developed by</p>
<ul>
<li><a href="https://github.com/nilehmann">Nico Lehmann</a>,</li>
<li><a href="https://www.cs.ubc.ca/~atgeller/">Adam Geller</a></li>
<li><a href="https://www.cole-k.com/">Cole Kurashige</a></li>
<li><a href="https://gbarthe.github.io/">Gilles Barthe</a></li>
<li><a href="https://nikivazou.github.io/">Niki Vazou</a></li>
<li><a href="https://cseweb.ucsd.edu/~rjhala">Ranjit Jhala</a></li>
</ul>
<h2 id="code"><a class="header" href="#code">Code</a></h2>
<p>Flux is open-source and available <a href="http://github.com/liquid-rust/flux">here</a></p>
<h2 id="thanks"><a class="header" href="#thanks">Thanks</a></h2>
<p>This work was supported by the National Science Foundation, European Research Council,
and by generous gifts from Microsoft Research.</p>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<p>This is a prototype! Use at your own risk. Everything could break and it will break.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="js/flux.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
