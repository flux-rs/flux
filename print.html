<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Flux Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="flux_theme/flux.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Flux Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <img src="img/logo-wide.svg" class="flux-logo" alt="Flux Logo">
<!-- Types bring order to code.

For example, if a variable `i:usize` then we know `i`
is a number that can be used to index a vector.
Similarly, if `v: Vec<&str>` then we can be sure that
`v` is a collection of strings which may _be_ indexed
but of course, not used _as_ an index.

However, by itself, `usize` doesn't tell us how big
or small the number and hence the programmer must
still rely on their own wits, a lot of tests, and
a dash of optimism, to ensure that all the different
bits snap together correctly at run-time. -->
<p>Flux is a <a href="https://github.com/flux-rs/flux/"><strong>refinement type checker</strong></a> plugin
for Rust that lets you <em>specify</em> a range of correctness properties
and have them be <em>verified</em> at compile time.</p>
<p>Flux works by extending Rust's types with <a href="https://arxiv.org/abs/2010.07763">refinements</a>:
logical assertions describing additional correctness requirements
that are checked during compilation, thereby eliminating various
classes of run-time problems.</p>
<p>You can try it on the <a href="https://flux.goto.ucsd.edu/"><strong>online playground</strong></a>.</p>
<p>Better still, read the <a href="./01-refinements.html"><strong>interactive tutorial</strong></a>,
to learn how you can use Flux on your Rust code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing-and-running-flux"><a class="header" href="#installing-and-running-flux">Installing and Running Flux</a></h1>
<p>You can install and then run Flux either on a single file or on an entire crate.</p>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<ul>
<li>
<p><a href="https://rustup.rs/">rustup</a></p>
<p>Rustup is required because Flux needs access to the source code of the Rust compiler, which we grab from rustup.</p>
</li>
<li>
<p><a href="https://github.com/ucsd-progsys/liquid-fixpoint">liquid-fixpoint</a></p>
<p>Nightly binary builds are avilable on <a href="https://github.com/ucsd-progsys/liquid-fixpoint/releases/tag/nightly">GitHub Releases</a>. If there is no binary available
for your platform, you will need to <a href="https://github.com/ucsd-progsys/liquid-fixpoint?tab=readme-ov-file#how-to-build-and-install">build it from source</a>.</p>
</li>
<li>
<p><a href="https://github.com/Z3Prover/z3">z3</a> 4.15 or later</p>
<p>You can download a binary for your platform from <a href="https://github.com/Z3Prover/z3/releases">Z3 GitHub Releases</a>. We recommend downloading the latest version, but older version should also work.</p>
</li>
</ul>
<p><strong>Note:</strong>
Make sure that the <code>liquid-fixpoint</code> and <code>z3</code> binaries are in your <code>$PATH</code>.</p>
<h2 id="install"><a class="header" href="#install">Install</a></h2>
<p>The only way to use Flux is to build it from source.</p>
<p>First you need to clone the repository</p>
<pre><code class="language-bash">git clone https://github.com/flux-rs/flux
cd flux
</code></pre>
<p>To build the source you need a nightly version of <code>rustc</code>.
We pin the version using a <a href="https://github.com/flux-rs/flux/blob/main/rust-toolchain">toolchain file</a> (more info <a href="https://rust-lang.github.io/rustup/overrides.html#the-toolchain-file">here</a>).
If you are using <code>rustup</code>, no special action is needed as it should install the correct <code>rustc</code> version and components based on the information on that file.</p>
<p>Next, run the following to build and install <code>flux</code> binaries</p>
<pre><code class="language-bash">cargo xtask install
</code></pre>
<p>This will install two binaries <code>flux</code> and <code>cargo-flux</code> in your cargo home. These two binaries should be used
respectively to run Flux on either a single file or on a project using cargo. The installation process will
also copy some files to <code>$HOME/.flux</code>.</p>
<p>In order to use Flux refinement attributes in a Cargo project, you will need to add the
following to your Cargo.toml</p>
<pre><code class="language-toml">[dependencies]
flux-rs = { git  = "https://github.com/flux-rs/flux.git" }
</code></pre>
<p>This will add the procedural macros Flux uses to your project; it is not a substitute for installing Flux, which must still be done.</p>
<h2 id="running-on-a-file-flux"><a class="header" href="#running-on-a-file-flux">Running on a File: <code>flux</code></a></h2>
<p>You can use <code>flux</code> as you would use <code>rustc</code>.
For example, the following command checks the file <code>test.rs</code>.</p>
<pre><code class="language-bash">flux path/to/test.rs
</code></pre>
<p>The flux binary accepts the same flags as <code>rustc</code>.
You could for example check a file as a library instead of a binary like so</p>
<pre><code class="language-bash">flux --crate-type=lib path/to/test.rs
</code></pre>
<h3 id="refinement-annotations-on-a-file"><a class="header" href="#refinement-annotations-on-a-file">Refinement Annotations on a File</a></h3>
<p>When running flux on a file with <code>flux path/to/test.rs</code>, refinement annotations should be prefixed with <code>flux::</code>.</p>
<p>For example, the refinement below will only work when running <code>flux</code> which is intended for use on a single file.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::spec(fn(x: i32) -&gt; i32{v: x &lt; v})]
fn inc(x: i32) -&gt; i32 {
    x - 1
}
<span class="boring">}</span></code></pre></pre>
<h2 id="running-on-a-package-cargo-flux"><a class="header" href="#running-on-a-package-cargo-flux">Running on a package: <code>cargo-flux</code></a></h2>
<p>See this an
Flux is integrated with <code>cargo</code> and can be invoked in a package as follows:</p>
<pre><code class="language-bash">cargo flux
</code></pre>
<p>By default, Flux won't verify a package unless it's explicitly enabled in the manifest.
To do so add the following to <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package.metadata.flux]
enabled = true
</code></pre>
<h3 id="refinement-annotations-on-a-cargo-projects"><a class="header" href="#refinement-annotations-on-a-cargo-projects">Refinement Annotations on a Cargo Projects</a></h3>
<p>Adding refinement annotations to cargo projects is simple. You can add <code>flux-rs</code> as a dependency in <code>Cargo.toml</code></p>
<pre><code class="language-toml">[dependencies]
flux-rs = { git  = "https://github.com/flux-rs/flux.git" }
</code></pre>
<p>Then, import attributes from <code>flux_rs</code> and add the appropriate refinement annoations.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use flux_rs::attrs::*;

#[spec(fn(x: i32) -&gt; i32{v: x &lt; v})]
fn inc(x: i32) -&gt; i32 {
    x - 1
}
<span class="boring">}</span></code></pre></pre>
<h2 id="a-tiny-example"><a class="header" href="#a-tiny-example">A tiny example</a></h2>
<p>The following example declares a function <code>inc</code>
that returns an integer greater than the input.
We use the nightly feature <code>register_tool</code>
to register the <code>flux</code> tool in order to
add refinement annotations to functions.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::spec(fn(x: i32) -&gt; i32{v: x &lt; v})]
pub fn inc(x: i32) -&gt; i32 {
    x - 1
}
<span class="boring">}</span></code></pre></pre>
<p>You can save the above snippet in say <code>test0.rs</code> and then run</p>
<pre><code class="language-bash">flux --crate-type=lib path/to/test0.rs
</code></pre>
<p>you should see in your output</p>
<pre><code class="language-text">error[FLUX]: postcondition might not hold
 --&gt; test0.rs:3:5
  |
3 |     x - 1
  |     ^^^^^
</code></pre>
<p>as indeed <code>x - 1</code> is <em>not</em> greater than <code>x</code> as required by the output refinement <code>i32{v: x &lt; v}</code>.</p>
<p>If you fix the error by replacing <code>x - 1</code> with <code>x + 1</code>, you should get no errors
in the output (the output may be empty, but in this case no output is a good
thing).</p>
<p>Read <a href="guide/SUMMARY.html#learn">these chapters</a> to learn more about what you specify and verify with <code>flux</code>.</p>
<h2 id="a-note-about-the-flux-driver-binary"><a class="header" href="#a-note-about-the-flux-driver-binary">A note about the flux-driver binary</a></h2>
<p>The <code>flux-driver</code> binary is a <a href="https://rustc-dev-guide.rust-lang.org/rustc-driver.html?highlight=driver#the-rustc-driver-and-interface">rustc
driver</a>
(similar to how clippy works) meaning it uses rustc as a library to "drive"
compilation performing additional analysis along the way. Running the binary
requires dynamically linking a correct version of <code>librustc</code>. Thus, to avoid the
hassle you should never execute it directly. Instead, use <code>flux</code> or <code>cargo-flux</code>.</p>
<h2 id="editor-support"><a class="header" href="#editor-support">Editor Support</a></h2>
<p>This section assumes you have installed <code>cargo-flux</code>.</p>
<h3 id="rust-analyzer-in-vscode"><a class="header" href="#rust-analyzer-in-vscode">Rust-Analyzer in VSCode</a></h3>
<p>Add this to the workspace settings i.e. <code>.vscode/settings.json</code></p>
<pre><code class="language-json">{
  "rust-analyzer.check.overrideCommand": [
    "cargo",
    "flux",
    "--workspace",
    "--message-format=json-diagnostic-rendered-ansi"
  ]
}
</code></pre>
<p><strong>Note:</strong> Make sure to edit the paths in the above snippet to point to the correct locations on your machine.</p>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<h3 id="flux-flags"><a class="header" href="#flux-flags">Flux Flags</a></h3>
<p>The <code>flux</code> binary accepts configuration flags in the format <code>-Fname=value</code>. For boolean flags, the
<code>value</code> can be one of <code>y</code>, <code>yes</code>, <code>on</code>, <code>true</code>, <code>n</code>, <code>no</code>, <code>off</code>, <code>false</code>. Alternatively, the <code>value</code>
can be omitted which will default to <code>true</code>. For example, to set the solver to <code>cvc5</code> and enable
qualifier scrapping:</p>
<pre><code class="language-console">flux -Fsolver=cvc5 -Fscrape-quals path/to/file.rs
</code></pre>
<p>For all available flags, see <a href="https://flux-rs.github.io/flux/doc/flux_config/flags/struct.Flags.html">https://flux-rs.github.io/flux/doc/flux_config/flags/struct.Flags.html</a></p>
<h3 id="cargo-projects"><a class="header" href="#cargo-projects">Cargo Projects</a></h3>
<p>When working with a Cargo project, some of the <a href="guide/install.html#Flux-Flags">flags</a> can be configured in the
<code>[package.metadata.flux]</code> table in <code>Cargo.toml</code>. For example, to enable query caching and set
<code>cvc5</code> as the solver:</p>
<pre><code class="language-toml"># Cargo.toml
[package.metadata.flux]
enabled = true
cache = true
solver = "cvc5"
</code></pre>
<p>Additionally, <code>cargo flux</code> searches for a configuration file called <code>flux.toml</code> with the same format
as the metadata table. The content of <code>flux.toml</code> takes precedence and it's merged with the
content of the <code>metadata</code> table. Note that the content of <code>flux.toml</code> will override the <code>metadata</code>
for all crates, including dependencies. This behavior is likely to change in the future as we figure
out what configurations make sense to have per package and which should only affect the current execution
of <code>cargo flux</code>.</p>
<p>You can see the format of the <code>metadata</code> in <a href="https://flux-rs.github.io/flux/doc/flux_bin/struct.FluxMetadata.html">https://flux-rs.github.io/flux/doc/flux_bin/struct.FluxMetadata.html</a>.</p>
<h3 id="fluxflags-environement-variable"><a class="header" href="#fluxflags-environement-variable"><code>FLUXFLAGS</code> Environement Variable</a></h3>
<p>When running <code>cargo flux</code>, flags defined in <code>FLUXFLAGS</code> will be passed to all <code>flux</code> invocations,
for example, to print timing information for all crates checked by Flux:</p>
<pre><code class="language-console">FLUXFLAGS="-Ftimings" cargo flux
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="about-flux"><a class="header" href="#about-flux">About Flux</a></h1>
<img src="img/logo-wide.svg" class="flux-logo" alt="Flux Logo">
<h2 id="team"><a class="header" href="#team">Team</a></h2>
<p>Flux is being developed by</p>
<ul>
<li><a href="https://github.com/nilehmann">Nico Lehmann</a>,</li>
<li><a href="https://www.cs.ubc.ca/~atgeller/">Adam Geller</a></li>
<li><a href="https://www.cole-k.com/">Cole Kurashige</a></li>
<li><a href="https://gbarthe.github.io/">Gilles Barthe</a></li>
<li><a href="https://nikivazou.github.io/">Niki Vazou</a></li>
<li><a href="https://cseweb.ucsd.edu/~rjhala">Ranjit Jhala</a></li>
</ul>
<h2 id="code"><a class="header" href="#code">Code</a></h2>
<p>Flux is open-source and available <a href="http://github.com/liquid-rust/flux">here</a></p>
<h2 id="publications"><a class="header" href="#publications">Publications</a></h2>
<ul>
<li><a href="https://dl.acm.org/doi/pdf/10.1145/3591283">Lehmann, Nico, Adam T. Geller, Niki Vazou, and Ranjit Jhala. "Flux: Liquid types for rust."  PLDI (2023)</a></li>
<li><a href="https://dl.acm.org/doi/pdf/10.1145/3704885">Lehmann, Nico, Cole Kurashige, Nikhil Akiti, Niroop Krishnakumar, and Ranjit Jhala. "Generic Refinement Types." POPL (2025)</a></li>
</ul>
<h2 id="talks"><a class="header" href="#talks">Talks</a></h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=3iYt2JTXCwM">PLDI'23</a></li>
<li><a href="https://www.youtube.com/watch?v=NIJtZ0yUDX0">SOAP'23</a></li>
</ul>
<h2 id="thanks"><a class="header" href="#thanks">Thanks</a></h2>
<p>This work was supported by the National Science Foundation, European Research Council,
and by generous gifts from Microsoft Research.</p>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<p>This is a prototype! Use at your own risk. Everything could break and it will break.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="refining-types"><a class="header" href="#refining-types">Refining Types</a></h1>
<p>Types bring order to code. For example, if a variable <code>i:usize</code>
then we know <code>i</code> is a number that can be used to index a vector.
Similarly, if <code>v: Vec&lt;&amp;str&gt;</code> then we can be sure that <code>v</code> is a
collection of strings which may <em>be</em> indexed but of course,
not used <em>as</em> an index. However, by itself <code>usize</code> doesn't
tell us how big or small the number and hence the programmer
must still rely on their own wits, a lot of tests, and a dash
of optimism, to ensure that all the different bits fit properly
at run-time.</p>
<p><a href="https://arxiv.org/abs/2010.07763">Refinements</a> are a promising new way to extend
type checkers with logical constraints that <em>specify</em> additional
correctness requirements that can be <em>verified</em> by the compiler,
thereby entirely eliminating various classes of run-time problems.</p>
<p>To begin, lets see how flux lets you refine <em>basic</em> or <em>primitive</em>
types like <code>i32</code> or <code>usize</code> or <code>bool</code> with logical constraints that
can be checked at compile time.</p>
<!-- more -->
<!-- SLIDE -->
<h2 id="indexed-types"><a class="header" href="#indexed-types">Indexed Types</a></h2>
<p>The simplest kind of refinement type in flux is a type that is
<em>indexed</em> by a logical value. For example</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left"><strong>Type</strong></th><th style="text-align: left"><strong>Meaning</strong></th></tr></thead><tbody>
<tr><td style="text-align: left"><code>i32[10]</code></td><td style="text-align: left">The (singleton) set of <code>i32</code> values equal to <code>10</code></td></tr>
<tr><td style="text-align: left"><code>bool[true]</code></td><td style="text-align: left">The (singleton) set of <code>bool</code> values equal to <code>true</code></td></tr>
</tbody></table>
</div><!-- SLIDE -->
<h3 id="flux-specifications"><a class="header" href="#flux-specifications">Flux Specifications</a></h3>
<p>First off, we need to add some incantations that pull in the mechanisms
for writing flux specifications as Rust <em>attributes</em>.</p>
<pre><pre class="playground"><code class="language-rust editable">#![allow(unused)]
extern crate flux_rs;
use flux_rs::attrs::*;</code></pre></pre>
<!-- SLIDE -->
<h3 id="post-conditions"><a class="header" href="#post-conditions">Post-Conditions</a></h3>
<p>We can already start using these indexed types to start writing (and checking)
code. For example, we can write the following specification which says that
the value <em>returned</em> by <code>mk_ten</code> must in fact be <code>10</code></p>
<pre><pre class="playground"><code class="language-rust editable">#[spec(fn() -&gt; i32[10])]
pub fn mk_ten() -&gt; i32 {
    5 + 4
}</code></pre></pre>
<p><strong>Push Play</strong>
Push the "run" button in the pane above. You will see a red squiggle that
and when you hover over the squiggle you will see an error message</p>
<pre><code class="language-bash">error[...]: refinement type error
  |
7 |     5 + 4
  |     ^^^^^ a postcondition cannot be proved
</code></pre>
<p>which says that that the <em>postcondition might not hold</em> which means
that the <em>output</em> produced by <code>mk_ten</code> may not in fact be an <code>i32[10]</code>
as indeed, in this case, the result is <code>9</code>! You can eliminate the error
by <em>editing</em> the body to <code>5 + 4 + 1</code> or <code>5 + 5</code> or just <code>10</code>.</p>
<!-- SLIDE -->
<h3 id="pre-conditions"><a class="header" href="#pre-conditions">Pre-Conditions</a></h3>
<p>You can use an index to <em>restrict the inputs</em> that a function expects
to be called with.</p>
<pre><pre class="playground"><code class="language-rust editable">#[spec(fn (b:bool[true]))]
pub fn assert(b:bool) {
  if !b { panic!("assertion failed") }
}</code></pre></pre>
<p>The specification for <code>assert</code> says you can <em>only</em> call
it with <code>true</code> as the input. So if you write</p>
<pre><pre class="playground"><code class="language-rust editable">fn test(){
  assert(2 + 2 == 4);
  assert(2 + 2 == 5); // fails to type check
}</code></pre></pre>
<p>then <code>flux</code> will complain that</p>
<pre><code class="language-bash">error[FLUX]: precondition might not hold
   |
12 |     assert(2 + 2 == 5); // fails to type check
   |     ^^^^^^^^^^^^^^^^^^
</code></pre>
<p>meaning at the second call to <code>assert</code> the input <em>may not</em>
be <code>true</code>, as of course, in this case, it is not!</p>
<p>Can you edit the code of <code>test</code> to fix the error?</p>
<!-- SLIDE -->
<h2 id="index-parameters-and-expressions"><a class="header" href="#index-parameters-and-expressions">Index Parameters and Expressions</a></h2>
<p>Its not terribly exciting to only talk about <em>fixed</em> values
like <code>10</code> or <code>true</code>. To be more useful, <code>flux</code> lets you index
types by refinement <em>parameters</em>. For example, you can write</p>
<pre><pre class="playground"><code class="language-rust editable">#[spec(fn(n:i32) -&gt; bool[0 &lt; n])]
pub fn is_pos(n: i32) -&gt; bool {
  if 0 &lt; n {
    true
  } else {
    false
  }
}</code></pre></pre>
<p>Here, the type says that <code>is_pos</code></p>
<ul>
<li><strong>takes</strong> as <em>input</em> some <code>i32</code> <em>indexed by</em> <code>n</code></li>
<li><strong>returns</strong> as <em>output</em> the <code>bool</code> <em>indexed by</em> <code>0 &lt; n</code></li>
</ul>
<p>That is, <code>is_pos</code> returns <code>true</code> <em>exactly when</em> <code>0 &lt; n</code>.</p>
<p>We might use this function to check that:</p>
<pre><pre class="playground"><code class="language-rust editable">pub fn test_pos(n: i32) {
  let m = if is_pos(n) { n - 1 } else { 0 };
  assert(0 &lt;= m);
}</code></pre></pre>
<!-- SLIDE -->
<h2 id="existential-types"><a class="header" href="#existential-types">Existential Types</a></h2>
<p>Often we don't care about the <em>exact</em> value of a thing -- but just
care about some <em>properties</em> that it may have. For example, we don't
care that an <code>i32</code> is equal to <code>5</code> or <code>10</code> or <code>n</code> but that it is
non-negative.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left"><strong>Type</strong></th><th style="text-align: left"><strong>Meaning</strong></th></tr></thead><tbody>
<tr><td style="text-align: left"><code>i32{v: 0 &lt;  v}</code></td><td style="text-align: left">The set of <code>i32</code> values that positive</td></tr>
<tr><td style="text-align: left"><code>i32{v: n &lt;= v}</code></td><td style="text-align: left">The set of <code>i32</code> values greater than or equal to <code>n</code></td></tr>
</tbody></table>
</div>
<p>Flux allows such specifications by pairing plain Rust types
with <em>assertions</em> <sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup> that constrain the value.</p>
<!-- SLIDE -->
<h2 id="existential-output-types"><a class="header" href="#existential-output-types">Existential Output Types</a></h2>
<p>For example, we can rewrite <code>mk_10</code> with the output type
<code>i32{v:0&lt;v}</code> that specifies a weaker property:
the value returned by <code>mk_ten_pos</code> is positive.</p>
<pre><pre class="playground"><code class="language-rust editable">#[spec(fn() -&gt; i32{v: 0 &lt; v})]
pub fn mk_ten_pos() -&gt; i32 {
    5 + 5
}</code></pre></pre>
<!-- SLIDE -->
<h2 id="example-absolute-value"><a class="header" href="#example-absolute-value">Example: <code>abs</code>olute value</a></h2>
<p>Similarly, you might specify that a function that computes the <em>absolute</em>
value of an <code>i32</code> with a type which says the result is non-negative <em>and</em>
exceeds the input <code>n</code>.</p>
<pre><pre class="playground"><code class="language-rust editable">#[spec(fn (n:i32) -&gt; i32{v:0&lt;=v &amp;&amp; n&lt;=v})]
pub fn abs(n: i32) -&gt; i32 {
    if 0 &lt;= n {
        n
    } else {
        0 - n
    }
}</code></pre></pre>
<!-- SLIDE -->
<h2 id="combining-indexes-and-constraints"><a class="header" href="#combining-indexes-and-constraints">Combining Indexes and Constraints</a></h2>
<p>Sometimes, we want to <em>combine</em> indexes and constraints in a specification.</p>
<p>For example, suppose we have some code that manipulates
<em>scores</em> which are required to be between <code>0</code> and <code>100</code>.
Now, suppose we want to write a function that adds <code>k</code>
points to a score <code>s</code>. We want to specify that</p>
<ul>
<li>The <em>inputs</em> <code>s</code> and <code>k</code> must be non-negative,</li>
<li>the <em>inputs</em> <code>s + k &lt;= 100</code>, and</li>
<li>The <em>output</em> equals <code>s + k</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">#[spec(fn ({usize[@s] | s + k &lt;= 100}, k:usize) -&gt; usize[s + k])]
fn add_points(s: usize, k: usize) -&gt; usize {
    s + k
}

fn test_add_points() {
    assert(add_points(20, 30) == 50);
    assert(add_points(90, 30) == 120); // fails to type check
}</code></pre></pre>
<p>Note that we use the <code>@s</code> to <em>index</em> the value of the <code>s</code> parameter,
so that we can</p>
<ol>
<li><em>constrain</em> the inputs to <code>s + k &lt;= 100</code>, and</li>
<li><em>refine</em> the value of the output to be exactly <code>usize[s + k]</code>.</li>
</ol>
<p><strong>EXERCISE</strong> Why does flux reject the second call to <code>add_points</code>?</p>
<!-- SLIDE -->
<h2 id="example-factorial"><a class="header" href="#example-factorial">Example: <code>factorial</code></a></h2>
<p>As a last example, you might write a function to compute the factorial of <code>n</code></p>
<pre><pre class="playground"><code class="language-rust editable">#[spec(fn (n:i32) -&gt; i32{v:1&lt;=v &amp;&amp; n&lt;=v})]
pub fn factorial(n: i32) -&gt; i32 {
    let mut i = 0;
    let mut res = 1;
    while i &lt; n {
        i += 1;
        res = res * i;
    }
    res
}</code></pre></pre>
<p>Here the specification says the input must be non-negative, and the
output is at least as large as the input. Note, that unlike the previous
examples, here we're actually <em>changing</em> the values of <code>i</code> and <code>res</code>.</p>
<!-- SLIDE -->
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>In this post, we saw how Flux lets you</p>
<ol>
<li>
<p><em>decorate</em> basic Rust types like <code>i32</code> and <code>bool</code> with
<strong>indices</strong> and <strong>constraints</strong> that let you respectively
<em>refine</em> the sets of values that inhabit that type, and</p>
</li>
<li>
<p><em>specify</em> contracts on functions that state <strong>pre-conditions</strong> on
the sets of legal inputs that they accept, and <strong>post-conditions</strong>
that describe the outputs that they produce.</p>
</li>
</ol>
<p>The whole point of Rust, of course, is to allow for efficient <em>imperative</em>
sharing and updates, without sacrificing thread- or memory-safety. Next time,
we'll see how Flux melds refinements and Rust's ownership to make refinements
happily coexist with imperative code.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<p>These are not arbitrary Rust expressions but a subset of expressions from logics that can be efficiently decided by <a href="https://github.com/flux-rs/flux/blob/main/book/src/guide/specs.md#grammar-of-refinements">SMT Solvers</a> <a href="#fr-1-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="ownership-in-flux"><a class="header" href="#ownership-in-flux">Ownership in Flux</a></h1>
<pre><pre class="playground"><code class="language-rust  editable  hidden">#![allow(unused)]
extern crate flux_rs;
use flux_rs::attrs::*;</code></pre></pre>
<p><a href="https://flux.goto.ucsd.edu/?example=ownership.rs">Online demo</a></p>
<p><a href="tutorial/./01-introducing-flux.html">Previously</a> we saw how to refine basic Rust
types like <code>i32</code> and <code>bool</code> with <em>indices</em> and <em>constraints</em> to
constrain the set of values described by those types. For instance, we
wrote the function <code>assert</code> function which can <em>only</em> be called with <code>true</code></p>
<pre><pre class="playground"><code class="language-rust editable">#[flux_rs::spec(fn (bool[true]))]
fn assert(b: bool) {
    if !b {
        panic!("assertion failed");
    }
}

fn test_assert() {
    assert(2 + 2 == 4);
    assert(2 + 2 == 5); // fails to type check
}</code></pre></pre>
<p>The whole point of Rust, of course, is to allow for efficient
imperative <em>sharing</em> and <em>updates</em>, via the clever type system
that keeps an eye on the <em>ownership</em> of resources to make sure
that aliasing and mutation cannot happen at the same time.</p>
<p>Next, lets see how Flux melds refinements and Rust's ownership
mechanisms to make refinements pleasant in the imperative setting.</p>
<!-- SLIDE -->
<h2 id="exclusive-ownership"><a class="header" href="#exclusive-ownership">Exclusive Ownership</a></h2>
<p>Rust's most basic form of sharing is <em>exclusive</em> ownership,
in which exactly one variable in a function has the right to
mutate a memory location. When a location is exclusively
owned, we can be sure that there are <em>no other references</em>
to it. Consequently, <code>flux</code> can <em>update</em> the type to precisely
track the value whenever the location is changed.</p>
<p>For example, consider the program</p>
<pre><pre class="playground"><code class="language-rust  editable">#[flux_rs::spec(fn () -&gt; i32[3])]
pub fn mk_three() -&gt; i32 {
  let mut r = 0;  // r: i32[0]
  r += 1;
  assert(r == 1); // r: i32[1]
  r += 1;
  assert(r == 2); // r: i32[2]
  r += 1;
  assert(r == 3); // r: i32[3]
  r
}</code></pre></pre>
<p>The variable <code>r</code> has <em>different types</em> at each point inside <code>mk_three</code>.
It starts off as <code>i32[0]</code>. The first increment changes it to <code>i32[1]</code>,
then <code>i32[2]</code> and finally, the returned type <code>i32[3]</code>.</p>
<!-- SLIDE -->
<h2 id="exclusive-ownership-and-loops"><a class="header" href="#exclusive-ownership-and-loops">Exclusive Ownership and Loops</a></h2>
<p>This exclusive ownership mechanism is at work in the <code>factorial</code> example
we signed off with <a href="tutorial/./01-introducing-flux.html">previously</a></p>
<pre><pre class="playground"><code class="language-rust  editable">#[flux_rs::spec(fn (n:i32{0 &lt;= n}) -&gt; i32{v:n &lt;= v})]
pub fn factorial(n: i32) -&gt; i32 {
    let mut i = 0;  // i: i32[0]
    let mut r = 1;  // r: i32[1]
    while i &lt; n {
                    // i: i32{v:0 &lt;= v &lt;= n}
                    // r: i32{v:1 &lt;= v &amp;&amp; i &lt;= v}
        i += 1;
        r = r * i;
    }
    r
}</code></pre></pre>
<p>In the above code, <code>i</code> and <code>r</code> start off at <code>0</code> and <code>1</code> but then
flux <em>infers</em> (a story for another day) that inside the <code>while</code>-loop<sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup></p>
<ul>
<li><code>i</code> has type <code>i32{v:0&lt;=v &amp;&amp; v &lt; n}</code></li>
<li><code>r</code> has type <code>i32{v:1&lt;=v &amp;&amp; i &lt;= v}</code></li>
</ul>
<p>and hence, upon exit since <code>i == n</code> we get that the result is at least <code>n</code>.</p>
<!-- SLIDE -->
<h2 id="borrowing-shared-references"><a class="header" href="#borrowing-shared-references">Borrowing: Shared References</a></h2>
<p>Exclusive ownership suffices for simple local updates
like in <code>factorial</code>. However, for more complex data,
functions must temporarily relinquish ownership to
allow <em>other</em> functions to mutate the data.</p>
<p>Rust cleverly allows this via the notion of
<em>borrowing</em> using two kinds of references
that give callee functions temporary access
to memory location.</p>
<p>The simplest kind of references are <code>&amp;T</code>
which denote <em>read-only</em> access to a value
of type <code>T</code>. For example, we might write <code>abs</code> to take
a shared reference to an <code>i32</code></p>
<pre><pre class="playground"><code class="language-rust  editable">#[flux_rs::spec(fn (p: &amp;i32[@n]) -&gt; i32{v:0&lt;=v &amp;&amp; n&lt;=v})]
pub fn abs(p: &amp;i32) -&gt; i32 {
    let n = *p;
    if 0 &lt;= n {
        n
    } else {
        0 - n
    }
}</code></pre></pre>
<p>Notice that the <em>input</em> type has changed. Now, the function</p>
<ul>
<li><strong>accepts</strong> <code>p</code>, a <em>reference</em> to an <code>i32</code> whose value is <code>n</code> as denoted by <code>@n</code></li>
<li><strong>returns</strong> an <code>i32</code> that is non-negative and larger than <code>n</code></li>
</ul>
<p>The <code>@</code> marks the <code>n</code> as a <em>refinement parameter</em> whose value
is automatically computed by flux during type checking.</p>
<!-- SLIDE -->
<h3 id="calling-abs-with-a-reference"><a class="header" href="#calling-abs-with-a-reference">Calling <code>abs</code> with a reference</a></h3>
<p>So, for example, Flux can check the below code by automatically
determining that the refinement parameter at the call-site is <code>10</code>.</p>
<pre><pre class="playground"><code class="language-rust  editable">pub fn test_abs() {
    let z = 10;
    assert(0 &lt;= abs(&amp;z));
    assert(10 &lt;= abs(&amp;z))
}</code></pre></pre>
<!-- SLIDE -->
<h3 id="refinement-parameters"><a class="header" href="#refinement-parameters">Refinement Parameters</a></h3>
<p>As an aside, we have secretly been using <em>refinement parameters</em>
like <code>@n</code> all along. For example, Flux automatically <em>desugars</em>
the signature <code>fn(n:i32{0 &lt;= n} -&gt; ...</code> that we wrote for <code>factorial</code> into</p>
<pre><code>fn ({i32[@n] : 0 &lt;= n}) -&gt; i32{v:n &lt;= v}
</code></pre>
<p>where <code>@n</code> is a refinement parameter that is <em>implicitly</em> determined
from the rust parameter <code>n:i32</code>. However, <em>explicit</em> parameters are
essential to <em>name</em> the value of what a reference points to.
In <code>abs</code> the <code>rust</code> parameter <code>p</code> names the reference but the
<code>@n</code> names the (input) <em>value</em> and lets us use it to provide
more information about the output of <code>abs</code>.</p>
<p><strong>EXERCISE</strong> Flux is <em>modular</em> in that the
<em>only</em> information it knows about the
implementation of <code>abs</code> is the signature.
For example, suppose we change the output type
of <code>abs</code> to <code>i32{v:0&lt;=v}</code>, that is, we remove the
<code>n &lt;= v</code> conjunct. Can you predict which <code>assert</code>
will be rejected by flux?</p>
<!-- SLIDE -->
<h2 id="borrowing-mutable-references"><a class="header" href="#borrowing-mutable-references">Borrowing: Mutable References</a></h2>
<p>References of type <code>&amp;mut T</code> denote <em>mutable</em> references that can be
used to (read and) write or update the contents of a <code>T</code> value.
Crucially, Rust ensures that while there may be multiple read-only (shared)
references to a location, there is at most one <em>active</em> writeable (mutable)
reference at any point in time.</p>
<p>Flux exploits the semantics of <code>&amp;mut T</code> to treat <code>T</code> as an <em>invariant</em>
of the underlying data. As an example, consider the following function
that <em>decrements</em> the value of a mutable reference while ensuring the
data is non-negative:</p>
<pre><pre class="playground"><code class="language-rust  editable">#[flux_rs::spec(fn(p: &amp;mut i32{v:0 &lt;= v}))]
pub fn decr(p: &amp;mut i32) {
    *p = *p - 1;
}</code></pre></pre>
<p>Flux complains that</p>
<pre><code>error[FLUX]: assignment might be unsafe
   |
13 |         *p = *p - 1;
   |         ^^^^^^^^^^^
</code></pre>
<p>as in fact, we <em>may</em> be writing a negative value into <code>*p</code>
for example, if the old value was zero. We can fix this
code by guarding the update with a test that ensures the
original contents are in fact <em>non-zero</em></p>
<p><strong>EXERCISE</strong> Can you <em>modify</em> the code for <code>decr</code> so that flux verifies it?</p>
<!-- SLIDE -->
<h3 id="aliased-references"><a class="header" href="#aliased-references">Aliased References</a></h3>
<p>Flux uses Rust's borrowing rules to track invariants even when
there may be aliasing. As an example, consider the function</p>
<pre><pre class="playground"><code class="language-rust  editable">#[flux_rs::spec(fn (bool) -&gt; i32{v:0 &lt;= v})]
fn test_alias(z: bool) -&gt; i32 {
    let mut x = 1;  // x: i32[1]
    let mut y = 2;  // y: i32[2]
    let r = if z { &amp;mut x } else { &amp;mut y };
                    // r: &amp;mut i32{v:0 &lt;= v}
    decr(r);
    *r
}</code></pre></pre>
<p>The reference <code>r</code> could point to <em>either</em> <code>x</code> or <code>y</code> depending
on the (unknown) value of the boolean <code>z</code>. Nevertheless, Flux
determines that <em>both</em> references <code>&amp;mut x</code> and <code>&amp;mut y</code> point
to values of the more general type <code>i32{v:0&lt;=v}</code> and hence,
infers <code>r : &amp;mut i32{v:0&lt;=v}</code> which allows us it to then call
<code>decr</code> with the reference and guarantee the result (after <code>decr</code>)
is still non-negative.</p>
<!-- SLIDE -->
<h3 id="invariants-are-not-enough"><a class="header" href="#invariants-are-not-enough">Invariants are not enough!</a></h3>
<p>In many situations, we want to lend a value to another function
that actually <em>changes</em> the value's (refinement) type upon exit.
For example, consider the following function to <em>increment</em>
a reference to a non-negative <code>i32</code></p>
<pre><pre class="playground"><code class="language-rust  editable">#[flux_rs::spec(fn (p: &amp;mut i32{v:0 &lt;= v}))]
fn incr_inv(p: &amp;mut i32) {
  *p += 1
}

fn test_incr_inv() {
  let mut z = 10;
  incr_inv(&amp;mut z);
  assert(z == 11);
}</code></pre></pre>
<p>The only information that <code>flux</code> has about <code>incr</code> what
it says in its <code>spec</code>, namely, that <code>p</code> remains non-negative.
Flux is blissfully unaware that <code>incr</code> <em>increments</em>
the value of <code>p</code>, and it cannot prove that after the
call, <code>z == 11</code> and hence, complains that <code>assert</code>
may fail even though it will obviously succeed!</p>
<!-- SLIDE -->
<h2 id="borrowing-updatable-references"><a class="header" href="#borrowing-updatable-references">Borrowing: <em>Updatable</em> References</a></h2>
<p>To verify <code>test_incr</code> we need a signature for <code>incr</code> that says
that its <em>output</em> is indeed one greater<sup class="footnote-reference" id="fr-2-1"><a href="#footnote-2">2</a></sup> than its input.</p>
<p>Flux extends Rust <code>&amp;mut T</code> with the notion of <strong>updatable references</strong>
which <em>additionally</em> specify how the type is <em>changed</em> when
the function exits<sup class="footnote-reference" id="fr-3-1"><a href="#footnote-3">3</a></sup>, using an <code>ensures</code> clause that specifies
the <em>modified</em> type of the reference.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[flux_rs::spec(fn(p: &amp;mut i32[@n]) ensures p:i32[n+1])]
fn incr(p: &amp;mut i32) {
  *p += 1
}</code></pre></pre>
<p>The Flux signature refines the plain Rust one to specify that</p>
<ol>
<li><code>p</code> is a strong reference to an <code>i32</code>,</li>
<li>the <em>input type</em> of <code>*p</code> is <code>i32[n]</code>, and</li>
<li>the <em>output type</em> of <code>*p</code> is <code>i32[n+1]</code>.</li>
</ol>
<p>With this specification, Flux merrily checks <code>test_incr</code>, by
determining that the refinement parameter <code>@n</code> is <code>10</code> and
hence, that upon return <code>x: i32[11]</code>.</p>
<pre><pre class="playground"><code class="language-rust  editable">fn test_incr() {
  let mut z = 10;
  incr_inv(&amp;mut z);
  assert(z == 11);
}</code></pre></pre>
<!-- SLIDE -->
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>To sum up, Flux exploits Rust's ownership mechanisms
to track properties of <em>shared</em> (<code>&amp;T</code>) and <em>mutable</em>
(<code>&amp;mut T</code>) references, and additionally uses (<code>ensures</code>)
clauses to specify when the type itself is <em>changed</em> by a call.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<p>For those familiar with the term, these types are <em>loop invariants</em> <a href="#fr-1-1">↩</a></p>
</li>
<li id="footnote-2">
<p>Setting aside the issue of overflows for now <a href="#fr-2-1">↩</a></p>
</li>
<li id="footnote-3">
<p>Thereby allowing so-called <em>strong updates</em> in the type specifications <a href="#fr-3-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="refining-structs"><a class="header" href="#refining-structs">Refining Structs</a></h1>
<pre><pre class="playground"><code class="language-rust  editable  hidden">#![allow(unused)]
extern crate flux_rs;
use flux_rs::attrs::*;

#[flux_rs::spec(fn (bool[true]))]
fn assert(b: bool) {
    if !b {
        panic!("assertion failed");
    }
}</code></pre></pre>
<p>Previously, we saw how to slap refinements on existing <em>built-in</em>
or <em>primitive</em> Rust types. For example,</p>
<ul>
<li><code>i32[10]</code> specifies the <code>i32</code> that is <em>exactly</em> equal to <code>10</code> and</li>
<li><code>i32{v: 0 &lt;= v &amp;&amp; v &lt; 10}</code> specifies an <code>i32</code> between <code>0</code> and <code>10</code>.</li>
</ul>
<p>Next, lets see how to attach refinements to <em>user-defined</em> types,
so we can precisely define the set of <em>legal</em> values of those types.</p>
<!-- SLIDE -->
<h2 id="positive-integers"><a class="header" href="#positive-integers">Positive Integers</a></h2>
<p>Lets start with an example posted on the <a href="https://github.com/flux-rs/flux/issues/1106">flux gitHub</a>:</p>
<blockquote>
<p>how do you create a Positivei32? I can think of two ways: <code>struct Positivei32 { val: i32, }</code> and struct <code>Positivei32(i32);</code> but I do not know how to apply the refinements for them. I want it to be an invariant that the i32 value is &gt;= 0. How would I do this?</p>
</blockquote>
<p>With flux, you can define the <code>Positivei32</code> type as follows:</p>
<pre><pre class="playground"><code class="language-rust  editable">#[refined_by(n: int)]
#[invariant(n &gt; 0)]
struct Positivei32 {
  #[field(i32[n])]
  val: i32
}</code></pre></pre>
<p>In addition to defining the plain Rust type <code>Positivei32</code>,
the flux refinements say <em>three</em> distinct things.</p>
<ol>
<li>The <code>refined_by(n: int)</code> tells flux to refine each
<code>Positivei32</code> with a special <code>int</code>-sorted <em>index</em> named <code>n</code>,</li>
<li>the <code>invariant(n &gt; 0)</code> says that the index <code>n</code>
is always positive, and,</li>
<li>the <code>field</code> attribute on <code>val</code> says that the
type of the field <code>val</code> is an <code>i32[n]</code>
i.e. is an <code>i32</code> whose exact value is <code>n</code>.</li>
</ol>
<!-- SLIDE -->
<h3 id="creating-positive-integers"><a class="header" href="#creating-positive-integers">Creating Positive Integers</a></h3>
<p>Now, you would create a <code>Positivei32</code> pretty much as you might in Rust:</p>
<pre><pre class="playground"><code class="language-rust  editable">#[spec(fn() -&gt; Positivei32)]
fn mk_positive_1() -&gt; Positivei32 {
  Positivei32 { val: 1 }
}</code></pre></pre>
<p>and flux will prevent you from creating an <em>illegal</em> <code>Positivei32</code>, like</p>
<pre><pre class="playground"><code class="language-rust  editable">#[spec(fn() -&gt; Positivei32)]
fn mk_positive_0() -&gt; Positivei32 {
  Positivei32 { val: 0 }
}</code></pre></pre>
<!-- SLIDE -->
<h3 id="a-constructor"><a class="header" href="#a-constructor">A Constructor</a></h3>
<p><strong>EXERCISE</strong> Consider the following <code>new</code> constructor for <code>Positivei32</code>. Why does flux reject it?
Can you figure out how to fix the <code>spec</code> for the constructor so flux will be appeased?</p>
<pre><pre class="playground"><code class="language-rust  editable">impl Positivei32 {
  pub fn new(val: i32) -&gt; Self {
    Positivei32 { val }
  }
}</code></pre></pre>
<!-- SLIDE -->
<h3 id="a-smart-constructor"><a class="header" href="#a-smart-constructor">A "Smart" Constructor</a></h3>
<p><strong>EXERCISE</strong> Here is a different, constructor that should work
for <em>any</em> input <code>n</code> but which may return <code>None</code> if the input is
invalid. Can you fix the code so that flux accepts <code>new_opt</code>?</p>
<pre><pre class="playground"><code class="language-rust  editable">impl Positivei32 {
  pub fn new_opt(val: i32) -&gt; Option&lt;Self&gt; {
      Some(Positivei32 { val })
  }
}</code></pre></pre>
<!-- SLIDE -->
<h3 id="tracking-the-field-value"><a class="header" href="#tracking-the-field-value">Tracking the Field Value</a></h3>
<p>In addition to letting us constrain the underlying <code>i32</code> to be positive,
the <code>n: int</code> index lets flux precisely <em>track</em> the value of the <code>Positivei32</code>.
For example, we can say that the following function returns a very specific <code>Positivei32</code>:</p>
<pre><pre class="playground"><code class="language-rust  editable">#[spec(fn() -&gt; Positivei32[{n:10}])]
fn mk_positive_10() -&gt; Positivei32 {
  Positivei32 { val: 10 }
}</code></pre></pre>
<p>(When there is a single index, we can just write <code>Positivei32[10]</code>.)</p>
<p>Since the field <code>val</code> corresponds to the <em>tracked index</em>,
flux "knows" what <code>val</code> is from the index, and hence lets us check that</p>
<pre><pre class="playground"><code class="language-rust  editable">#[spec(fn() -&gt; i32[10])]
fn test_ten() -&gt; i32 {
    let p = mk_positive_10(); // p   : Positivei32[{n: 10}]
    let res = p.val;          // res : i32[10]
    res
}</code></pre></pre>
<!-- SLIDE -->
<h3 id="tracking-the-value-in-the-constructor"><a class="header" href="#tracking-the-value-in-the-constructor">Tracking the Value in the Constructor</a></h3>
<p><strong>EXERCISE</strong> Scroll back up, and modify the <code>spec</code> for <code>new</code>
so that the below code verifies. That is, modify the <code>spec</code>
so that it says what the value of <code>val</code> is when <code>new</code> returns
a <code>Positivei32</code>. You will likely need to <em>combine</em> indexes
and constraints as shown in <a href="tutorial/./01-refinements.html#combining-indexes-and-constraints">the example <code>add_points</code></a>.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[spec(fn() -&gt; i32[99])]
fn test_new() -&gt; i32 {
    let p = Positivei32::new(99);
    let res = p.val;
    res
}</code></pre></pre>
<!-- SLIDE -->
<h3 id="field-vs-index"><a class="header" href="#field-vs-index">Field vs. Index?</a></h3>
<p>At this point, you might be wondering why, since <code>n</code> is the value of the field <code>val</code>,
we didn't just name the index <code>val</code> instead of <code>n</code>?</p>
<p>Indeed, we could have named it <code>val</code>.</p>
<p>However, we picked a different name to emphasize that the index is <em>distinct from</em>
the field. The field actually exists at run-time, but in contrast, the index is a
<em>type-level property</em> that only lives at compile-time.</p>
<!-- SLIDE -->
<h2 id="integers-in-a-range"><a class="header" href="#integers-in-a-range">Integers in a Range</a></h2>
<p>Of course, once we can index and constrain a single field, we can do so for many fields.</p>
<p>For instance, suppose we wanted to write a <code>Range</code> type with two fields <code>start</code> and <code>end</code>
which are integers such that <code>start &lt;= end</code>. We might do so as</p>
<pre><pre class="playground"><code class="language-rust  editable">#[refined_by(start: int, end: int)]
#[invariant(start &lt;= end)]
struct Range {
  #[field(i32[start])]
  start: i32,
  #[field(i32[end])]
  end: i32,
}</code></pre></pre>
<p>Note that this time around, we're using the <em>same names</em> for the index as the field
names (even though they are conceptually distinct things).</p>
<!-- SLIDE -->
<h3 id="legal-ranges"><a class="header" href="#legal-ranges">Legal Ranges</a></h3>
<p>Again, the refined <code>struct</code> specification will ensure we only create legal <code>Range</code> values.</p>
<pre><pre class="playground"><code class="language-rust  editable">fn test_range() {
    vec![
        Range { start: 0, end: 10 }, // ok
        Range { start: 15, end: 5 }, // rejected!
    ];
}</code></pre></pre>
<!-- SLIDE -->
<h3 id="a-range-constructor"><a class="header" href="#a-range-constructor">A Range Constructor</a></h3>
<p><strong>EXERCISE</strong> Fix the specification of the <code>new</code>
constructor for <code>Range</code> so that both <code>new</code> and
<code>test_range_new</code> are accepted by flux. (Again,
you will need to <em>combine</em> indexes and constraints
as shown in <a href="tutorial/./01-refinements.html#combining-indexes-and-constraints">the example <code>add_points</code></a>.)</p>
<pre><pre class="playground"><code class="language-rust  editable">impl Range {
    pub fn new(start: i32, end: i32) -&gt; Self {
        Range { start, end }
    }
}

#[spec(fn() -&gt; Range[{start: 0, end: 10}])]
fn test_range_new() -&gt; Range {
    let rng = Range::new(0, 10);
    assert(rng.start == 0);
    assert(rng.end == 10);
    rng
}</code></pre></pre>
<!-- SLIDE -->
<h3 id="combining-ranges"><a class="header" href="#combining-ranges">Combining Ranges</a></h3>
<p>Lets write a function that computes the <em>union</em> of two ranges.
For example, given the range from <code>10-20</code> and <code>15-25</code>, we might
want to return the the union is <code>10-25</code>.</p>
<pre><pre class="playground"><code class="language-rust  editable">fn min(x:i32, y:i32) -&gt; i32 {
  if x &lt; y { x } else { y }
}

fn max(x:i32, y:i32) -&gt; i32 {
  if x &lt; y { y } else { x }
}

fn union(r1: Range, r2: Range) -&gt; Range {
  let start = min(r1.start, r2.start);
  let end = max(r2.end, r2.end);
  Range { start, end }
}</code></pre></pre>
<p><strong>EXERCISE</strong> Can you figure out how to fix the <code>spec</code> for <code>min</code> and <code>max</code>
so that flux will accept that <code>union</code> only constructs legal <code>Range</code> values?</p>
<!-- SLIDE -->
<h2 id="refinement-functions"><a class="header" href="#refinement-functions">Refinement Functions</a></h2>
<p>When <em>code</em> get's more complicated, we like to abstract it into reusable
functions. Flux lets us do the same for refinements too. For example, we
can define refinement-level functions <code>min</code> and <code>max</code> which take <code>int</code>
(not <code>i32</code> or <code>usize</code> but logical <code>int</code>) as input and return that as output.</p>
<pre><pre class="playground"><code class="language-rust  editable">defs! {
    fn min(x: int, y: int) -&gt; int {
        if x &lt; y { x } else { y }
    }
    fn max(x: int, y: int) -&gt; int {
        if x &lt; y { y } else { x }
    }
}</code></pre></pre>
<p>We can now use refinement functions like <code>min</code> and <code>max</code> inside types.
For example, the output type of <code>decr</code> precisely tracks the decremented value.</p>
<pre><pre class="playground"><code class="language-rust  editable">impl Positivei32 {
  #[spec(fn(&amp;Self[@p]) -&gt; Self[max(1, p.n - 1)])]
  fn decr(&amp;self) -&gt; Self {
    let val = if self.val &gt; 1 { self.val - 1 } else { self.val };
    Positivei32 { val }
  }
}

fn test_decr() {
  let p = Positivei32{val: 2}; // p : Positivei32[2]
  assert(p.val == 2);
  let p = p.decr();            // p : Positivei32[1]
  assert(p.val == 1);
  let p = p.decr();            // p : Positivei32[1]
  assert(p.val == 1);
}</code></pre></pre>
<!-- SLIDE -->
<h3 id="combining-ranges-precisely"><a class="header" href="#combining-ranges-precisely">Combining Ranges, Precisely</a></h3>
<p><strong>EXERCISE</strong> The <code>union</code> function that we wrote
above says <em>some</em> <code>Range</code> is returned, but nothing
about <em>what</em> that range actually is! Fix the <code>spec</code>
for <code>union</code> below, so that flux accepts <code>test_union</code> below.</p>
<pre><pre class="playground"><code class="language-rust  editable">impl Range {
  #[spec(fn(&amp;Self[@r1], &amp;Self[@r2]) -&gt; Self)]
  pub fn union(&amp;self, other: &amp;Range) -&gt; Range {
    let start = if self.start &lt; other.start {
        self.start
    } else {
        other.start
    };
    let end = if self.end &lt; other.end {
        other.end
    } else {
        self.end
    };
    Range { start, end }
  }
}

fn test_union() {
  let r1 = Range { start: 10, end: 20 };
  let r2 = Range { start: 15, end: 25 };
  let r3 = r1.union(&amp;r2);
  assert(r3.start == 10);
  assert(r3.end == 25);
}</code></pre></pre>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<p>To conclude, we saw how you can use flux to refine user-defined <code>struct</code> to track,
at the type-level, the values of fields, and to then constrain the sets of <em>legal</em>
values for those structs.</p>
<p>To see a more entertaining example, <a href="https://github.com/flux-rs/flux/blob/f200714dfae5e7c9a3bdf7231191499f56aac45b/tests/tests/pos/surface/date.rs">check out this code</a>
which shows how we can use refinements to ensure that only legal <code>Date</code>s can be constructed
at compile time!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="refining-enums"><a class="header" href="#refining-enums">Refining Enums</a></h1>
<pre><pre class="playground"><code class="language-rust  editable  hidden">#![allow(unused)]
extern crate flux_rs;
use flux_rs::attrs::*;

#[flux_rs::spec(fn (bool[true]))]
fn assert(b: bool) {
    if !b {
        panic!("assertion failed");
    }
}</code></pre></pre>
<p><a href="tutorial/./03-structs.html">Previously</a> we saw how to refine structs to constrain the space
of legal values, for example, to define a <code>Positivei32</code> or a <code>Range</code> <code>struct</code> where
the <code>start</code> was less than or equal to the <code>end</code>. Next, lets see how the same mechanism
can be profitably used to let us check properties of <code>enums</code> at compile time.</p>
<!-- SLIDE -->
<h2 id="failure-is-an-option"><a class="header" href="#failure-is-an-option">Failure is an Option</a></h2>
<p>Rust's type system is really terrific for spotting all
manner of bugs at compile time. However, that just makes
it all the more disheartening to get runtime errors like</p>
<pre><code>thread ... panicked at ... called `Option::unwrap()` on a `None` value
</code></pre>
<p>Lets see how to refine <code>enum</code>'s like <code>Option</code> to
let us <code>unwrap</code> without the anxiety of run-time failure.</p>
<!-- SLIDE -->
<h3 id="a-refined-option"><a class="header" href="#a-refined-option">A Refined Option</a></h3>
<p>To do so, lets define a custom <code>Option</code> type <sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup> that
is indexed by a <code>bool</code> which indicates whether or not
the option is valid (i.e. <code>Some</code> or <code>None</code>):</p>
<pre><pre class="playground"><code class="language-rust  editable">#[refined_by(valid: bool)]
enum Option&lt;T&gt; {
    #[variant((T) -&gt; Option&lt;T&gt;[{valid: true}])]
    Some(T),
    #[variant(Option&lt;T&gt;[{valid: false}])]
    None,
}</code></pre></pre>
<p>As with <code>std::option::Option</code>, we have two variants</p>
<ul>
<li><code>Some</code>, with the "payload" <code>T</code> and</li>
<li><code>None</code>, without.</li>
</ul>
<p>However, we have tricked out the type in two ways.</p>
<ul>
<li>First, we added a <code>bool</code> sorted index that aims to track whether the option is <code>valid</code>;</li>
<li>Second, we used the <code>variant</code> attribute to specify the value of the index for the <code>Some</code> and <code>None</code> cases.</li>
</ul>
<!-- SLIDE -->
<h3 id="constructing-options"><a class="header" href="#constructing-options">Constructing Options</a></h3>
<p>The definition above tells flux that <code>Some(...)</code>
has the refined type <code>Option&lt;...&gt;[{valid: true}]</code>,
and <code>None</code> has the refined type <code>Option&lt;...&gt;[{valid: false}]</code>.</p>
<p><strong>NOTE</strong> When there is a <em>single</em> refinement index, we can skip the <code>{valid:b}</code>
and just write <code>b</code>.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[spec(fn () -&gt; Option&lt;i32&gt;[true])]
fn test_some() -&gt; Option&lt;i32&gt; {
  Option::Some(12)
}

#[spec(fn () -&gt; Option&lt;i32&gt;[false])]
fn test_none() -&gt; Option&lt;i32&gt; {
  Option::None
}</code></pre></pre>
<!-- SLIDE -->
<h3 id="destructing-options-by-pattern-matching"><a class="header" href="#destructing-options-by-pattern-matching">Destructing Options by Pattern Matching</a></h3>
<p>The neat thing about refining variants is that <em>pattern matching</em>
on the <code>enum</code> tells flux what the variant's refinements are.</p>
<p>For example, consider the following implementation of <code>is_some</code></p>
<pre><pre class="playground"><code class="language-rust  editable">impl&lt;T&gt; Option&lt;T&gt; {
  #[spec(fn(&amp;Self[@valid]) -&gt; bool[valid])]
  pub fn is_some(&amp;self) -&gt; bool {
    match self {
      Option::Some(_) =&gt; true,  // self : &amp;Option&lt;..&gt;[true]
      Option::None =&gt; false,    // self : &amp;Option&lt;..&gt;[false]
    }
  }
}</code></pre></pre>
<!-- SLIDE -->
<h3 id="never-do-this"><a class="header" href="#never-do-this">Never Do This!</a></h3>
<p>When working with <code>Option</code> types, or more generally,
with <code>enum</code>s, we often have situations in pattern-match
cases where we "know" that that case will not arise.</p>
<p>Typically we mark those cases with an <code>unreachable!()</code> call.</p>
<p>With flux, we can do even more: we can <em>prove</em>, at compile-time,
that those cases will never, in fact, be executed.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[spec(fn () -&gt; _ requires false)]
fn unreachable() -&gt; ! {
    assert(false);  // flux will prove this is unreachable
    unreachable!(); // panic if we ever get here
}</code></pre></pre>
<p>The <em>precondition</em> <code>false</code> ensures that the <em>only</em> way that
a call to <code>unreachable</code> can be verified is when flux can prove
that the call-site is "dead code".</p>
<pre><pre class="playground"><code class="language-rust  editable">fn test_unreachable(n: usize) {
  let x = 12;           // x : usize[12]
  let x = 12 + n;       // x : usize[12 + n] where 0 &lt;= n
  if x &lt; 12 {
    unreachable();      // impossible, as x &gt;= 12
  }
}</code></pre></pre>
<!-- SLIDE -->
<h3 id="unwrap-without-anxiety"><a class="header" href="#unwrap-without-anxiety">Unwrap Without Anxiety!</a></h3>
<p>Lets use our refined <code>Option</code> to implement a safe <code>unwrap</code> function.</p>
<pre><pre class="playground"><code class="language-rust  editable">impl &lt;T&gt; Option&lt;T&gt; {
  #[spec(fn(Self[true]) -&gt; T)]
  pub fn unwrap(self) -&gt; T {
    match self {
      Option::Some(v) =&gt; v,
      Option::None =&gt; unreachable(),
    }
  }
}</code></pre></pre>
<p>The <code>spec</code> requires that <code>unwrap</code> is <em>only</em> called
with an <code>Option</code> whose (<code>valid</code>) index is <code>true</code>,
i.e. <code>Some(...)</code>.</p>
<p>The <code>None</code> pattern is matched only when the index
is <code>false</code> which is impossible, as it contradicts
the precondition.</p>
<p>Hence, flux concludes that pattern is dead code
(like the <code>x &lt; 12</code> branch is dead code in the
<code>test_unreachable</code> above.)</p>
<!-- SLIDE -->
<h2 id="using-unwrap"><a class="header" href="#using-unwrap">Using <code>unwrap</code></a></h2>
<p>Next, lets see some examples of how to use refined options
to safely <code>unwrap</code>.</p>
<!-- SLIDE -->
<h3 id="safe-division"><a class="header" href="#safe-division">Safe Division</a></h3>
<p>Here's a safe divide-by-zero function that returns an <code>Option&lt;i32&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust  editable">#[spec(fn(n:i32, k:i32) -&gt; Option&lt;i32&gt;)]
pub fn safe_divide(n: i32, k: i32) -&gt; Option&lt;i32&gt; {
  if k &gt; 0 {
    Option::Some(n / k)
  } else {
    Option::None
  }
}</code></pre></pre>
<p><strong>EXERCISE</strong> Why does the test below fail to type check?
Can you fix the <code>spec</code> for <code>safe_divide</code> so flux is happy
with <code>test_safe_divide</code>?</p>
<pre><pre class="playground"><code class="language-rust  editable">fn test_safe_divide() -&gt; i32 {
    safe_divide(10, 2).unwrap()
}</code></pre></pre>
<!-- SLIDE -->
<h3 id="smart-constructors-revisited"><a class="header" href="#smart-constructors-revisited">Smart Constructors Revisited</a></h3>
<p>Recall the <a href="tutorial/./03-structs.html#positive-integers"><code>struct Positivei32</code></a>
and the smart constructor we wrote for it.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[refined_by(n: int)]
#[invariant(n &gt; 0)]
struct Positivei32 {
    #[field(i32[n])]
    val: i32
}

impl Positivei32 {
  #[spec(fn(val: i32) -&gt; Option&lt;Self&gt;)]
  pub fn new(val: i32) -&gt; Option&lt;Self&gt; {
    if val &gt; 0 {
      Option::Some(Positivei32 { val })
    } else {
      Option::None
    }
  }
}</code></pre></pre>
<p><strong>EXERCISE</strong> The code below has a function that
invokes the smart constructor and then <code>unwrap</code>s
the result. Why is flux complaining? Can you fix
the <code>spec</code> of <code>new</code> so that the <code>test_unwrap</code> figure
out how to fix the <code>spec</code> of <code>new</code> so that <code>test_new_unwrap</code>
is accepted?</p>
<pre><pre class="playground"><code class="language-rust  editable">fn test_new_unwrap() {
    Positivei32::new(10).unwrap();
}</code></pre></pre>
<!-- SLIDE -->
<h2 id="typestates-a-refined-timer"><a class="header" href="#typestates-a-refined-timer">TypeStates: A Refined Timer</a></h2>
<p>Lets look a different way to use refined <code>enum</code>s.
On the <a href="https://flux-rs.zulipchat.com/#narrow/channel/486098-general/topic/greetings/near/509911720">flux zulip</a> we were asked
if we could write an <code>enum</code> to represent a <code>Timer</code>
with two variants:</p>
<ul>
<li><code>Inactive</code> indicating that the timer is not running, and</li>
<li><code>CountDown(n)</code> indicating that the timer is counting down from <code>n</code> seconds.</li>
</ul>
<p>Somehow using refinements to ensure that the timer can only
be set to <code>Inactive</code> when <code>n &lt; 1</code>.</p>
<!-- SLIDE -->
<h3 id="refined-timers"><a class="header" href="#refined-timers">Refined Timers</a></h3>
<p>To do so, lets define the <code>Timer</code>, refined with an <code>int</code> index that tracks
the number of remaining seconds.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[flux::refined_by(remaining: int)]
enum Timer {
    #[flux::variant(Timer[0])]
    Inactive,

    #[flux::variant((usize[@n]) -&gt; Timer[n])]
    CountDown(usize)
}</code></pre></pre>
<p>The flux definitions ensure that <code>Timer</code> has two variants</p>
<ul>
<li><code>Inactive</code>, which has a <code>remaining</code> index of <code>0</code>, and</li>
<li><code>CountDown(n)</code>, which has a <code>remaining</code> index of <code>n</code>.</li>
</ul>
<!-- SLIDE -->
<h3 id="timer-implementation"><a class="header" href="#timer-implementation">Timer Implementation</a></h3>
<p>We can now implement the <code>Timer</code> with a constructor and a method to set it to <code>Inactive</code>.</p>
<pre><pre class="playground"><code class="language-rust  editable">impl Timer {
    #[spec(fn (n: usize) -&gt; Timer[n])]
    pub fn new(n: usize) -&gt; Self {
       Timer::CountDown(n)
    }

    #[spec(fn (self: &amp;mut Self[0]))]
    fn deactivate(&amp;mut self) {
        *self = Timer::Inactive
    }
}</code></pre></pre>
<!-- SLIDE -->
<h3 id="deactivate-the-timer"><a class="header" href="#deactivate-the-timer">Deactivate the Timer</a></h3>
<p>Now, you can see that flux will only let us <code>set_inactive</code>
a timer whose countdown is at <code>0</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn test_deactivate() {
  let mut t0 = Timer::new(0);
  t0.deactivate(); // verifies

  let mut t3 = Timer::new(3);
  t3.deactivate(); // rejected
}
<span class="boring">}</span></code></pre></pre>
<!-- SLIDE -->
<h3 id="ticking-the-timer"><a class="header" href="#ticking-the-timer">Ticking the Timer</a></h3>
<p>Here is a function to <code>tick</code> the timer down by one second.</p>
<!-- // #[spec(fn (self: &mut Self[@s]) ensures self: Self[if n > 1 then n-1 else 0])] -->
<pre><pre class="playground"><code class="language-rust  editable">impl Timer {
  #[spec(fn (self: &amp;mut Self[@s]) ensures self: Self)]
  fn tick(&amp;mut self) {
    match self {
      Timer::CountDown(s) =&gt; {
        let n = *s;
        if n &gt; 0 {
          *s = n - 1;
        }
      }
      Timer::Inactive =&gt; {},
    }
  }
}</code></pre></pre>
<p><strong>EXERCISE</strong> Can you fix the <code>spec</code> for <code>tick</code> so that flux accepts the following test?</p>
<pre><pre class="playground"><code class="language-rust  editable">fn test_tick() {
  let mut t = Timer::new(3);
  t.tick();       // should decrement to 2
  t.tick();       // should decrement to 1
  t.tick();       // should decrement to 0
  t.deactivate(); // should set to Inactive
}</code></pre></pre>
<h2 id="summary-3"><a class="header" href="#summary-3">Summary</a></h2>
<p>In this chapter, we saw how you refine an <code>enum</code> with indices, and then specify
the values of the indices for each <code>variant</code>. This let us, for example, determine
whether an <code>Option</code> is <code>Some</code> or <code>None</code> at compile time, and to safely <code>unwrap</code>
the former, and to encode a "typestate" mechanism for a <code>Timer</code> that tracks how
many seconds remain in a countdown, ensuring we only <code>deactivate</code> when the timer
has expired.</p>
<p>You can do various other fun things, like</p>
<ul>
<li>track the <a href="https://github.com/flux-rs/flux/blob/main/tests/tests/pos/enums/list00.rs">length</a> of a linked list or</li>
<li>track the set of <a href="https://github.com/flux-rs/flux/blob/main/tests/tests/pos/enums/list01.rs">elements</a> in the list, or</li>
<li>determine whether an expression is in <a href="tutorial/./10-case-study-anf.html">normal form</a>, or</li>
<li>ensure the layers of a <a href="tutorial/./12-case-study-neural.html">neural network</a>
are composed correctly.</li>
</ul>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<p>In the chapter on <a href="tutorial/06-extern-specs.html">extern specifications</a> we will explain how to "retrofit" these refinements onto the existing <code>std::option::Option</code> type. <a href="#fr-1-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="opaque-types-refined-vectors"><a class="header" href="#opaque-types-refined-vectors">Opaque Types: Refined Vectors</a></h1>
<pre><pre class="playground"><code class="language-rust  editable  hidden">#![allow(unused)]
extern crate flux_rs;
use flux_rs::attrs::*;

#[flux_rs::spec(fn (bool[true]))]
fn assert(b: bool) {
    if !b {
        panic!("assertion failed");
    }
}</code></pre></pre>
<p><a href="https://flux.goto.ucsd.edu/index.html#?demo=vectors.rs">Online demo</a></p>
<p>While <code>rustc</code> has a keen eye for spotting nasty bugs at
compile time, it is not omniscient. We've all groaned in
dismay at seeing deployed code crash with messages like</p>
<pre><code>panicked at 'index out of bounds: the len is ... but the index is ...'
</code></pre>
<p>Next, lets see how flux's <a href="tutorial/./01-refinements.html">refinement</a>
and <a href="tutorial/./02-ownership.html">ownership</a> mechanisms let us write
a <em>refined vector</em> API whose types track vector sizes and
ensure --- at compile time --- that vector accesses cannot
fail at runtime.</p>
<!-- SLIDE -->
<h2 id="refining-vectors-"><a class="header" href="#refining-vectors-">Refining Vectors ...</a></h2>
<p>To track sizes, lets define a <code>struct</code> that
is just a <em>wrapper</em> around the <code>std::vec::Vec</code>
type, but with a refinement index that tracks
the size of the vector.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[opaque]
#[refined_by(len: int)]
pub struct RVec&lt;T&gt; {
    inner: Vec&lt;T&gt;,
}</code></pre></pre>
<!-- SLIDE -->
<h3 id="-to-track-their-size"><a class="header" href="#-to-track-their-size">... to Track their Size</a></h3>
<p>As <a href="tutorial/./03-structs.html">with other structs</a> we're using <code>refined_by</code>
to <em>index</em> the <code>RVec</code> with an <code>int</code> value (that will represent
the vector's length.)</p>
<p>The idea is that</p>
<ul>
<li><code>RVec&lt;i32&gt;[10]</code> represents a vector of <code>i32</code> size 10, and</li>
<li><code>RVec&lt;bool&gt;{v:0 &lt; v}</code> represents a <em>non-empty</em> vector of <code>bool</code>, and</li>
<li><code>RVec&lt;RVec&lt;f32&gt;[n]&gt;[m]</code> represents a vector of vectors of <code>f32</code> of size <code>m</code> and
<em>each of</em> whose elements is a vector of size <code>n</code>.</li>
</ul>
<!-- SLIDE -->
<h3 id="-but-opaquely"><a class="header" href="#-but-opaquely">... but <em>Opaquely</em></a></h3>
<p>The <code>opaque</code> attribute tells flux that we're not
going to <em>directly</em> connect the <code>len</code> to any of
the <code>RVec</code>'s fields' values.</p>
<p>This is quite <em>unlike</em> <a href="tutorial/./03-structs.html"><code>Positivei32</code> example</a>
where the index held the actual value of the field,
or the [<code>Timer</code> example)(./04-enums.md) where the
index held the value of the countdown.</p>
<p>Instead, with an <em>opaque</em> <code>struct</code> the idea is that the value
of the index will be tracked solely by the API for that struct.</p>
<p>Next, lets see how to build such an API for creating and
manipulating <code>RVec</code>, where the length is precisely tracked
in the index.</p>
<!-- SLIDE -->
<h3 id="creating-vectors"><a class="header" href="#creating-vectors">Creating Vectors</a></h3>
<p>I suppose one must start with nothing: the empty vector.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[trusted]
impl&lt;T&gt; RVec&lt;T&gt; {
    #[spec(fn() -&gt; RVec&lt;T&gt;[0])]
    pub fn new() -&gt; Self {
        Self { inner: Vec::new() }
    }
}</code></pre></pre>
<p>The above implements <code>RVec::new</code> as a wrapper around <code>Vec::new</code>.
The <code>#[trusted]</code> attribute tells flux to <em>not check</em> this code,
i.e. to simply <em>trust</em> that the specification is correct.
Indeed, flux <em>cannot</em> check this code.</p>
<p>If you remove the <code>#trusted</code> (do it!) then flux will
complain that you <em>cannot</em> access the <code>inner</code> field
of the opaque <code>struct</code>!</p>
<p>So the only way to use an <code>RVec</code> is to define a "trusted" API,
and then use that in client code, where for example, callers
of <code>RVec::new</code> get back an <code>RVec</code> indexed with <code>0</code> : the empty vector.</p>
<!-- SLIDE -->
<h3 id="pushing-values"><a class="header" href="#pushing-values">Pushing Values</a></h3>
<p>An empty vector is a rather desolate thing.</p>
<p>To be of any use, we need to be able to <code>push</code>
values into it, like so</p>
<pre><pre class="playground"><code class="language-rust  editable">#[trusted]
impl&lt;T&gt; RVec&lt;T&gt; {
    #[spec(fn(self: &amp;mut RVec&lt;T&gt;[@n], T) ensures self: RVec&lt;T&gt;[n+1])]
    pub fn push(&amp;mut self, item: T) {
        self.inner.push(item);
    }
}</code></pre></pre>
<p>The refined type for <code>push</code> says that it takes a <a href="tutorial/./02-ownership.html#borrowing-updatable-references"><em>updatable</em> reference</a> to an <code>RVec&lt;T&gt;</code> of size <code>n</code> and, a value <code>T</code>
and ensures that upon return, the size of <code>self</code> is increased by <code>1</code>.</p>
<h3 id="creating-a-vector-with-push"><a class="header" href="#creating-a-vector-with-push">Creating a Vector with <code>push</code></a></h3>
<p>Lets test that the types are in fact tracking sizes.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[spec(fn () -&gt; RVec&lt;i32&gt;[3])]
fn test_push() -&gt; RVec&lt;i32&gt; {
    let mut v = RVec::new(); // v: RVec&lt;i32&gt;[0]
    v.push(1);               // v: RVec&lt;i32&gt;[1]
    v.push(2);               // v: RVec&lt;i32&gt;[2]
    v.push(3);               // v: RVec&lt;i32&gt;[3]
    v
}</code></pre></pre>
<p><strong>EXERCISE</strong>: Can you correctly implement the code
for <code>zeros</code> so that it typechecks?</p>
<pre><pre class="playground"><code class="language-rust  editable">#[spec(fn(n: usize) -&gt; RVec&lt;i32&gt;[n])]
fn zeros(n:usize) -&gt; RVec&lt;i32&gt; {
    let mut v = RVec::new(); // v: RVec&lt;i32&gt;[0]
    let mut i = 0;
    while i &lt;= n {
        v.push(0);           // v: RVec&lt;i32&gt;[i]
        i += 1;
    }
    v
}</code></pre></pre>
<h3 id="popping-values"><a class="header" href="#popping-values">Popping Values</a></h3>
<p>Not much point stuffing things into a vector if we can't get them out again.
For that, we might implement a <code>pop</code> method that returns the <em>last</em> element
of the vector.</p>
<p>Aha, but what if the vector is empty? You <em>could</em> return an
<code>Option&lt;T&gt;</code> <em>or</em> since we're tracking sizes, we could
<em>require</em> that <code>pop</code> only be called with non-empty vectors.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[trusted]
impl&lt;T&gt; RVec&lt;T&gt; {
    #[spec(fn(self: &amp;mut {RVec&lt;T&gt;[@n] | 0 &lt; n}) -&gt; T
           ensures self: RVec&lt;T&gt;[n-1])]
    pub fn pop(&amp;mut self) -&gt; T {
      self.inner.pop().unwrap()
    }
}</code></pre></pre>
<p>Note that unlike <code>push</code> which works for <em>any</em> <code>RVec&lt;T&gt;[@n]</code>, the <code>pop</code>
method requires that <code>0 &lt; n</code> i.e. that the vector is <em>not</em> empty.</p>
<h3 id="using-the-pushpop-api"><a class="header" href="#using-the-pushpop-api">Using the <code>push/pop</code> API</a></h3>
<p>Now already <code>flux</code> can start checking some code, for example if you <code>push</code> two
elements, then you can <code>pop</code> twice, but flux will reject the third <code>pop</code> at
compile-time</p>
<pre><pre class="playground"><code class="language-rust  editable">fn test_push_pop() {
    let mut vec = RVec::new();   // vec: RVec&lt;i32&gt;[0]
    vec.push(10);                // vec: RVec&lt;i32&gt;[1]
    vec.push(20);                // vec: RVec&lt;i32&gt;[2]
    vec.pop();                   // vec: RVec&lt;i32&gt;[1]
    vec.pop();                   // vec: RVec&lt;i32&gt;[0]
    vec.pop();                   // rejected!
}</code></pre></pre>
<p>In fact, the error message from <code>flux</code> will point to exact condition that
does not hold</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[FLUX]: precondition might not hold
   |
24 |     v.pop();
   |     ^^^^^^^ call site
   |
   = note: a precondition cannot be proved at this call site
note: this is the condition that cannot be proved
   |
78 |     #[spec(fn(self: &amp;mut{RVec&lt;T&gt;[@n] | 0 &lt; n}) -&gt; T
   |                                        ^^^^^
<span class="boring">}</span></code></pre></pre>
<!--
We can use `push` to implement an `rvec!` macro for constructing vectors
and then test that lengths are tracked correctly

<img src="tutorial/../img/test_macro_pop.gif" width="100%"> -->
<!-- SLIDE -->
<h3 id="querying-the-size"><a class="header" href="#querying-the-size">Querying the Size</a></h3>
<p>Perhaps we should <em>peek</em> at the size of the vector
to make sure its not empty <em>before</em> we <code>pop</code> it.</p>
<p>We can do that by writing a <code>len</code> method that returns
a <code>usize</code> corresponding to (and hence, by indexed by)
the size of the input vector</p>
<pre><pre class="playground"><code class="language-rust  editable">#[flux_rs::trusted]
impl&lt;T&gt; RVec&lt;T&gt; {
    #[spec(fn(&amp;RVec&lt;T&gt;[@vec]) -&gt; usize)]
    pub fn len(&amp;self) -&gt; usize {
        self.inner.len()
    }
}</code></pre></pre>
<p><strong>EXERCISE</strong> Can you fix the <code>spec</code> for <code>len</code> so that the code below
verifies, i.e. so that flux "knows" that</p>
<ul>
<li>after two <code>push</code>es, the value returned by <code>.len()</code> is exactly <code>2</code>, and</li>
<li>after two <code>pop</code>s the size is <code>0</code> again.</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable">fn test_len() {
    let mut vec = RVec::new();
    vec.push(10);
    vec.push(20);
    assert(vec.len() == 2);
    vec.pop();
    vec.pop();
    assert(vec.len() == 0);
}</code></pre></pre>
<!-- SLIDE -->
<h2 id="random-access"><a class="header" href="#random-access">Random Access</a></h2>
<p>Of course, vectors are not just <em>stacks</em>, they also allow
<em>random</em> access to their elements which is where those
pesky panics occur, and where the refined vector API
gets rather useful.</p>
<p>Now that we're tracking sizes, we can <em>require</em>
that the method to <code>get</code> an element only be called
with a <em>valid index</em> less than the vector's size</p>
<pre><pre class="playground"><code class="language-rust  editable">impl&lt;T&gt; RVec&lt;T&gt; {
    #[spec(fn(&amp;RVec&lt;T&gt;[@n], i: usize{i &lt; n}) -&gt; &amp;T)]
    pub fn get(&amp;self, i: usize) -&gt; &amp;T {
        &amp;self.inner[i]
    }

    #[spec(fn(&amp;mut RVec&lt;T&gt;[@n], i: usize{i &lt; n}) -&gt; &amp;mut T)]
    pub fn get_mut(&amp;mut self, i: usize) -&gt; &amp;mut T {
        &amp;mut self.inner[i]
    }
}</code></pre></pre>
<!-- SLIDE -->
<h3 id="summing-the-elements-of-an-rvec"><a class="header" href="#summing-the-elements-of-an-rvec">Summing the Elements of an <code>RVec</code></a></h3>
<p><strong>EXERCISE</strong> Can you spot and fix the <em>off-by-one</em> error
in the code below which loops over the elements
of an <code>RVec</code> and sums them up? <sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup></p>
<pre><pre class="playground"><code class="language-rust  editable">fn sum_vec(vec: &amp;RVec&lt;i32&gt;) -&gt; i32 {
    let mut res = 0;
    let mut i = 0;
    while i &lt;= vec.len() {
        res += vec.get(i);
        i += 1;
    }
    sum
}</code></pre></pre>
<!-- SLIDE -->
<h3 id="using-the-index-trait"><a class="header" href="#using-the-index-trait">Using the <code>Index</code> trait</a></h3>
<p>Its a bit of an eyesore to to use <code>get</code> and <code>get_mut</code> directly.</p>
<p>Instead lets implement the <code>Index</code> and <code>IndexMut</code>
traits for <code>RVec</code> which allows us to use the <code>[..]</code>
operator to access elements</p>
<pre><pre class="playground"><code class="language-rust  editable">impl&lt;T&gt; std::ops::Index&lt;usize&gt; for RVec&lt;T&gt; {
    type Output = T;
    #[spec(fn(&amp;RVec&lt;T&gt;[@n], i:usize{i &lt; n}) -&gt; &amp;T)]
    fn index(&amp;self, index: usize) -&gt; &amp;T {
        self.get(index)
    }
}

impl&lt;T&gt; std::ops::IndexMut&lt;usize&gt; for RVec&lt;T&gt; {
    #[spec(fn(&amp;mut RVec&lt;T&gt;[@n], i:usize{i &lt; n}) -&gt; &amp;mut T)]
    fn index_mut(&amp;mut self, index: usize) -&gt; &amp;mut T {
        self.get_mut(index)
    }
}</code></pre></pre>
<!-- SLIDE -->
<h3 id="summing-nicely"><a class="header" href="#summing-nicely">Summing Nicely</a></h3>
<p>Now the above <code>vec_sum</code> example looks a little nicer</p>
<pre><pre class="playground"><code class="language-rust  editable">fn sum_vec_fixed(vec: &amp;RVec&lt;i32&gt;) -&gt; i32 {
    let mut res = 0;
    let mut i = 0;
    while i &lt; vec.len() {
        res += vec[i]
        i += 1;
    }
    sum
}</code></pre></pre>
<!-- SLIDE -->
<h2 id="memoization"><a class="header" href="#memoization">Memoization</a></h2>
<p>Lets put the whole API to work in this "memoized" version of the fibonacci
function which uses a vector to store the results of previous calls</p>
<pre><pre class="playground"><code class="language-rust  editable">pub fn fib(n: usize) -&gt; i32 {
    let mut r = RVec::new();
    let mut i = 0;
    while i &lt; n {
        if i == 0 {
            r.push(0);
        } else if i == 1 {
            r.push(1);
        } else {
            let a = r[i - 1];
            let b = r[i - 2];
            r.push(a + b);
        }
        i += 1;
    }
    r.pop()
}</code></pre></pre>
<p><strong>EXERCISE</strong> Flux is unhappy with the <code>pop</code> at the end of the function
which returns the <em>last</em> value as the result: it thinks the vector
<em>may be empty</em> and so the <code>pop</code> call may fail ... Can you spot and fix
the problem?</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[FLUX]: precondition might not hold
  --&gt; src/vectors.rs:40:5
   |
40 |     r.pop()
   |     ^^^^^^^
<span class="boring">}</span></code></pre></pre>
<!-- Indeed, we missed a "corner" case -- when `n` is `0` we skip the loop and
so the vector is empty! Once we add a test for that, flux is happy.

<img src="tutorial/../img/fib.gif" width="100%"> -->
<!-- SLIDE -->
<h2 id="binary-search"><a class="header" href="#binary-search">Binary Search</a></h2>
<p>As a last example, lets look at a simplified version of the
<a href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#2423-2425"><code>binary_search</code> method from <code>std::vec</code></a>, into which
we've snuck a tiny little bug</p>
<pre><pre class="playground"><code class="language-rust  editable">pub fn binary_search(vec: &amp;RVec&lt;i32&gt;, x: i32) -&gt; Result&lt;usize, usize&gt; {
    let mut size = vec.len();
    let mut left = 0;
    let mut right = size;
    while left &lt;= right {
        let mid = left + size / 2;
        let val = vec[mid];
        if val &lt; x {
            left = mid + 1;
        } else if x &lt; val {
            right = mid;
        } else {
            return Ok(mid);
        }
        size = right - left;
    }
    Err(left)
}</code></pre></pre>
<p>Flux complains in <em>two</em> places</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[FLUX]: precondition might not hold
   --&gt; src/vectors.rs:152:19
    |
152 |         let val = vec[mid];
    |                   ^^^^^^^^ call site
    |
    = note: a precondition cannot be proved at this call site
note: this is the condition that cannot be proved
   --&gt; src/rvec.rs:189:44
    |
189 |     #[spec(fn(&amp;RVec&lt;T&gt;[@n], usize{v : v &lt; n}) -&gt; &amp;T)]
    |                                       ^^^^^

error[FLUX]: arithmetic operation may overflow
   --&gt; src/vectors.rs:160:9
    |
160 |         size = right - left;
    |         ^^^^^^^^^^^^^^^^^^^
<span class="boring">}</span></code></pre></pre>
<ul>
<li>
<p>The vector access may be <em>unsafe</em> as <code>mid</code> could be out of bounds!</p>
</li>
<li>
<p>The <code>size</code> variable may <em>underflow</em> as <code>left</code> may exceed <code>right</code>!</p>
</li>
</ul>
<p><strong>EXERCISE</strong> Can you the spot off-by-one and figure out a fix?</p>
<h2 id="summary-4"><a class="header" href="#summary-4">Summary</a></h2>
<p>Well then. We just saw how Flux's index and constraint
mechanisms combine with Rust's ownership to let us write
a <em>refined vector API</em> that ensures the safety of all
accesses at compile time.</p>
<p>These mechanisms are <em>compositional</em> : we can use standard
type machinery to build up compound structures and APIs from
simple ones, as we will see when we use <code>RVec</code> to implment
<a href="tutorial/./10-case-study-sparse.html">sparse matrices</a> and a small
<a href="tutorial/./12-case-study-neural.html">neural network</a> library.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<p>Why not use an iterator? We'll get there in <a href="tutorial/./07-traits.html">due course</a>! <a href="#fr-1-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="const-generics"><a class="header" href="#const-generics">Const Generics</a></h1>
<p><a href="https://flux.goto.ucsd.edu/index.html#?demo=arrays.rs">Online demo</a></p>
<p>Rust has a built-in notion of <em>arrays</em> : collections of objects of
the same type <code>T</code> whose size is known at compile time. The fact that
the sizes are known allows them to be allocated contiguously in memory,
which makes for fast access and manipulation.</p>
<p>When I asked ChatGPT what arrays were useful for, it replied
with several nice examples, including low-level systems programming (e.g.
packets of data represented as <code>struct</code>s with array-valued fields), storing configuration data, or small sets of related values (e.g. RGB values for a pixel).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Pixel = [u8; 3]; // RGB values

let pix0: Pixel = [255,   0, 127];
let pix1: Pixel = [  0, 255, 127];
<span class="boring">}</span></code></pre></pre>
<h2 id="compile-time-safety"><a class="header" href="#compile-time-safety">Compile-time Safety...</a></h2>
<p>As the size of the array is known at compile time, Rust can make sure that
we don't <em>create</em> arrays of the wrong size, or <em>access</em> them out of bounds.</p>
<p>For example, <code>rustc</code> will grumble if you try to make a <code>Pixel</code> with 4 elements:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   |
52 | let pix2 : Pixel = [0,0,0,0];
   |            -----   ^^^^^^^^^ expected an array with a fixed size of 3 elements, found one with 4 elements
   |            |
   |            expected due to this
<span class="boring">}</span></code></pre></pre>
<p>Similarly, <code>rustc</code> will wag a finger if you try to access a <code>Pixel</code> at an invalid index.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   |
54 |  let blue0 = pix0[3];
   |              ^^^^^^^ index out of bounds: the length is 3 but the index is 3
   |
<span class="boring">}</span></code></pre></pre>
<h2 id="-run-time-panic"><a class="header" href="#-run-time-panic">... Run-time Panic!</a></h2>
<p>However, the plain type system works only upto a point. For example, consider the
following function to compute the average <code>color</code> value of a collection of <code>&amp;[Pixel]</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn average_color(pixels: &amp;[Pixel], i: usize) -&gt; u64 {
    let mut sum = 0;
    for p in pixels {
        sum += p[i] as u64;
    }
    sum / pixels.len() as u64
}
<span class="boring">}</span></code></pre></pre>
<p>Now, <code>rustc</code> will not complain about the above code, even though it may panic if
<code>color</code> is out of bounds (or of course, if the slice <code>pixels</code> is empty!).
For example, the following code</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let pixels = [ [255, 0, 0], [0, 255, 0], [0, 0, 255] ];
    let avg = average(&amp;pixels, 3);
    println!("Average: {}", avg);
}</code></pre></pre>
<p>panics at runtime:</p>
<pre><code>thread 'main' panicked ... index out of bounds: the len is 3 but the index is 3
</code></pre>
<h2 id="refined-compile-time-safety"><a class="header" href="#refined-compile-time-safety">Refined Compile-time Safety</a></h2>
<p>Fortunately, <code>flux</code> knows about the sizes of arrays and slices. At compile time,
<code>flux</code> warns about two possible errors in <code>average_color</code></p>
<img src="tutorial/../img/04-arrays-average-error.png" width="100%">
<ol>
<li>The index <code>i</code> may be out of bounds when accessing <code>p[i]</code> and</li>
<li>The division can panic as <code>pixels</code> may be empty (i.e. have length <code>0</code>).</li>
</ol>
<p>We can fix these errors by requiring that the input</p>
<ul>
<li><code>i</code> be a valid color index, i.e. <code>i &lt; 3</code> and</li>
<li><code>pixels</code> be non-empty, i.e. have size <code>n</code> where <code>n &gt; 0</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[sig(fn(pixels: &amp;[Pixel][@n], i:usize{i &lt; 3}) -&gt; u64 requires n &gt; 0)]
<span class="boring">}</span></code></pre></pre>
<img src="tutorial/../img/04-arrays-average-fix.gif" width="100%">
<h2 id="const-generics-1"><a class="header" href="#const-generics-1">Const Generics</a></h2>
<p>Rust also lets us write arrays that are <em>generic</em> over the size. For example,
suppose we want to take two input arrays <code>x</code> and <code>y</code> of the same size <code>N</code> and
compute their dot product. We can write</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn dot&lt;const N:usize&gt;(x: [f32;N], y: [f32;N]) -&gt; f32 {
    let mut sum = 0.0;
    for i in 0..N {
        sum += x[i] * y[i];
    }
    sum
}
<span class="boring">}</span></code></pre></pre>
<p>This is very convenient because <code>rustc</code> will prevent us from calling <code>dot</code> with
arrays of different sizes, for example we get a compile-time error</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   |
68 |     dot([1.0, 2.0], [3.0, 4.0, 5.0]);
   |     ---             ^^^^^^^^^^^^^^^ expected an array with a fixed size of 2 elements, found one with 3 elements
   |     |
   |     arguments to this function are incorrect
   |
<span class="boring">}</span></code></pre></pre>
<p>However, suppose we wanted to compute the <code>dot</code> product of just the first <code>k</code> elements</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn dot_k&lt;const N:usize&gt;(x: [f32;N], y: [f32;N], k: usize) -&gt; f32 {
    let mut sum = 0.0;
    for i in 0..k {
        sum += x[i] * y[i];
    }
    sum
}
<span class="boring">}</span></code></pre></pre>
<p>Now, unfortunately, <code>rustc</code> will not prevent us from calling <code>dot_k</code> with <code>k</code> set to a value that is too large!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>thread 'main' panicked at ... index out of bounds: the len is 2 but the index is 2
<span class="boring">}</span></code></pre></pre>
<p>Yikes.</p>
<h2 id="refined-const-generics"><a class="header" href="#refined-const-generics">Refined Const Generics</a></h2>
<p>Fortunately, <code>flux</code> understands const-generics as well!</p>
<p>First off, it warns us about the fact that the accesses with the index may be out of bounds.</p>
<img src="tutorial/../img/04-arrays-dotk-error.png" width="100%">
<p>We can fix it in two ways.</p>
<ul>
<li>The <strong>permissive</strong> approach is to accept any <code>k</code> but restrict the iteration to the valid elements</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn dot_k&lt;const N:usize&gt;(x: [f32;N], y: [f32;N], k: usize) -&gt; f32 {
    let mut sum = 0.0;
    let n = if k &lt; N { k } else { N };
    for i in 0..n {
        sum += x[i] * y[i];
    }
    sum
}
<span class="boring">}</span></code></pre></pre>
<img src="tutorial/../img/04-arrays-dotk-permissive.gif" width="100%">
<ul>
<li>The <strong>strict</strong> approach is to require that <code>k</code> be less than or equal to <code>N</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[sig(fn(x: [f32;N], y: [f32;N], k:usize{k &lt;= N}) -&gt; f32)]
fn dot_k&lt;const N:usize&gt;(x: [f32;N], y: [f32;N], k: usize) -&gt; f32 {
    let mut sum = 0.0;
    for i in 0..k {
        sum += x[i] * y[i];
    }
    sum
}
<span class="boring">}</span></code></pre></pre>
<img src="tutorial/../img/04-arrays-dotk-strict.gif" width="100%">
<p>Do you understand why</p>
<p>(1) Adding the type signature moved the error from the body of <code>dot_k</code> into the call-site inside <code>test</code>?
(2) Then editing <code>test</code> to call <code>dot_k</code> with <code>k=2</code> fixed the error?</p>
<h2 id="summary-5"><a class="header" href="#summary-5">Summary</a></h2>
<p>Rust's (sized) arrays are great, and <code>flux</code>'s refinements make them even better,
by ensuring indices are guaranteed to be within the arrays bounds. Const generics
let us write functions that are polymorphic over array sizes, and again, refinements
let us precisely track those sizes to prevent out-of-bounds errors!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extern-specifications"><a class="header" href="#extern-specifications">Extern Specifications</a></h1>
<pre><pre class="playground"><code class="language-rust  editable">#![feature(allocator_api)]
#![allow(unused)]
extern crate flux_rs;
use flux_rs::{attrs::*, extern_spec};
use std::alloc::{Allocator, Global};
use std::mem::swap;</code></pre></pre>
<pre><pre class="playground"><code class="language-rust  editable  hidden">#[spec(fn (bool[true]))]
fn assert(b: bool) {
    if !b {
        panic!("assertion failed");
    }
}</code></pre></pre>
<p>No man is an island.</p>
<p>Every substantial Rust code base will make use
of <em>external crates</em>. To <em>check</em> properties of
such code bases, Flux requires some way to reason
about the uses of the external crate's APIs.</p>
<p>Let's look at how Flux lets you write
<em>assumptions</em><sup class="footnote-reference" id="fr-assumption-1"><a href="#footnote-assumption">1</a></sup> about the behavior of those
libraries via <em>extern specifications</em> (abbreviated to
<em>extern-specs</em>) which can then let us check facts about
the uses of the external crate's APIs.</p>
<p>To this end, flux lets you write extern-specs for</p>
<ol>
<li>Functions,</li>
<li>Structs,</li>
<li>Enums,</li>
<li>Traits and their Impls.</li>
</ol>
<p>In this chapter, we'll look at the first three,
and then we'll see how the idea <a href="tutorial/./08-traits.html">extends to traits
and their implementations</a>.</p>
<h2 id="extern-specs-for-functions"><a class="header" href="#extern-specs-for-functions">Extern Specs for Functions</a></h2>
<p>As a first example, lets see how to write an extern spec for
the function <code>std::mem::swap</code>.</p>
<h3 id="using-extern-functions"><a class="header" href="#using-extern-functions">Using Extern Functions</a></h3>
<p>Lets write a little test that creates to references and swaps them</p>
<pre><pre class="playground"><code class="language-rust editable">pub fn test_swap() {
    let mut x = 5;
    let mut y = 10;
    std::mem::swap(&amp;mut x, &amp;mut y);
    assert(x == 10);
    assert(y == 5);
}</code></pre></pre>
<p>Now, if you push the <strong>play button</strong> you should see that Flux cannot prove
the two <code>assert</code>s. The little red squiggles indicate it does not know that
after the <code>swap</code> the values of <code>x</code> and <code>y</code> are swapped to <code>10</code> and <code>5</code>, as,
well, it has no idea about how <code>swap</code> behaves!</p>
<h3 id="writing-extern-specs"><a class="header" href="#writing-extern-specs">Writing Extern Specs</a></h3>
<p>We can fill this gap in flux's understanding by providing
an <strong>extern-spec</strong>  that gives flux a refined type
specification for <code>swap</code></p>
<pre><pre class="playground"><code class="language-rust editable">#[extern_spec]
// UNCOMMENT THIS LINE to verify `test_swap`
// #[spec(fn(x: &amp;mut T[@vx], y: &amp;mut T[@vy]) ensures x: T[vy], y: T[vx])]
fn swap&lt;T&gt;(a: &amp;mut T, b: &amp;mut T);</code></pre></pre>
<p><strong>The refined specification</strong> says that <code>swap</code> takes as input
two <em>mutable</em> references <code>x</code> and <code>y</code> that refer to values of
type <code>T</code> with respective indices <code>vx</code> and <code>vy</code>. Upon finishing,
the types referred to by <code>x</code> and <code>y</code> are "swapped".</p>
<p>Now, if you uncomment and push play, flux will verify <code>test_swap</code> as
it knows that at the call-site, <code>vx</code> and <code>vy</code> are respectively <code>5</code> and <code>10</code>.</p>
<h3 id="features-of-extern-spec-functions"><a class="header" href="#features-of-extern-spec-functions">Features of Extern Spec Functions</a></h3>
<p>Note two things about the <code>extern_spec</code> specification.</p>
<ol>
<li>First, up at the top, we had to import the <code>extern_spec</code> macro,
implemented in the <code>flux_rs</code> crate,</li>
<li>Second, importantly, we <em>do not write an implementation</em> for the function,
as that is going to be taken from <code>std::mem</code>. Instead, we're just telling
flux to use the (uncommented) type specification when checking clients.</li>
</ol>
<h3 id="getting-the-length-of-a-slice"><a class="header" href="#getting-the-length-of-a-slice">Getting the Length of a Slice</a></h3>
<p>Here is a function below that returns the <code>first</code> (well, <code>0</code>th)
element of a slice of <code>u32</code>s.</p>
<pre><pre class="playground"><code class="language-rust editable">fn first(slice: &amp;[u32]) -&gt; Option&lt;u32&gt; {
    let n = slice.len();
    if n &gt; 0 {
        Some(slice[0])
    } else {
        None
    }
}</code></pre></pre>
<p><strong>EXERCISE</strong> Unfortunately, flux does not know what <code>slice.len()</code> returns, and
so, cannot verify that the access <code>slice[0]</code> is safe! Can you help
it by <em>fixing</em> the <code>extern_spec</code> for the method shown below?
You might want to refresh your memory about the meaning of
<code>&amp;[T][@n]</code> by quickly skimming the previous chapter on the <a href="tutorial/./06-consts.html#refined-compile-time-safety">sizes of arrays
and slices</a>.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[extern_spec]
impl&lt;T&gt; [T] {
    #[spec(fn(&amp;[T][@n]) -&gt; usize)]
    fn len(v: &amp;[T]) -&gt; usize;
}</code></pre></pre>
<h2 id="extern-specs-for-enums-option"><a class="header" href="#extern-specs-for-enums-option">Extern Specs for Enums: <code>Option</code></a></h2>
<p>In the <a href="tutorial/./04-enums.html">chapter on enums</a> we saw how you can
refine <code>enum</code> types with extra indices that track extra information
about the underlying value. For example, we saw how to implement
a <a href="tutorial/./04-enums.html#a-refined-option">refined Option</a> that is indexed
by a boolean that tracks whether the value is <code>Some</code> (and hence, safe
to <code>unwrap</code>)or <code>None</code>.</p>
<p>The <code>extern_spec</code> mechanism lets us do the same thing, but directly on
<code>std::option::Option</code>. To do so we need only</p>
<ol>
<li>write extern-specs for the <strong>enum definition</strong> that add the indices
and connect them to the variant constructors,</li>
<li>write extern-specs for the <strong>method signatures</strong> that let us use the
indices to describe a refined API that is used to check client code.</li>
</ol>
<h3 id="extern-specs-for-the-type-definition"><a class="header" href="#extern-specs-for-the-type-definition">Extern Specs for the Type Definition</a></h3>
<p>First, lets add the <code>bool</code> index to the <code>Option</code> type definition.</p>
<pre><pre class="playground"><code class="language-rust editable">#[extern_spec]
#[refined_by(valid: bool)]
enum Option&lt;T&gt; {
    #[variant(Option&lt;T&gt;[{valid: false}])]
    None,
    #[variant((T) -&gt; Option&lt;T&gt;[{valid: true}])]
    Some(T),
}</code></pre></pre>
<p>As you might have noticed, this bit is <em>identical</em>
to the refined version of <code>Option</code> that we saw in
the <a href="tutorial/./04-enums.html#a-refined-option">chapter on enums</a>,
except for the <code>#[extern_spec]</code> topping.</p>
<h3 id="using-the-type-definition"><a class="header" href="#using-the-type-definition">Using the Type Definition</a></h3>
<p>Adding the above "retrofits" the <code>bool</code> index directly
into the <code>std::option::Option</code> type. So, for example
we can write</p>
<pre><pre class="playground"><code class="language-rust editable">#[spec(fn () -&gt; Option&lt;i32&gt;[{valid: true}])]
fn test_some() -&gt; Option&lt;i32&gt; {
    Some(42)
}

#[spec(fn () -&gt; Option&lt;i32&gt;[{valid: false}])]
fn test_none() -&gt; Option&lt;i32&gt; {
    None
}</code></pre></pre>
<p><strong>TIP:</strong> When there is a single field like <code>valid</code>
you can drop it, and just write <code>Option&lt;i32&gt;[true]</code>
or <code>Option&lt;i32&gt;[false]</code>.</p>
<h3 id="extern-specs-for-impl-methods"><a class="header" href="#extern-specs-for-impl-methods">Extern Specs for Impl Methods</a></h3>
<p>The extern specs become especially useful when we use them to refine
the methods that <code>impl</code>ement various key operations on <code>Option</code>s.</p>
<p>To do so, we can make an <code>extern_spec</code> <code>impl</code> for <code>Option</code>, much like
we did for slices, <a href="tutorial/07-externs.html#getting-the-length-of-a-slice">back here</a>.</p>
<pre><pre class="playground"><code class="language-rust editable">#[extern_spec]
impl&lt;T&gt; Option&lt;T&gt; {
    #[sig(fn(&amp;Option&lt;T&gt;[@b]) -&gt; bool[b])]
    const fn is_some(&amp;self) -&gt; bool;

    #[sig(fn(&amp;Option&lt;T&gt;[@b]) -&gt; bool[!b])]
    const fn is_none(&amp;self) -&gt; bool;

    #[sig(fn(Option&lt;T&gt;[true]) -&gt; T)]
    const fn unwrap(self) -&gt; T;
}</code></pre></pre>
<p>The definition looks rather like the actual one,
except that it wears the <code>#[extern_spec]</code> attribute
on top, and the methods have no definitions, as we
want to use those from the extern crate, in this case,
the standard library.</p>
<p>Notice that the spec for</p>
<ul>
<li><code>is_some</code> returns <code>true</code> if the input <code>Option</code> was indeed <code>valid</code>, i.e. was a <code>Some(..)</code>;</li>
<li><code>is_none</code> returns <code>true</code> if the input <code>Option</code> was <em>not</em> <code>valid</code>, i.e. was a <code>None</code>.</li>
</ul>
<h3 id="using-extern-method-specifications"><a class="header" href="#using-extern-method-specifications">Using Extern Method Specifications</a></h3>
<p>We can test these new specifications out in our client code.</p>
<pre><pre class="playground"><code class="language-rust editable">fn test_opt_specs(){
    let a = Some(42);
    assert(a.is_some());
    let b: Option&lt;i32&gt; = None;
    assert(b.is_none());
}</code></pre></pre>
<h3 id="safely-unwrapping"><a class="header" href="#safely-unwrapping">Safely Unwrapping</a></h3>
<p>Of course, we all know that we <em>shouldn't</em> directly use <code>unwrap</code>.
However, sometimes, its ok, if we somehow <em>know</em> that the value
is indeed a valid <code>Some(..)</code>. The refined type for <code>unwrap</code> keeps
us honest with a <strong>precondition</strong> that tells flux that it should
<strong>only</strong> be invoked when the underlying <code>Option</code> can be provably
<code>valid</code>.</p>
<pre><pre class="playground"><code class="language-rust editable">#[spec(fn (n:u32) -&gt; Option&lt;u8&gt;)]
fn into_u8(n: u32) -&gt; Option&lt;u8&gt; {
   if n &lt;= 255 {
       Some(n as u8)
   } else {
       None
   }
}

fn test_unwrap() -&gt; u8 {
    into_u8(42).unwrap()
}</code></pre></pre>
<p><strong>EXERCISE</strong> The function <code>test_unwrap</code> above
merrily <code>unwrap</code>s the result of the call <code>into_u8</code>.
Flux is unhappy and flags an error even though surely
the call will not panic! The trouble is that the "default"
<code>spec</code> for <code>into_u8</code> -- the Rust type -- says it can
return <em>any</em> <code>Option&lt;i32&gt;</code>, including those that might
well blow up <code>unwrap</code>. Can you fix the <code>spec</code> for <code>into_u8</code>
so that flux verifies <code>test_unwrap</code>?</p>
<h3 id="a-safe-division-function"><a class="header" href="#a-safe-division-function">A Safe Division Function</a></h3>
<p>Lets write a safe-division function, that checks if the divisor
is non-zero before doing the division.</p>
<pre><pre class="playground"><code class="language-rust editable">#[spec(fn (num: u32, denom: u32) -&gt; Option&lt;u32[num / denom]&gt;)]
pub fn safe_div(num: u32, denom: u32) -&gt; Option&lt;u32&gt; {
    if denom == 0 {
        None
    } else {
        Some(num / denom)
    }
}</code></pre></pre>
<p><strong>EXERCISE</strong> The client <code>test_safe_div</code> shown below is certainly it is safe to
divide by two! Alas, Flux thinks otherwise: it cannot determine that output of
<code>safe_div</code> may be safely <code>unwrap</code>ped. Can you figure out how to fix the specification
for <code>safe_div</code> so that the code below verifies?</p>
<pre><pre class="playground"><code class="language-rust editable">pub fn test_safe_div() {
    let res = safe_div(42, 2).unwrap();
    assert(res == 21);
}</code></pre></pre>
<h2 id="extern-specs-for-structs-vec"><a class="header" href="#extern-specs-for-structs-vec">Extern Specs for Structs: <code>Vec</code></a></h2>
<p>Previously, we saw how to define a <em>new</em> type <code>RVec&lt;T&gt;</code>
for <a href="tutorial/./05-vectors.html">refined vectors</a> and to write
an API that let us track the vector's size, and hence
check the safety of vector accesses at compile time.
Next, lets see how we can use <code>extern_spec</code> to implement
(most of) the refined API directly on structs like
<code>std::vec::Vec</code> which are defined in external crates.</p>
<h3 id="extern-specs-for-the-type-definition-1"><a class="header" href="#extern-specs-for-the-type-definition-1">Extern Specs for the Type Definition</a></h3>
<p>As with <code>enum</code>s we start by sprinkling refinement
indices on the <code>struct</code> definition. Since we want
to track sizes, lets write</p>
<pre><pre class="playground"><code class="language-rust editable">#[extern_spec]
#[refined_by(len: int)]
#[invariant(0 &lt;= len)]
struct Vec&lt;T, A: Allocator = Global&gt;;</code></pre></pre>
<h3 id="extern-invariants"><a class="header" href="#extern-invariants">Extern Invariants</a></h3>
<p>Note that we can additionally attach <strong>invariants</strong> to the <code>struct</code>
definition, which correspond to facts that are <em>always</em> true about
the indices, for example, that the <code>len</code> of a <code>Vec</code> is always non-negative.</p>
<h3 id="extern-structs-are-opaque"><a class="header" href="#extern-structs-are-opaque">Extern <code>struct</code>s are Opaque</a></h3>
<p>Unlike with <code>enum</code>, the <code>extern_spec</code> is oblivious
to the <em>internals</em> of the <code>struct</code>. That is flux
assumes that the fields are all "private", and so the
refinements must be tracked solely using the <em>methods</em>
used to construct and manipulate the <code>struct</code>.</p>
<p>The simplest of these is the one that births an <em>empty</em> <code>Vec</code></p>
<pre><pre class="playground"><code class="language-rust editable">#[extern_spec]
impl&lt;T&gt; Vec&lt;T&gt; {
    #[spec(fn() -&gt; Vec&lt;T&gt;[0])]
    fn new() -&gt; Vec&lt;T&gt;;
}</code></pre></pre>
<p>We can test this out by creating an empty vector</p>
<pre><pre class="playground"><code class="language-rust editable">#[spec(fn () -&gt; Vec&lt;i32&gt;[0])]
fn test_new() -&gt; Vec&lt;i32&gt; {
    Vec::new()
}</code></pre></pre>
<h3 id="extern-specs-for-impl-methods-1"><a class="header" href="#extern-specs-for-impl-methods-1">Extern Specs for Impl Methods</a></h3>
<p>Lets beef up our refined <code>Vec</code> API with a few more methods
like <code>push</code>, <code>pop</code>, <code>len</code> and so on.</p>
<p>We might be tempted to just bundle them together with <code>new</code>
in the <code>impl</code> above, but it is important to Flux that the
the <code>extern_spec</code> implementations <strong>mirror the original
implementations</strong> so that Flux can accurately match (i.e. "resolve")
the <code>extern_spec</code> method with the original method, and thus,
attach the specification to uses of the original method.</p>
<p>As it happens, <code>push</code> and <code>pop</code> are defined in a <em>separate</em>
<code>impl</code> block, parameterized by a generic <code>A: Allocator</code>, so
our <code>extern_spec</code> mirrors this block:</p>
<pre><pre class="playground"><code class="language-rust  editable">#[extern_spec]
impl&lt;T, A: Allocator&gt; Vec&lt;T, A&gt; {
    #[spec(fn(self: &amp;mut Vec&lt;T, A&gt;[@n], T)
           ensures self: Vec&lt;T, A&gt;[n+1])]
    fn push(&amp;mut self, value: T);

    #[spec(fn(self: &amp;mut Vec&lt;T, A&gt;[@n]) -&gt; Option&lt;T&gt;
           ensures self: Vec&lt;T, A&gt;[if n &gt; 0 { n-1 } else { 0 }])]
    fn pop(&amp;mut self) -&gt; Option&lt;T&gt;;

    #[spec(fn(self: &amp;Vec&lt;T, A&gt;[@n]) -&gt; usize[n])]
    fn len(&amp;self) -&gt; usize;

    #[spec(fn(self: &amp;Vec&lt;T, A&gt;) -&gt; bool)]
    fn is_empty(&amp;self) -&gt; bool;
}</code></pre></pre>
<h3 id="constructing-vectors"><a class="header" href="#constructing-vectors">Constructing Vectors</a></h3>
<p>Lets take the refined <code>vec</code> API out for a spin.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[spec(fn() -&gt; Vec&lt;i32&gt;[3])]
pub fn test_push() -&gt; Vec&lt;i32&gt; {
    let mut res = Vec::new();   // res: Vec&lt;i32&gt;[0]
    res.push(10);               // res: Vec&lt;i32&gt;[1]
    res.push(20);               // res: Vec&lt;i32&gt;[2]
    res.push(30);               // res: Vec&lt;i32&gt;[3]
    assert(res.len() == 3);
    res
}</code></pre></pre>
<p>Flux uses the refinements to type <code>res</code> as a 0-sized <code>Vec&lt;i32&gt;[0]</code>.
Each subsequent <code>push</code> <a href="tutorial/./02-ownership.html#borrowing-updatable-references">updates the reference's type</a>
by increasing the size by one.
Finally, the <code>len</code> returns the size at that point, <code>3</code>, thereby
proving the assert.</p>
<h3 id="testing-emptiness"><a class="header" href="#testing-emptiness">Testing Emptiness</a></h3>
<p><strong>EXERCISE</strong> Can you fix the spec for <code>is_empty</code> above so that the
two assertions below are verified?</p>
<pre><pre class="playground"><code class="language-rust  editable">fn test_is_empty() {
   let v0 = test_new();
   assert(v0.is_empty());

   let v1 = test_push();
   assert(!v1.is_empty());
}</code></pre></pre>
<h3 id="the-refined-vec-macro"><a class="header" href="#the-refined-vec-macro">The Refined <code>vec!</code> Macro</a></h3>
<p>The ubiquitous <code>vec!</code> macro internally allocates a slice
and then calls <code>into_vec</code> to create a <code>Vec</code>.</p>
<pre><pre class="playground"><code class="language-rust editable">#[extern_spec]
impl&lt;T&gt; [T] {
    #[spec(fn(self: Box&lt;[T], A&gt;) -&gt; Vec&lt;T, A&gt;)]
    fn into_vec&lt;A&gt;(self: Box&lt;[T], A&gt;) -&gt; Vec&lt;T, A&gt;
    where
        A: Allocator;
}</code></pre></pre>
<p><strong>EXERCISE</strong> Can you fix the <code>extern_spec</code> for <code>into_vec</code> so that
the code below verifies?</p>
<pre><pre class="playground"><code class="language-rust  editable">#[spec(fn() -&gt; Vec&lt;i32&gt;[3])]
pub fn test_push_macro() -&gt; Vec&lt;i32&gt; {
    let res = vec![10, 20, 30];
    assert(res.len() == 3);
    res
}</code></pre></pre>
<h3 id="pop-and-unwrap"><a class="header" href="#pop-and-unwrap">Pop-and-Unwrap</a></h3>
<p>Suppose we wanted to write a function that popped the last element
of a non-empty vector.</p>
<pre><pre class="playground"><code class="language-rust editable">#[spec(fn (vec: &amp;mut Vec&lt;T&gt;[@n]) -&gt; T
       requires 0 &lt; n
       ensures  vec: Vec&lt;T&gt;[n-1])]
fn pop_and_unwrap&lt;T&gt;(vec: &amp;mut Vec&lt;T&gt;) -&gt; T {
    vec.pop().unwrap()
}</code></pre></pre>
<p><strong>EXERCISE</strong> Flux chafes because the spec for <code>pop</code> is too <em>weak</em>:
above does not tell us <em>when</em> the returned value is safe to unwrap.
Can you go back and fix the spec for <code>fn pop</code> so that <code>pop_and_unwrap</code>
verifies?</p>
<h3 id="poppop"><a class="header" href="#poppop">PopPop!</a></h3>
<p><strong>EXERCISE</strong> Finally, as a parting exercise, can you work out
why flux rejects the <code>pop2</code> function below, and modify the spec
so that it is accepted?</p>
<pre><pre class="playground"><code class="language-rust editable">#[spec(fn (vec: &amp;mut Vec&lt;T&gt;[@n]) -&gt; (T, T)
       ensures vec: Vec&lt;T&gt;[n-2] )]
fn pop2&lt;T&gt;(vec: &amp;mut Vec&lt;T&gt;) -&gt; (T, T)  {
    let v1 = pop_and_unwrap(vec);
    let v2 = pop_and_unwrap(vec);
    (v1, v2)
}</code></pre></pre>
<h2 id="summary-6"><a class="header" href="#summary-6">Summary</a></h2>
<p>Previously, we saw how to attach refined specifications for
<a href="tutorial/./01-refinements.html">functions</a>, <a href="tutorial/03-structs.html">structs</a>
and <a href="tutorial/04-enums.html">enums</a>.</p>
<p>In this chapter, we saw that you can use the <code>extern_spec</code>
mechanism to do the same things for objects defined elsewhere,
e.g. in external crates being used by your code.</p>
<p>Next, we'll learn how to use <code>extern_spec</code> to refine <em>traits</em>
(and their implementations), which is key to checking idiomatic
Rust code.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-assumption">
<p>We say <em>assumption</em> because we're presuming that
the actual code for the library is not available to verify; if
it was, you could of course actually <em>guarantee</em> that the library
correctly implements those specifications. <a href="#fr-assumption-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="traits-and-associated-refinements"><a class="header" href="#traits-and-associated-refinements">Traits and Associated Refinements</a></h1>
<pre><pre class="playground"><code class="language-rust  editable">#![allow(unused)]
extern crate flux_rs;
extern crate flux_core;
extern crate flux_alloc;
use flux_rs::{attrs::*, extern_spec};
use std::ops::Range;</code></pre></pre>
<pre><pre class="playground"><code class="language-rust  editable  hidden">#[spec(fn (bool[true]))]
fn assert(b: bool) {
    if !b {
        panic!("assertion failed");
    }
}</code></pre></pre>
<p>One of Rust's most appealing features is its <strong>trait</strong> system which lets us decouple
<strong>descriptions</strong> of particular operations that a type should support, from their actual
<strong>implementations</strong>, to enable <em>generic</em> code that works across all implementations of
an interface.</p>
<p>Traits are ubiquitous in Rust code. For example,</p>
<ul>
<li>
<p>an <em>addition</em> <code>x + y</code> is internally represented as <code>x.add(y)</code>
where <code>x</code> and <code>y</code> can be values that implement the <code>Add</code> trait,
allowing for a uniform way to write <code>+</code> that works across
all compatible types;</p>
</li>
<li>
<p>an <em>indexing</em> operation <code>x[i]</code> is internally represented as <code>x.index(i)</code>
where <code>x</code> can be any value that implements the <code>Index</code> trait, and <code>i</code>
a compatible "key", which allows for a standard way to lookup
containers at a particular value;</p>
</li>
<li>
<p>an <em>iteration</em> <code>for x in e { ... }</code> becomes <code>while let Some(x) = e.next() { ... }</code>,
where the <code>e</code> can be any value that implements the <code>Iterator</code> trait,
allowing for an elegant and uniform way to iterate over different kinds
of ranges and collections.</p>
</li>
</ul>
<p>In this chapter, lets learn how traits pose some interesting
puzzles for formal verification, and how Flux resolves these
challenges with <strong>associated refinements</strong>.</p>
<h2 id="first-things-first"><a class="header" href="#first-things-first">First things First</a></h2>
<p>To limber up before we get to traits, lets
write a function to return (a reference to)
the first element of a slice.</p>
<pre><pre class="playground"><code class="language-rust  editable">fn get_first_slice&lt;A&gt;(container: &amp;[A]) -&gt; &amp;A
{
    &amp;container[0]
}</code></pre></pre>
<p>The method <code>get_first_slice</code> works just
fine if you call it on <em>non-empty</em> slices,
but will panic at run-time if you try it on
an empty one</p>
<pre><pre class="playground"><code class="language-rust  editable">fn test_first_slice() {
    let s0: &amp;[i32] = &amp;[10, 20, 30];
    let v0 = get_first_slice(s0);
    println!("get_first_slice {s0:?} ==&gt; {v0}");

    let s1: &amp;[char] = &amp;['a', 'b', 'c'];
    let v1 = get_first_slice(s1);
    println!("get_first_slice {s1:?} ==&gt; {v1}");

    let s2: &amp;[bool] = &amp;[];
    let v2 = get_first_slice(s2);
    println!("get_first_slice {s2:?} ==&gt; {v2}");
}</code></pre></pre>
<h3 id="catching-panics-at-compile-time"><a class="header" href="#catching-panics-at-compile-time">Catching Panics at Compile Time</a></h3>
<p>You might recall from <a href="tutorial/06-consts.html#refined-compile-time-safety">this previous chapter</a>
that Flux tracks the sizes of arrays and slices.</p>
<p>If you click the check button, you will see that flux
disapproves of <code>get_first_slice</code></p>
<pre><code>error[E0999]: assertion might fail: possible out of bounds access

   |
13 |    &amp;container[0];
   |    ^^^^^^^^^^^^
</code></pre>
<h3 id="specifying-non-empty-slices"><a class="header" href="#specifying-non-empty-slices">Specifying Non-Empty Slices</a></h3>
<p><strong>EXERCISE</strong> Can you go back and add a flux <code>spec</code> for <code>get_first_slice</code> that says that the function
should  <em>only</em> be called with <em>non-empty</em> slices? The spec should look something like the below, except
the <code>...</code> should be a constraint over <code>size</code>.</p>
<pre><code>#[spec(fn (container: &amp;[A]{size: ...}) -&gt; &amp;A)]
</code></pre>
<p>When you are done, you should see no warnings in <code>get_first_slice</code> but you will get an error in
<code>test_first_slice</code>, precisely at the location where we call it with an empty slice, which you
can fix by commenting out or removing the last call...</p>
<h2 id="a-trait-to-index-values"><a class="header" href="#a-trait-to-index-values">A Trait to <code>Index</code> Values</a></h2>
<p>Next, lets write our own little trait to index different kinds of containers <sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup>.</p>
<pre><pre class="playground"><code class="language-rust  editable">pub trait IndexV1&lt;Idx&gt; {
    type Output:?Sized;

    fn index(&amp;self, index: Idx) -&gt; &amp;Self::Output;
}</code></pre></pre>
<p>The above snippet defines a <code>trait</code> called <code>IndexV1</code> that is parameterized by <code>Idx</code>: the
type used as the actual index. To <em>implement</em> the trait, we must specify</p>
<ol>
<li>The <code>Self</code> type for the container itself (e.g. a slice, a vector, hash-map, a string, <em>etc.</em>),</li>
<li>The <code>Idx</code> type used as the index (e.g. a <code>usize</code> or <code>String</code> key, or <code>Range&lt;usize&gt;</code>, <em>etc</em>), and</li>
<li>The <code>Output</code>: an <em>associated type</em> that describes what the <code>index</code> method returns, and finally,</li>
<li>The <code>index</code> method itself, which takes a reference to <code>self</code> and an <code>index</code> of type <code>Idx</code>, and returns a reference to the <code>Output</code>.</li>
</ol>
<h3 id="a-generic-reusable-get_firstv1"><a class="header" href="#a-generic-reusable-get_firstv1">A Generic, Reusable <code>get_firstV1</code></a></h3>
<p>We can now write functions that work over <em>any</em> type that implements the <code>Index</code> trait.
For instance, we can generalize the <code>get_first_slice</code> method, which only worked on slices,
to the <code>get_firstV1</code> method will let use borrow the <code>0</code>th element of <em>any</em> <code>container</code> that
implements <code>Index&lt;usize&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust  editable">fn get_firstV1&lt;A, T&gt;(container: &amp;T) -&gt; &amp;A
  where
    T: ?Sized + IndexV1&lt;usize, Output = A&gt;
{
    container.index(0)
}</code></pre></pre>
<h3 id="indexing-slices-with-usize"><a class="header" href="#indexing-slices-with-usize">Indexing Slices with <code>usize</code></a></h3>
<p>To use the <code>trait</code>, we must actually <em>implement</em> it for particular types of interest.</p>
<p>Lets implement a method to <code>index</code> a slice by a <code>usize</code> value:</p>
<pre><pre class="playground"><code class="language-rust  editable">#[trusted]
impl &lt;A&gt; IndexV1&lt;usize&gt; for [A] {

    type Output = A;

    fn index(&amp;self, index: usize) -&gt; &amp;Self::Output {
        &amp;self[index]
    }
}</code></pre></pre>
<p>The above code describes an implementation where the</p>
<ul>
<li><code>Self</code> type of the <em>container</em> is a slice <code>[A]</code>;</li>
<li><code>Idx</code> type of the <em>index</em> is <code>usize</code>;</li>
<li><code>Output</code> returned by <code>index()</code> is a (reference to) <code>A</code>; and</li>
<li><code>index()</code> is just a wrapper around the standard library's implementation.</li>
</ul>
<p>Lets ignore the <code>#[trusted]</code> for now: it just tells flux to accept this code
without protesting about <code>self[index]</code> triggering an out-of-bounds error.</p>
<h3 id="testing-get_firstv1"><a class="header" href="#testing-get_firstv1">Testing <code>get_firstV1</code></a></h3>
<p>Sweet! Now that we have a concrete implementation for <code>Index</code>
we should be able to <em>test</em> it</p>
<pre><pre class="playground"><code class="language-rust  editable">fn test_firstV1() {
    let s0: &amp;[i32] = &amp;[10, 20, 30];
    let v0 = get_firstV1(s0);
    println!("get_firstV1 {s0:?} ==&gt; {v0}");

    let s1: &amp;[char] = &amp;['a', 'b', 'c'];
    let v1 = get_firstV1(s1);
    println!("get_firstV1 {s1:?} ==&gt; {v1}");

    let s2: &amp;[bool] = &amp;[];
    let v2 = get_firstV1(s2);
    println!("get_firstV1 {s2:?} ==&gt; {v2}");
}</code></pre></pre>
<p>Click the run button. Huh?! No warnings??</p>
<p>Of course, the last one <em>will</em> panic.</p>
<p>But why didn't flux <em>warn</em> us about it, like it did with <code>test_first_slice</code>.</p>
<h3 id="yikes-get_firstv1-is-unsafe"><a class="header" href="#yikes-get_firstv1-is-unsafe">Yikes <code>get_firstV1</code> is unsafe!</a></h3>
<p>When we <em>directly</em> access a slice as in <code>get_first_slice</code>,
or <code>test_first_slice</code>, flux complains about the potential,
in this case, <em>certain</em>, out of bounds access.</p>
<p>But the <em>indirection</em> through <code>get_firstV1</code> (and <code>index</code>) has
has laundered the out of bounds access, tricking
flux into unsoundly missing the run-time error!</p>
<p>We're in a bit of a pickle.</p>
<p>The <code>Index</code> trait <em>giveth</em> the ability to write <em>generic</em>
code like <code>get_firstV1</code>, but apparently <em>taketh away</em> the
ability to <em>catch panics</em> at compile-time.</p>
<p>Surely, there is a way to use traits without giving up
on compile-time verification...</p>
<h3 id="the-challenge-how-to-specify-safe-indexing-generically"><a class="header" href="#the-challenge-how-to-specify-safe-indexing-generically">The Challenge: How to Specify <em>Safe</em> Indexing, Generically</a></h3>
<p>Clearly we <em>should not</em> call <code>get_firstV1</code> with empty slices.</p>
<p>The method <code>get_firstV1</code> wants to access the <code>0</code>-th element
of the container, and will crash at run-time if the <code>0</code>th element
does not exist, as is the case with an empty slice.</p>
<p>But the puzzle is this: how do we specify
<strong>"the <code>0</code>-th element exists"</strong> for <em>any</em>
generic <code>container</code> that implements <code>Index</code>?</p>
<h2 id="associated-refinements"><a class="header" href="#associated-refinements">Associated Refinements</a></h2>
<p>Flux's solution to this puzzle is to borrow a page from Rust's own playbook.</p>
<p>Lets revisit the definition of the <code>Index</code> trait:</p>
<pre><code>pub trait IndexV1&lt;Idx&gt; {
    type Output:?Sized;
    fn index(&amp;self, index: Idx) -&gt; &amp;Self::Output;
}
</code></pre>
<p>In the above, <code>Output</code> is an <strong>associated type</strong> for the <code>Index</code> trait that
specifies what the <code>index</code> method returns. For instance, in our implementation
of <code>Index&lt;usize&gt;</code> for slices <code>[A]</code>, the <code>Output</code> is <code>A</code>.
Inspired this idea, Flux extends traits with the ability to specify
<strong>associated refinements</strong> that can <em>describe</em> the values accepted
and returned by the trait's methods.</p>
<h3 id="valid-indexes"><a class="header" href="#valid-indexes">Valid Indexes</a></h3>
<p>Thus, we can extend the trait with an associated refinement
that specifies when an index is <code>valid</code> for a container.
Lets do so by defining the <code>Index</code> trait as:</p>
<pre><pre class="playground"><code class="language-rust  editable">#[reft(fn valid(me: Self, index: Idx) -&gt; bool)]
pub trait Index&lt;Idx:?Sized&gt; {
    type Output:?Sized;

    #[spec(fn(&amp;Self[@me], idx:Idx{&lt;Self as Index&lt;Idx&gt;&gt;::valid(me, idx)}) -&gt; &amp;Self::Output)]
    fn index(&amp;self, idx: Idx) -&gt; &amp;Self::Output;
}</code></pre></pre>
<p>There are <em>two</em> new things in our new version of <code>Index</code>.</p>
<p><strong>1. Declaration</strong>
First, the <code>reft</code> attribute declares<sup class="footnote-reference" id="fr-2-1"><a href="#footnote-2">2</a></sup> the <em>associated refinement</em>:
a refinement level function named <code>valid</code>, that</p>
<ul>
<li><em>takes</em> as inputs, the <code>Self</code> type of the container and the <code>Idx</code> type of the index, and</li>
<li><em>returns</em> a <code>bool</code> which indicates if the <code>index</code> is valid for the container.</li>
</ul>
<p><strong>2. Use</strong>
Next, the <code>spec</code> attribute refines the <code>index</code> method to say that it should only be
passed an <code>idx</code> that is <em>valid</em> for the <code>me</code> container, where <code>valid</code> is the associated
refinement declared above. The notation <code>&lt;Self as Index&lt;Idx&gt;&gt;::valid(me, idx)</code> is a
(sadly, verbose!) way to refer to the <code>valid</code> function associated with the particular
implementation of the <code>Index</code> trait for the <code>Self</code> type.</p>
<h3 id="a-safe-and-generic-reusable-get_first"><a class="header" href="#a-safe-and-generic-reusable-get_first">A Safe (and Generic, Reusable) <code>get_first</code></a></h3>
<p>We can now write functions that work over <em>any</em> type that implements the <code>Index</code> trait,
but where flux will guarantee that <code>index</code> is safe to call. For example, lets revisit
the <code>get_first</code> method that returns the 0th element of a container.</p>
<pre><pre class="playground"><code class="language-rust  editable">// #[spec(fn (&amp;T{container:&lt;T as Index&lt;usize&gt;&gt;::valid(container, 0)}) -&gt; &amp;A)]
fn get_first&lt;A, T&gt;(container: &amp;T) -&gt; &amp;A
  where T: ?Sized + Index&lt;usize, Output = A&gt;
{
    container.index(0)
}</code></pre></pre>
<p>Aha, now flux complains that the above is <em>unsafe</em> because we don't know that <code>container</code>
is <em>actually</em> <code>valid</code> for the index <code>0</code>. To make it safe, we must add (uncomment!) the
flux specification in the line above. This spec says that <code>get_first</code> can only be called
with a <code>container</code> that is <code>valid</code> for the index <code>0</code>.</p>
<h3 id="indexing-slices-with-usize-1"><a class="header" href="#indexing-slices-with-usize-1">Indexing Slices with <code>usize</code></a></h3>
<p>Lets now revisit that implementation of for slices using <code>usize</code> indexes.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[assoc(fn valid(size: int, index: int) -&gt; bool { index &lt; size })]
impl &lt;A&gt; Index&lt;usize&gt; for [A] {

    type Output = A;

    #[spec(fn(&amp;Self[@me], idx:usize{&lt;[A] as Index&lt;usize&gt;&gt;::valid(me, idx)}) -&gt; &amp;Self::Output)]
    fn index(&amp;self, index: usize) -&gt; &amp;Self::Output {
        &amp;self[index]
    }
}</code></pre></pre>
<p>As with the trait definition, there are two new things in our implementation of <code>Index</code> for slices.</p>
<p><strong>1. Implementation</strong>
First, we provide a concrete implementation of the <em>associated refinement</em> <code>valid</code>.
Recall that in flux, slices <code>[A]</code> are <a href="tutorial/./06-consts.html#refined-compile-time-safety">represented by their size</a> at the refinement level.
Hence, the implementation of <code>valid</code> takes as parameters the <code>size</code>
of the slice and the <code>index</code>, and returns <code>true</code> exactly if
the <code>index</code> is less than the <code>size</code>.</p>
<p><strong>2. Use</strong>
As with the trait method, the actual implementation of the <code>index</code>
method has been refined to say that it should only be passed an
<code>idx</code> that is <em>valid</em> for <code>me</code> at the specified <code>idx</code>.<sup class="footnote-reference" id="fr-3-1"><a href="#footnote-3">3</a></sup></p>
<h3 id="testing-get_first"><a class="header" href="#testing-get_first">Testing <code>get_first</code></a></h3>
<p>Now, lets revisit our clients for <code>get_first</code> using the new <code>Index</code> trait.</p>
<pre><pre class="playground"><code class="language-rust  editable">fn test_first() {
    let s0: &amp;[i32] = &amp;[10, 20, 30];
    let v0 = get_first(s0);
    println!("get_first {s0:?} ==&gt; {v0}");

    let s1: &amp;[char] = &amp;['a', 'b', 'c'];
    let v1 = get_first(s1);
    println!("get_first {s1:?} ==&gt; {v1}");

    let s2: &amp;[bool] = &amp;[];
    let v2 = get_first(s2);
    println!("get_first {s2:?} ==&gt; {v2}");
}</code></pre></pre>
<p><em>Hooray!</em> Now, when you click the check button, flux will complain about the
last call to <code>get_first</code> because the slice <code>s2</code> is <em>not</em> <code>valid</code> for the index <code>0</code>!
To do so, flux <em>specialized</em> the specification of <code>get_first</code> (which required
<code>container</code> to be <code>valid</code> for <code>0</code>) with the actual <em>definition</em> of <code>valid</code> for
slices (which requires that <code>0 &lt; size</code>) and the actual <code>size</code> for <code>s2</code> (which is <code>0</code>).
As <code>0 &lt; 0</code> is false, flux rejects the code at compile time.</p>
<h2 id="indexing-strings-with-ranges"><a class="header" href="#indexing-strings-with-ranges">Indexing Strings with Ranges</a></h2>
<p>The whole point of the <code>Index</code> trait is be able to <code>index</code> <em>different kinds</em> of
containers. Lets see how to implement <code>Index</code> for <code>str</code> using <code>Range&lt;usize&gt;</code> indexes,
which return sub-slices of the string.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[assoc(fn valid(me: str, index: Range) -&gt; bool {
    index.start &lt;= index.end &amp;&amp; index.end &lt;= str_len(me)
})]
impl Index&lt;Range&lt;usize&gt;&gt; for str  {

    type Output = str;

    #[spec(fn(&amp;Self[@me], idx:Range&lt;usize&gt;{&lt;str as Index&lt;Range&lt;usize&gt;&gt;&gt;::valid(me, idx)}) -&gt; &amp;Self::Output)]
    fn index(&amp;self, idx: Range&lt;usize&gt;) -&gt; &amp;Self::Output {
        &amp;self[idx.start..idx.end]
    }
}</code></pre></pre>
<p>The implementation above, implements <code>Index&lt;Range&lt;usize&gt;&gt;</code> for <code>str</code> by</p>
<ol>
<li>
<p><strong>Defining</strong> the associated refinement <code>valid</code> to say that a <code>Range</code> is valid for a string
if the <code>start</code> of the range is less than or equal to the <code>end</code>, and the <code>end</code> is
less than or equal to the length of the string (which we get using the built-in
<code>str_len</code> function);</p>
</li>
<li>
<p><strong>Refining</strong> the specification of the <code>index</code> method to say that it should only be
passed an <code>index</code> that is valid for the string <code>me</code>; and the given <code>idx</code>.</p>
</li>
</ol>
<p>Now when we run flux on clients of this implementation,
we can see that the first call is a valid sub-slice, but the
second is <em>not</em> and hence, is rejected by flux.</p>
<pre><pre class="playground"><code class="language-rust  editable">fn test_str() {
    let cat = "caterpillar";
    let sub = cat.index(0..6); // OK
    let sub = cat.index(0..19); // Error
}</code></pre></pre>
<p>Flux produces the error pinpointing the problem:</p>
<pre><code>error[E0999]: refinement type error
   |
89 |     let sub = cat.index(0..19); // Error
   |               ^^^^^^^^^^^^^^^^ a precondition cannot be proved
   |
note: this is the condition that cannot be proved
   |
74 |     index.start &lt;= index.end &amp;&amp; index.end &lt;= str_len(me)
   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<p><strong>EXERCISE</strong> Can you modify the code above so that the second call to <code>index</code>
is accepted by flux?</p>
<h2 id="indexing-vectors-with-usize"><a class="header" href="#indexing-vectors-with-usize">Indexing Vectors with <code>usize</code></a></h2>
<p><strong>EXERCISE</strong> Let's implement the <code>Index</code> trait for <code>Vec</code> using <code>usize</code> indexes.
The definition of <code>valid</code> is too permissive, can you modify it so that flux accepts
the below <code>impl</code>?</p>
<pre><pre class="playground"><code class="language-rust  editable">#[assoc(fn valid(me: std::vec::Vec, index: int) -&gt; bool { true })]
impl &lt;A:Copy&gt; Index&lt;usize&gt; for Vec&lt;A&gt; {
    type Output = A;

    #[spec(fn(&amp;Self[@me], index:usize{&lt;std::vec::Vec&lt;A&gt; as Index&lt;usize&gt;&gt;::valid(me, index)}) -&gt; &amp;Self::Output)]
    fn index(&amp;self, index: usize) -&gt; &amp;Self::Output {
        &amp;self[index]
    }
}</code></pre></pre>
<p><strong>EXERCISE</strong> Let's write a client that uses the <code>index</code> on <code>Vec</code>
to compute a dot-product for two <code>Vec&lt;f64&gt;</code>. Can you fix the <code>spec</code>
for <code>dot_vec</code> so flux accepts it?</p>
<pre><pre class="playground"><code class="language-rust  editable">#[spec(fn (xs: &amp;std::vec::Vec&lt;f64&gt;, ys: &amp;std::vec::Vec&lt;f64&gt;) -&gt; f64)]
fn dot_vec(xs: &amp;Vec&lt;f64&gt;, ys: &amp;Vec&lt;f64&gt;) -&gt; f64 {
    let mut res = 0.0;
    for i in 0..xs.len() {
        res += xs.index(i) * ys.index(i);
    }
    res
}</code></pre></pre>
<h2 id="indexing-vectors-with-ranges"><a class="header" href="#indexing-vectors-with-ranges">Indexing Vectors with Ranges</a></h2>
<p><strong>EXERCISE</strong> Finally, lets extract <em>sub-slices</em> from vectors using <code>Range&lt;usize&gt;</code> indexes.
Why does flux reject the below <code>impl</code>? Can you edit the code so flux accepts it?</p>
<pre><pre class="playground"><code class="language-rust  editable">#[assoc(fn valid(me: std::vec::Vec, idx: Range&lt;int&gt;) -&gt; bool {
    true
  })]
impl &lt;A&gt; Index&lt;Range&lt;usize&gt;&gt; for Vec&lt;A&gt; {

    type Output = [A];

    #[spec(fn(&amp;Self[@me], idx:Range&lt;usize&gt;{&lt;std::vec::Vec&lt;A&gt; as Index&lt;Range&lt;usize&gt;&gt;&gt;::valid(me, idx)}) -&gt; &amp;Self::Output)]
    fn index(&amp;self, idx: Range&lt;usize&gt;) -&gt; &amp;Self::Output {
        &amp;self[idx.start..idx.end]
    }
}</code></pre></pre>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>In this chapter, we saw how traits can be extended with <strong>associated refinements</strong>
which let us <em>declare</em> refinements on the inputs and outputs of trait methods
(e.g. <code>valid</code> indexes) that are then <em>implemented</em>  by each implementation of
the trait (e.g. the index is less than the slice size).</p>
<p>Associated refinements turn out to be an extremely useful mechanism, for example,
they let us specify properties of commonly used operations like
<a href="tutorial/spec-index">indexing</a> and <a href="tutorial/spec-iterator">iteration</a>, and more
advanced properties like the semantics of sql queries <sup class="footnote-reference" id="fr-4-1"><a href="#footnote-4">4</a></sup> and
the behavior of memory allocators <sup class="footnote-reference" id="fr-5-1"><a href="#footnote-5">5</a></sup>.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<p>The "real" ones in the standard library have a few more moving parts that would needlessly complicate our explanation of the interaction between traits and formal verification. <a href="#fr-1-1">↩</a></p>
</li>
<li id="footnote-2">
<p><code>valid</code> function is just a declaration: we do not specify an actual <em>body</em>
as those will be filled in by the implementors of the trait. We could specify a
<em>default</em> body for <code>valid</code> e.g. which always returns <code>true</code>, which can be
<em>over-ridden</em> i.e. redefined by implementations, but we must be careful
about what we choose as the default. <a href="#fr-2-1">↩</a></p>
</li>
<li id="footnote-3">
<p>By the way, it seems a little silly to <em>repeat</em> the spec for <code>index</code> doesn't it?
To be sound, Flux checks that the implementation needs to be a <a href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)">subtype of the trait method</a>.
We could for example, accept <em>more</em> inputs and produce <em>fewer</em> outputs.
But in this case, it is simply a version of the trait specification, specialized
to the particular <code>Self</code> and <code>Idx</code> types of the implementation. <a href="#fr-3-1">↩</a></p>
</li>
<li id="footnote-4">
<p>See section 6.2 of this <a href="https://ranjitjhala.github.io/static/popl25-generic-refinements.pdf">POPL 2025 paper</a> for more details. <a href="#fr-4-1">↩</a></p>
</li>
<li id="footnote-5">
<p>See this <a href="https://ranjitjhala.github.io/static/sosp25-ticktock.pdf">SOSP 2025 paper</a> for more details. <a href="#fr-5-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="flux-specifications-1"><a class="header" href="#flux-specifications-1">Flux Specifications</a></h1>
<p>One day, this will be an actual user's guide, but for now,
it is a WIP guide to writing specifications in <code>flux</code>, as
illustrated by examples from the regression tests.</p>
<h2 id="refinement-types"><a class="header" href="#refinement-types">Refinement Types</a></h2>
<ul>
<li>
<p><strong>Indexed Type</strong>: An indexed type <code>B[r]</code> is composed of a base Rust type <code>B</code> and a refinement index <code>r</code>. The meaning of the index depends on the type. Some examples are</p>
<ul>
<li><code>i32[n]</code>: denotes the (singleton) set of <code>i32</code> values equal to <code>n</code>.</li>
<li><code>List&lt;T&gt;[n]</code>: values of type <code>List&lt;T&gt;</code> of length <code>n</code>.</li>
</ul>
</li>
<li>
<p><strong>Refinement parameter</strong>: Function signatures can be parametric on refinement variables. Refinement parameters are declared using the <code>@n</code> syntax. For example, the following signature:</p>
<p><code>fn(i32[@n]) -&gt; i32[n + 1]</code></p>
<p>binds <code>n</code> over the entire scope of the function to specify that it takes an <code>i32</code> equal to <code>n</code> and returns an <code>i32</code> equal to <code>n + 1</code>. This is analogous to languages like Haskell where a lower case letter can be used to quantify over a type, e.g., the type <code>a -&gt; a</code> in Haskell is polymorphic on the type <code>a</code> which is bound for the scope of the entire function type.</p>
</li>
<li>
<p><strong>Existential Type</strong>: An existential type <code>B{v: r(v)}</code> is composed of a base type <code>B</code>, a refinement variable <code>v</code> and a refinement predicate <code>r</code> on <code>v</code>. Intuitively, a Rust value <code>x</code> has type <code>B{v: r(v)}</code> if there exists a refinement value <code>a</code> such that <code>r(a)</code> holds and <code>x</code> has type <code>B[a]</code>.</p>
<ul>
<li><code>i32{v: v &gt; 0}</code>: set of positive <code>i32</code> values.</li>
<li><code>List&lt;T&gt;{v: v &gt; 0}</code>: set of non-empty lists.</li>
</ul>
</li>
<li>
<p><strong>Constraint Type</strong>: A constraint type has the form <code>{T | r}</code> where <code>T</code> is any type (not just a base type). Intuitively, a value has type <code>{T | r}</code> if it has type <code>T</code> and also <code>r</code> holds. They can be used to constraint a refinement parameter. For example, the following signature constraint the refinement parameter <code>n</code> to be less than <code>10</code>.</p>
<p><code>fn({i32[@n] | n &lt; 10}) -&gt; i32[n + 1]</code></p>
<p>Constraint types serve a similar role as existentials as they can also be used to constraint some
refinement value with a predicate, but an existential type can only be used to constraint refinement
variable that it bound locally, in contrast constraint types can be used to constraint a "non-local" parameter. This can be seen in the example above where the parameter <code>n</code> cannot be bound locally
because it has to be used in the return type.</p>
</li>
</ul>
<h2 id="argument-syntax"><a class="header" href="#argument-syntax">Argument Syntax</a></h2>
<p>The <code>@n</code> syntax used to declare refinements parameters can be hard to read sometimes. Flux also supports a syntax that let you bind refinement parameters using colons similar to the syntax used to declare arguments in a function. We call this <em>argument syntax</em>. This syntax desugars to one of the refinements forms discussed above. For example, the following signature</p>
<p><code>fn(x: i32, y: i32) -&gt; i32[x + y]</code></p>
<p>desugars to</p>
<p><code>fn(i32[@x], i32[@y]) -&gt; i32[x + y]</code></p>
<p>It is also possible to attach some constraint to the parameters when using argument syntax. For example,
to specify that <code>y</code> must be greater than <code>x</code> using argument syntax we can write:</p>
<p><code>fn(x: i32, y: i32{x &gt; y}) -&gt; i32[x + y]</code></p>
<p>This will desugar to:</p>
<p><code>fn(i32[@x], {i32[@y] | x &gt; y}) -&gt; i32[x + y]</code></p>
<h2 id="grammar-of-refinements"><a class="header" href="#grammar-of-refinements">Grammar of Refinements</a></h2>
<p>The grammar of refinements (expressions that can appear as an index or constraint) is as follows:</p>
<pre><code class="language-text">r ::= n                     // numbers 1,2,3...
    | x                     // identifiers x,y,z...
    | x.f                   // index-field access
    | r + r                 // addition
    | r - r                 // subtraction
    | n * e                 // multiplication by constant
    | if r { r } else { r } // if-then-else
    | f(r...)               // function application
    | true | false          // booleans
    | r == r                // equality
    | r != r                // not equal
    | r &lt; r                 // less than
    | r &lt;= r                // less than or equal
    | r &gt; r                 // greater than
    | r &gt;= r                // greater than or equal
    | r || r                // disjunction
    | r &amp;&amp; r                // conjunction
    | r =&gt; r                // implication
    | !r                    // negation
</code></pre>
<h2 id="index-refinements"><a class="header" href="#index-refinements">Index Refinements</a></h2>
<p>Of the form <code>i32[e]</code> (<code>i32</code> equal to <code>e</code>) values.</p>
<pre><code class="language-rust noplayground noplayground">#[flux::sig(fn(bool[true]))]
pub fn assert(_b: bool) {}

pub fn test00() {
    let x = 1;
    let y = 2;
    assert(x + 1 == y);
}

#[flux::sig(fn five() -&gt; usize[5])]
pub fn five() -&gt; usize {
    let x = 2;
    let y = 3;
    x + y
}

#[flux::sig(fn(n:usize) -&gt; usize[n+1])]
pub fn incr(n: usize) -&gt; usize {
    n + 1
}

pub fn test01() {
    let a = five();
    let b = incr(a);
    assert(b == 6);
}</code></pre>
<p><strong>NOTE:</strong> We use the <code>sig(..)</code> annotation to specify the refinement type of a function;
you can optionally also add the <em>name</em> of the function as shown for <code>fn five</code>.</p>
<h2 id="existential-refinements"><a class="header" href="#existential-refinements">Existential Refinements</a></h2>
<p>Of the form <code>i32{v: 0 &lt;= v}</code> (non-negative <code>i32</code>) values.</p>
<pre><code class="language-rust noplayground noplayground">#[flux::sig(fn(x:i32) -&gt; i32{v: v &gt; x})]
pub fn inc(x: i32) -&gt; i32 {
    x + 1
}

#[flux::sig(fn(x:i32) -&gt; i32{v: v &lt; x})]
pub fn dec(x: i32) -&gt; i32 {
    x - 1
}</code></pre>
<h2 id="combining-index-and-existential-refinements"><a class="header" href="#combining-index-and-existential-refinements">Combining Index and Existential Refinements</a></h2>
<pre><code class="language-rust noplayground noplayground">#[flux::sig(fn(k: i32{0 &lt;= k}) -&gt; i32[0])]
pub fn test(mut k: i32) -&gt; i32 {
    while toss() &amp;&amp; k &lt; i32::MAX - 1 {
        k += 1;
    }
    while k &gt; 0 {
        k -= 1;
    }
    k
}</code></pre>
<h2 id="mutable-references"><a class="header" href="#mutable-references">Mutable References</a></h2>
<pre><code class="language-rust noplayground noplayground">#[flux::sig(fn(x: &amp;mut i32{v: 0 &lt;= v}))]
pub fn test4(x: &amp;mut i32) {
    *x += 1;
}</code></pre>
<pre><code class="language-rust noplayground noplayground">#[flux::sig(fn(x: &amp;mut i32{v: 0 &lt;= v}))]
pub fn test4(x: &amp;mut i32) {
    *x -= 1; //~ ERROR assignment might be unsafe
}</code></pre>
<h2 id="strong-references"><a class="header" href="#strong-references">Strong References</a></h2>
<p>Like <code>&amp;mut T</code> but which allow <em>strong updates</em> via <code>ensures</code> clauses</p>
<pre><code class="language-rust noplayground noplayground">#[flux::sig(fn(x: &amp;strg i32[@n]) ensures x: i32[n+1])]
pub fn inc(x: &amp;mut i32) {
    *x += 1;
}

#[flux::sig(fn() -&gt; i32[1])]
pub fn test_inc() -&gt; i32 {
    let mut x = 0;
    inc(&amp;mut x);
    x
}</code></pre>
<h2 id="mixing-mutable-and-strong-references"><a class="header" href="#mixing-mutable-and-strong-references">Mixing Mutable and Strong References</a></h2>
<pre><code class="language-rust noplayground">#[flux::sig(fn (x: &amp;strg i32[@n]) ensures x: i32[n+1])]
pub fn incr(x: &amp;mut i32) {
    *x += 1;
}

#[flux::sig(fn (x: &amp;mut i32{v: 0&lt;=v}))]
pub fn client_safe(z: &amp;mut i32) {
    incr(z);
}</code></pre>
<h2 id="refined-arrays"><a class="header" href="#refined-arrays">Refined Arrays</a></h2>
<p><code>flux</code> supports <em>refined arrays</em> of the form <code>[i32{v: 0 &lt;= v}; 20]</code>
denoting arrays of size <code>20</code> of non-negative <code>i32</code> values.</p>
<pre><code class="language-rust noplayground">#[flux::sig(fn() -&gt; [i32{v : v &gt;= 0}; 2])]
pub fn array00() -&gt; [i32; 2] {
    [0, 1]
}

pub fn read_u16() -&gt; u16 {
    let bytes: [u8; 2] = [10, 20];
    u16::from_le_bytes(bytes)
}

#[flux::sig(fn() -&gt; i32{v : v &gt; 10})]
pub fn write() -&gt; i32 {
    let bytes: [i32; 2] = [10, 20];
    bytes[0] + bytes[1]
}</code></pre>
<h2 id="refined-vectors-rvec"><a class="header" href="#refined-vectors-rvec">Refined Vectors <code>rvec</code></a></h2>
<p><code>RVec</code> specification</p>
<pre><code class="language-rust noplayground">#![allow(dead_code)]

pub mod rslice;

#[macro_export]
macro_rules! rvec {
    () =&gt; { RVec::new() };
    ($($e:expr),+$(,)?) =&gt; {{
        let mut res = RVec::new();
        $( res.push($e); )*
        res
    }};
    ($elem:expr; $n:expr) =&gt; {{
        RVec::from_elem_n($elem, $n)
    }}
}

#[flux::opaque]
#[flux::refined_by(len: int)]
#[flux::invariant(0 &lt;= len)]
pub struct RVec&lt;T&gt; {
    inner: Vec&lt;T&gt;,
}

impl&lt;T&gt; RVec&lt;T&gt; {
    #[flux::trusted]
    #[flux::sig(fn() -&gt; RVec&lt;T&gt;[0])]
    pub fn new() -&gt; Self {
        Self { inner: Vec::new() }
    }

    #[flux::trusted]
    #[flux::sig(fn(self: &amp;strg RVec&lt;T&gt;[@n], T) ensures self: RVec&lt;T&gt;[n+1])]
    pub fn push(&amp;mut self, item: T) {
        self.inner.push(item);
    }

    #[flux::trusted]
    #[flux::sig(fn(&amp;RVec&lt;T&gt;[@n]) -&gt; usize[n])]
    pub fn len(&amp;self) -&gt; usize {
        self.inner.len()
    }

    #[flux::trusted]
    #[flux::sig(fn(&amp;RVec&lt;T&gt;[@n]) -&gt; bool[n == 0])]
    pub fn is_empty(&amp;self) -&gt; bool {
        self.inner.is_empty()
    }

    #[flux::trusted]
    #[flux::sig(fn(&amp;RVec&lt;T&gt;[@n], i: usize{i &lt; n}) -&gt; &amp;T)]
    pub fn get(&amp;self, i: usize) -&gt; &amp;T {
        &amp;self.inner[i]
    }

    #[flux::trusted]
    #[flux::sig(fn(&amp;mut RVec&lt;T&gt;[@n], i: usize{i &lt; n}) -&gt; &amp;mut T)]
    pub fn get_mut(&amp;mut self, i: usize) -&gt; &amp;mut T {
        &amp;mut self.inner[i]
    }

    #[flux::trusted]
    #[flux::sig(fn(self: &amp;strg RVec&lt;T&gt;[@n]) -&gt; T
    		requires n &gt; 0
            ensures self: RVec&lt;T&gt;[n-1])]
    pub fn pop(&amp;mut self) -&gt; T {
        self.inner.pop().unwrap()
    }

    #[flux::trusted]
    #[flux::sig(fn(&amp;mut RVec&lt;T&gt;[@n], a: usize{a &lt; n}, b: usize{b &lt; n}))]
    pub fn swap(&amp;mut self, a: usize, b: usize) {
        self.inner.swap(a, b);
    }

    #[flux::trusted]
    #[flux::sig(fn(&amp;mut RVec&lt;T&gt;[@n]) -&gt; &amp;mut [T][n])]
    pub fn as_mut_slice(&amp;mut self) -&gt; &amp;mut [T] {
        self.inner.as_mut_slice()
    }

    #[flux::trusted]
    #[flux::sig(fn(arr:_) -&gt; RVec&lt;T&gt;[N])]
    pub fn from_array&lt;const N: usize&gt;(arr: [T; N]) -&gt; Self {
        Self { inner: Vec::from(arr) }
    }

    #[flux::trusted]
    #[flux::sig(fn(xs:&amp;[T][@n]) -&gt; RVec&lt;T&gt;[n])]
    pub fn from_slice(xs: &amp;[T]) -&gt; Self
    where
        T: Clone,
    {
        Self { inner: Vec::from(xs) }
    }

    #[flux::trusted]
    #[flux::sig(fn(T, n: usize) -&gt; RVec&lt;T&gt;[n])]
    pub fn from_elem_n(elem: T, n: usize) -&gt; Self
    where
        T: Copy,
    {
        let mut vec = Self::new();
        let mut i = 0;
        while i &lt; n {
            vec.push(elem);
            i += 1;
        }
        vec
    }

    #[flux::trusted]
    #[flux::sig(fn(&amp;RVec&lt;T&gt;[@n]) -&gt; RVec&lt;T&gt;[n])]
    pub fn clone(&amp;self) -&gt; Self
    where
        T: Clone,
    {
        Self { inner: self.inner.clone() }
    }

    #[flux::trusted]
    #[flux::sig(fn(self: &amp;strg RVec&lt;T&gt;[@n], other: &amp;[T][@m]) ensures self: RVec&lt;T&gt;[n + m])]
    pub fn extend_from_slice(&amp;mut self, other: &amp;[T])
    where
        T: Clone,
    {
        self.inner.extend_from_slice(other)
    }

    #[flux::trusted]
    #[flux::sig(fn (&amp;RVec&lt;T&gt;[@n], F) -&gt; RVec&lt;U&gt;[n])]
    pub fn map&lt;U, F&gt;(&amp;self, f: F) -&gt; RVec&lt;U&gt;
    where
        F: Fn(&amp;T) -&gt; U,
    {
        RVec { inner: self.inner.iter().map(f).collect() }
    }

    #[flux::trusted]
    pub fn fold&lt;B, F&gt;(&amp;self, init: B, f: F) -&gt; B
    where
        F: FnMut(B, &amp;T) -&gt; B,
    {
        self.inner.iter().fold(init, f)
    }
}

#[flux::opaque]
pub struct RVecIter&lt;T&gt; {
    vec: RVec&lt;T&gt;,
    curr: usize,
}

impl&lt;T&gt; IntoIterator for RVec&lt;T&gt; {
    type Item = T;
    type IntoIter = RVecIter&lt;T&gt;;

    // TODO: cannot get variant of opaque struct
    #[flux::trusted]
    #[flux::sig(fn(RVec&lt;T&gt;) -&gt; RVecIter&lt;T&gt;)]
    fn into_iter(self) -&gt; RVecIter&lt;T&gt; {
        RVecIter { vec: self, curr: 0 }
    }
}

impl&lt;T&gt; Iterator for RVecIter&lt;T&gt; {
    type Item = T;

    // TODO: cannot get variant of opaque struct
    #[flux::trusted]
    #[flux::sig(fn(&amp;mut RVecIter&lt;T&gt;) -&gt; Option&lt;T&gt;)]
    fn next(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.vec.inner.pop()
    }
}

impl&lt;T&gt; std::ops::Index&lt;usize&gt; for RVec&lt;T&gt; {
    type Output = T;

    #[flux::trusted_impl]
    #[flux::sig(fn(&amp;RVec&lt;T&gt;[@n], usize{v : v &lt; n}) -&gt; &amp;T)]
    fn index(&amp;self, index: usize) -&gt; &amp;T {
        self.get(index)
    }
}

impl&lt;T&gt; std::ops::IndexMut&lt;usize&gt; for RVec&lt;T&gt; {
    #[flux::trusted_impl]
    #[flux::sig(fn(&amp;mut RVec&lt;T&gt;[@n], usize{v : v &lt; n}) -&gt; &amp;mut T)]
    fn index_mut(&amp;mut self, index: usize) -&gt; &amp;mut T {
        self.get_mut(index)
    }
}</code></pre>
<p><code>RVec</code> clients</p>
<pre><code class="language-rust noplayground">#[path = "../../lib/rvec.rs"]
mod rvec;
use rvec::RVec;

#[flux::sig(fn() -&gt; RVec&lt;i32&gt;[0])]
pub fn test0() -&gt; RVec&lt;i32&gt; {
    let mv = rvec![];
    mv
}

#[flux::sig(fn() -&gt; RVec&lt;i32&gt;[5])]
pub fn test1() -&gt; RVec&lt;i32&gt; {
    rvec![ 12; 5 ]
}

#[flux::sig(fn(n:usize) -&gt; RVec&lt;i32&gt;[n])]
pub fn test2(n: usize) -&gt; RVec&lt;i32&gt; {
    rvec![ 12; n ]
}

pub fn test3() -&gt; usize {
    let v = rvec![0, 1];
    let r = v[0];
    let r = r + v[1];
    r
}</code></pre>
<p><strong>Binary Search</strong></p>
<pre><code class="language-rust noplayground">#![allow(unused_attributes)]

#[path = "../../lib/rvec.rs"]
pub mod rvec;
use rvec::RVec;

// CREDIT: https://shane-o.dev/blog/binary-search-rust

#[flux::sig(fn(i32, &amp;RVec&lt;i32&gt;) -&gt; usize)]
pub fn binary_search(k: i32, items: &amp;RVec&lt;i32&gt;) -&gt; usize {
    let size = items.len();
    if size &lt;= 0 {
        return size;
    }

    let mut low: usize = 0;
    let mut high: usize = size - 1;

    while low &lt;= high {
        // SAFE   let middle = (high + low) / 2;
        // UNSAFE let middle = high + ((high - low) / 2);
        let middle = low + ((high - low) / 2);
        let current = items[middle];
        if current == k {
            return middle;
        }
        if current &gt; k {
            if middle == 0 {
                return size;
            }
            high = middle - 1
        }
        if current &lt; k {
            low = middle + 1
        }
    }
    size
}</code></pre>
<p><strong>Heapsort</strong></p>
<pre><code class="language-rust noplayground">#[path = "../../lib/rvec.rs"]
mod rvec;
use rvec::RVec;

#[flux::sig(fn(&amp;mut RVec&lt;i32&gt;[@n]) -&gt; i32)]
pub fn heap_sort(vec: &amp;mut RVec&lt;i32&gt;) -&gt; i32 {
    let len = vec.len();

    if len &lt;= 0 {
        return 0;
    }

    let mut start = len / 2;
    while start &gt; 0 {
        start -= 1;
        shift_down(vec, start, len - 1);
    }

    let mut end = len;
    while end &gt; 1 {
        end -= 1;
        vec.swap(0, end);
        shift_down(vec, 0, end - 1);
    }
    0
}

#[flux::sig(fn(&amp;mut RVec&lt;i32&gt;[@len], usize{v : v &lt; len}, usize{v : v &lt; len}) -&gt; i32)]
pub fn shift_down(vec: &amp;mut RVec&lt;i32&gt;, start: usize, end: usize) -&gt; i32 {
    let mut root = start;
    loop {
        let mut child = root * 2 + 1;
        if child &gt; end {
            break;
        } else {
            if child + 1 &lt;= end {
                let a = vec[child];
                let b = vec[child + 1];
                if a &lt; b {
                    child += 1;
                }
            }
            let a = vec[root];
            let b = vec[child];
            if a &lt; b {
                vec.swap(root, child);
                root = child;
            } else {
                break;
            }
        }
    }
    0
}</code></pre>
<h2 id="refined-slices"><a class="header" href="#refined-slices">Refined Slices</a></h2>
<pre><code class="language-rust noplayground">#[flux::sig(fn(&amp;[i32{v : v &gt; 0}]) -&gt; &amp;[i32{v : v &gt;= 0}])]
fn first_half(slice: &amp;[i32]) -&gt; &amp;[i32] {
    let mid = slice.len() / 2;
    let (fst, snd) = slice.split_at(mid);
    fst
}

#[flux::sig(fn(&amp;[i32{v : v &gt; 0}]) -&gt; Option&lt;&amp;i32{v : v &gt;= 0}&gt;)]
fn first(slice: &amp;[i32]) -&gt; Option&lt;&amp;i32&gt; {
    slice.first()
}

#[flux::sig(fn(&amp;mut [i32{v : v &gt; 0}]))]
fn inc_fst(slice: &amp;mut [i32]) {
    if let Some(x) = slice.first_mut() {
        *x += 1;
    }
}</code></pre>
<pre><code class="language-rust noplayground">#[path = "../../lib/rvec.rs"]
mod rvec;
use rvec::{RVec, rslice::RSlice};

#[flux::sig(fn(&amp;mut RVec&lt;T&gt;[10]))]
fn test00&lt;T&gt;(vec: &amp;mut RVec&lt;T&gt;) {
    let mut s = RSlice::from_vec(vec);
    let s1 = s.subslice(0, 3);
    let s2 = s.subslice(4, 5);
}

#[flux::trusted]
#[flux::sig(fn(x: &amp;[T][@n]) -&gt; usize[n])]
fn len&lt;T&gt;(x: &amp;[T]) -&gt; usize {
    x.len()
}

#[flux::sig(fn(&amp;mut [i32][@n], &amp;[i32][n]))]
fn add(x: &amp;mut [i32], y: &amp;[i32]) {
    let mut i = 0;
    while i &lt; len(x) {
        x[i] += y[i];
        i += 1;
    }
}

#[flux::sig(fn(&amp;mut {RVec&lt;i32&gt;[@n] | n % 2 == 0 &amp;&amp; n &gt; 0}))]
fn test01(vec: &amp;mut RVec&lt;i32&gt;) {
    let n = vec.len();
    let mut s = RSlice::from_vec(vec);
    let mut s1 = s.subslice(0, n / 2 - 1);
    let s2 = s.subslice(n / 2, n - 1);
    add(s1.as_mut_slice(), s2.as_slice())
}</code></pre>
<h2 id="refined-vec"><a class="header" href="#refined-vec">Refined <code>Vec</code></a></h2>
<p>This uses <code>extern_spec</code> which is <a href="guide/specifications.html#extern-specs">described below</a>.</p>
<p><strong>Standalone</strong></p>
<pre><code class="language-rust noplayground">#![feature(allocator_api)]

use std::alloc::{Allocator, Global};

use flux_rs::{assert, attrs::*, extern_spec};

#[extern_spec]
#[refined_by(len: int)]
#[invariant(len &gt;= 0)]
struct Vec&lt;T, A: Allocator = Global&gt;;

#[extern_spec]
impl&lt;T&gt; Vec&lt;T&gt; {
    #[spec(fn() -&gt; Vec&lt;T&gt;[0])]
    fn new() -&gt; Vec&lt;T&gt;;
}

#[extern_spec]
impl&lt;T, A: Allocator&gt; Vec&lt;T, A&gt; {
    #[spec(fn(self: &amp;mut Vec&lt;T, A&gt;[@n], T) ensures self: Vec&lt;T, A&gt;[n+1])]
    fn push(&amp;mut self, value: T);

    #[spec(fn(self: &amp;Vec&lt;T, A&gt;[@n]) -&gt; usize[n])]
    fn len(&amp;self) -&gt; usize;

    #[spec(fn(self: &amp;Vec&lt;T, A&gt;[@n]) -&gt; bool[n == 0])]
    fn is_empty(&amp;self) -&gt; bool;

    #[spec(fn(self: &amp;mut Vec&lt;T, A&gt;[@n]) -&gt; Option&lt;T&gt;
           ensures self: Vec&lt;T, A&gt;[if n &gt; 0 { n-1 } else { 0 }])]
    fn pop(&amp;mut self) -&gt; Option&lt;T&gt;;
}

#[extern_spec]
impl&lt;T&gt; [T] {
    #[spec(fn(self: Box&lt;[T][@n], A&gt;) -&gt; Vec&lt;T, A&gt;[n])]
    fn into_vec&lt;A&gt;(self: Box&lt;[T], A&gt;) -&gt; Vec&lt;T, A&gt;
    where
        A: Allocator;
}

#[spec(fn() -&gt; Vec&lt;i32&gt;[3])]
pub fn test_vec_macro() -&gt; Vec&lt;i32&gt; {
    vec![10, 20, 30]
}

#[spec(fn() -&gt; Vec&lt;i32&gt;[4])]
pub fn test_push_macro() -&gt; Vec&lt;i32&gt; {
    let res = vec![10, 20, 30, 40];
    assert(res.len() == 4);
    res
}

#[spec(fn() -&gt; Vec&lt;i32&gt;[2])]
pub fn test_push() -&gt; Vec&lt;i32&gt; {
    let mut res = Vec::new();
    res.push(10);
    res.push(20);
    res.push(30);
    let val = res.pop().unwrap();
    assert(val &gt;= 10);
    res
}

#[spec(fn() -&gt; usize[2])]
pub fn test_len() -&gt; usize {
    let res = test_push();
    res.len()
}

pub fn test_is_empty() {
    let res = test_push();
    assert(!res.is_empty())
}

// TODO: https://github.com/flux-rs/flux/issues/578
// #[spec(fn (Vec&lt;i32{v:10 &lt;= v}&gt;))]
// pub fn test3(xs: Vec&lt;i32&gt;) {
//     for x in &amp;xs {
//         assert(0 &lt;= *x)
//     }
// }

#[spec(fn (vec: &amp;mut Vec&lt;T&gt;[@n]) -&gt; Option&lt;(T, T)&gt;
       requires n &gt; 2
       ensures vec: Vec&lt;T&gt;[n-2])]
pub fn pop2&lt;T&gt;(vec: &amp;mut Vec&lt;T&gt;) -&gt; Option&lt;(T, T)&gt; {
    let v1 = vec.pop().unwrap();
    let v2 = vec.pop().unwrap();
    Some((v1, v2))
}</code></pre>
<p><strong>Associated Refinements</strong> for indexing</p>
<pre><code class="language-rust noplayground">use std::{
    alloc::{Allocator, Global},
    ops::{Index, IndexMut},
    slice::SliceIndex,
};

use flux_attrs::*;

//---------------------------------------------------------------------------------------
#[extern_spec]
#[refined_by(len: int)]
#[invariant(0 &lt;= len)]
struct Vec&lt;T, A: Allocator = Global&gt;;

//---------------------------------------------------------------------------------------

#[extern_spec]
impl&lt;T&gt; Vec&lt;T&gt; {
    #[flux::sig(fn() -&gt; Vec&lt;T&gt;[0])]
    fn new() -&gt; Vec&lt;T&gt;;
}

#[extern_spec]
impl&lt;T, A: Allocator&gt; Vec&lt;T, A&gt; {
    #[spec(fn(self: &amp;mut Vec&lt;T, A&gt;[@n], T) ensures self: Vec&lt;T, A&gt;[n+1])]
    fn push(v: &amp;mut Vec&lt;T, A&gt;, value: T);

    #[spec(fn(&amp;Vec&lt;T, A&gt;[@n]) -&gt; usize[n])]
    fn len(v: &amp;Vec&lt;T, A&gt;) -&gt; usize;

    #[spec(fn(self: &amp;mut Vec&lt;T, A&gt;[@n]) -&gt; Option&lt;T&gt; ensures self: Vec&lt;T, A&gt;[if n &gt; 0 { n-1 } else { 0 }])]
    fn pop(&amp;mut self) -&gt; Option&lt;T&gt;;
}

//---------------------------------------------------------------------------------------

#[extern_spec]
impl&lt;T, I: SliceIndex&lt;[T]&gt;, A: Allocator&gt; Index&lt;I&gt; for Vec&lt;T, A&gt; {
    #[spec(fn(&amp;Vec&lt;T, A&gt;[@len], {I[@idx] | &lt;I as SliceIndex&lt;[T]&gt;&gt;::in_bounds(idx, len)}) -&gt; _)]
    fn index(z: &amp;Vec&lt;T, A&gt;, index: I) -&gt; &amp;&lt;I as SliceIndex&lt;[T]&gt;&gt;::Output;
}

#[extern_spec]
impl&lt;T, I: SliceIndex&lt;[T]&gt;, A: Allocator&gt; IndexMut&lt;I&gt; for Vec&lt;T, A&gt; {
    #[spec(fn(&amp;mut Vec&lt;T,A&gt;[@len], {I[@idx] | &lt;I as SliceIndex&lt;[T]&gt;&gt;::in_bounds(idx, len)}) -&gt; _)]
    fn index_mut(z: &amp;mut Vec&lt;T, A&gt;, index: I) -&gt; &amp;mut &lt;I as SliceIndex&lt;[T]&gt;&gt;::Output;
}

//---------------------------------------------------------------------------------------

#[extern_spec]
impl&lt;'a, T, A: Allocator&gt; IntoIterator for &amp;'a Vec&lt;T, A&gt; {
    #[spec(fn (&amp;Vec&lt;T, A&gt;[@n]) -&gt; &lt;&amp;Vec&lt;T, A&gt; as IntoIterator&gt;::IntoIter[0,n])]
    fn into_iter(v: &amp;'a Vec&lt;T, A&gt;) -&gt; &lt;&amp;'a Vec&lt;T, A&gt; as IntoIterator&gt;::IntoIter;
}

#[extern_spec]
#[assoc(fn with_size(self: Self, n:int) -&gt; bool { self.len == n })]
impl&lt;T&gt; FromIterator&lt;T&gt; for Vec&lt;T&gt; {}</code></pre>
<pre><code class="language-rust noplayground">#![feature(allocator_api)]

use std::ops::Index;

extern crate flux_alloc;
extern crate flux_core;

// ---------------------------------------------------------------------------------------

pub fn test_get0(xs: &amp;Vec&lt;i32&gt;) -&gt; &amp;i32 {
    &lt;Vec&lt;i32&gt; as Index&lt;usize&gt;&gt;::index(xs, 10) //~ ERROR refinement type
}

pub fn test_get1(xs: &amp;Vec&lt;i32&gt;) -&gt; i32 {
    xs[10] //~ ERROR refinement type
}

#[flux::sig(fn (&amp;Vec&lt;i32&gt;[100]) -&gt; &amp;i32)]
pub fn test_get2(xs: &amp;Vec&lt;i32&gt;) -&gt; &amp;i32 {
    &lt;Vec&lt;i32&gt; as Index&lt;usize&gt;&gt;::index(xs, 99)
}

#[flux::sig(fn (&amp;Vec&lt;i32&gt;[100]) -&gt; i32)]
pub fn test_get3(xs: &amp;Vec&lt;i32&gt;) -&gt; i32 {
    xs[99]
}

pub fn test_set0(xs: &amp;mut Vec&lt;i32&gt;) {
    xs[10] = 100; //~ ERROR refinement type
}

#[flux::sig(fn (&amp;mut Vec&lt;i32&gt;[100]))]
pub fn test_set1(xs: &amp;mut Vec&lt;i32&gt;) {
    xs[99] = 100;
}

pub fn test1() {
    let mut xs = Vec::&lt;i32&gt;::new();
    xs.push(10);
    xs.push(20);
    xs.push(30);

    xs[0] = 100;
    xs[1] = 100;
    xs[2] = 100;
    xs[10] = 100; //~ ERROR refinement type
}

pub fn test2(xs: Vec&lt;i32&gt;, i: usize) {
    if i &lt; xs.len() {
        let _ = xs[i];
        let _ = xs[i + 1]; //~ ERROR refinement type
    }
}</code></pre>
<h2 id="named-function-signatures"><a class="header" href="#named-function-signatures">Named Function Signatures</a></h2>
<p>You can also write <em>named</em> function signatures using the <code>spec</code>
annotation (instead of the anonymous <code>sig</code> annotation).</p>
<h2 id="requires-clauses"><a class="header" href="#requires-clauses">Requires Clauses</a></h2>
<p>Used to specify preconditions in a single spot, if needed.</p>
<pre><code class="language-rust noplayground">#[path = "../../lib/rvec.rs"]
mod rvec;
use rvec::RVec;

#[flux::sig(
    fn(&amp;mut RVec&lt;i32&gt;[@n], b:bool) -&gt; i32[0]
    requires 2 &lt;= n
)]
pub fn test1(vec: &amp;mut RVec&lt;i32&gt;, b: bool) -&gt; i32 {
    let r;
    if b {
        r = &amp;mut vec[0];
    } else {
        r = &amp;mut vec[1];
    }
    *r = 12;
    0
}</code></pre>
<h2 id="refining-structs-1"><a class="header" href="#refining-structs-1">Refining Structs</a></h2>
<pre><code class="language-rust noplayground">#![flux::defs {
    qualifier Sub2(x: int, a: int, b:int) { x == a - b }
}]
#[path = "../../lib/rvec.rs"]
pub mod rvec;

use rvec::RVec;

#[flux::refined_by(x: int, y:int)]
pub struct Pair {
    #[flux::field(i32[x])]
    pub x: i32,
    #[flux::field(i32[y])]
    pub y: i32,
}

#[flux::sig(fn(a: i32) -&gt; RVec&lt;Pair{v : v.x + v.y &lt;= a }&gt;)]
pub fn mk_pairs_with_bound(a: i32) -&gt; RVec&lt;Pair&gt; {
    let mut i = 0;
    let mut res = RVec::new();
    while i &lt; a {
        let p = Pair { x: i, y: a - i };
        res.push(p);
        i += 1;
    }
    res
}</code></pre>
<pre><code class="language-rust noplayground">#![flux::defs {
    fn is_btwn(v:int, lo:int, hi: int) -&gt; bool { lo &lt;= v &amp;&amp; v &lt;= hi }
    fn ok_day(d:int) -&gt; bool { is_btwn(d, 1, 31) }
    fn is_month30(m:int) -&gt; bool { m == 4 || m == 6 || m == 9 || m == 11 }
    fn ok_month(d:int, m:int) -&gt; bool { is_btwn(m, 1, 12) &amp;&amp; (is_month30(m) =&gt; d &lt;= 30) }
    fn is_leap_year(y:int) -&gt; bool { y % 400 == 0 || (y % 4 == 0 &amp;&amp; (y % 100) &gt; 0) }
    fn is_feb_day(d:int, y:int) -&gt; bool { d &lt;= 29 &amp;&amp; ( d == 29 =&gt; is_leap_year(y) ) }
    fn ok_year(d:int, m:int, y:int) -&gt; bool { 1 &lt;= y &amp;&amp; (m == 2 =&gt; is_feb_day(d, y)) }
}]

// https://github.com/chrisdone/sandbox/blob/master/liquid-haskell-dates.hs

#[allow(dead_code)]
#[flux::refined_by(d:int, m:int, y:int)]
pub struct Date {
    #[flux::field({ usize[d] | ok_day(d) })]
    day: usize,
    #[flux::field({ usize[m] | ok_month(d, m)})]
    month: usize,
    #[flux::field({ usize[y] | ok_year(d, m, y)})]
    year: usize,
}

pub fn test() {
    let _ok_date = Date { day: 9, month: 8, year: 1977 };
}

// TODO: Tedious to duplicate the definitions if you want to use them in rust code.
// Maybe some macro magic can unify?

#[flux::sig(fn(m:usize) -&gt; bool[is_month30(m)])]
fn is_month30(m: usize) -&gt; bool {
    m == 4 || m == 6 || m == 9 || m == 11
}

#[flux::sig(fn(y:usize) -&gt; bool[is_leap_year(y)])]
fn is_leap_year(y: usize) -&gt; bool {
    y % 400 == 0 || (y % 4 == 0 &amp;&amp; y % 100 != 0)
}

#[flux::sig(fn(d:usize, y:usize) -&gt; bool[is_feb_day(d, y)])]
fn is_feb_day(d: usize, y: usize) -&gt; bool {
    d &lt;= 29 &amp;&amp; (d != 29 || is_leap_year(y))
}

pub fn mk_date(day: usize, month: usize, year: usize) -&gt; Option&lt;Date&gt; {
    if 1 &lt;= year &amp;&amp; 1 &lt;= month &amp;&amp; month &lt;= 12 &amp;&amp; 1 &lt;= day &amp;&amp; day &lt;= 31 {
        if !is_month30(month) || day &lt;= 30 {
            if month != 2 || is_feb_day(day, year) {
                return Some(Date { day, month, year });
            }
        }
    }
    return None;
}</code></pre>
<h3 id="invariants-on-structs"><a class="header" href="#invariants-on-structs">Invariants on Structs</a></h3>
<pre><code class="language-rust noplayground">#[flux::refined_by(a: int, b: int)]
#[flux::invariant(a &gt; 0)]
#[flux::invariant(b &gt; 0)]
pub struct S {
    #[flux::field({i32[a] | a &gt; 0})]
    fst: i32,
    #[flux::field({i32[b] | b &gt;= a})]
    snd: i32,
}</code></pre>
<p>with <code>const</code> generics</p>
<pre><code class="language-rust noplayground">// Test that const generics in invariants are properly instantiated

use flux_rs::attrs::*;

#[invariant(N &gt; 0)]
struct S&lt;const N: usize&gt; {}

#[sig(fn(_) -&gt; usize{v : v &gt; 0})]
fn foo&lt;const M: usize&gt;(x: S&lt;M&gt;) -&gt; usize {
    M
}</code></pre>
<h3 id="opaque-structs"><a class="header" href="#opaque-structs">Opaque Structs</a></h3>
<p>Flux offers an attribute <code>opaque</code> which can be used on structs. A module defining an opaque struct should define a trusted API, and clients of the API should not access struct fields directly. This is particularly useful in cases where users need to define a type indexed by a different type than the structs fields. For example, <code>RMap</code> (see below) defines a refined HashMap, indexed by a <code>Map</code> - a primitive sort defined by flux.</p>
<pre><code class="language-rust noplayground">use flux_rs::*;

#[opaque]
#[refined_by(vals: Map&lt;K, V&gt;)]
pub struct RMap&lt;K, V&gt; {
    inner: std::collections::HashMap&lt;K, V&gt;,
}</code></pre>
<p><strong>Note that opaque structs <strong>can not</strong> have refined fields.</strong></p>
<p>Now, we can define <code>get</code> for our refined map as follows:</p>
<pre><code class="language-rust noplayground">impl&lt;K, V&gt; RMap&lt;K, V&gt; {

    #[flux_rs::trusted]
    #[flux_rs::sig(fn(&amp;RMap&lt;K, V&gt;[@m], &amp;K[@k]) -&gt; Option&lt;&amp;V[map_select(m.vals, k)]&gt;)]
    pub fn get(&amp;self, k: &amp;K) -&gt; Option&lt;&amp;V&gt;
    where
        K: Eq + Hash,
    {
        self.inner.get(k)
    }

}</code></pre>
<p>Note that if we do not mark these methods as <code>trusted</code>, we will get an error that looks like...</p>
<pre><code class="language-text">error[E0999]: cannot access fields of opaque struct `RMap`.
  --&gt; ../opaque.rs:22:9
   |
22 |         self.inner.get(k)
   |         ^^^^^^^^^^
-Ztrack-diagnostics: created at crates/flux-refineck/src/lib.rs:111:14
   |
help: if you'd like to use fields of `RMap`, try annotating this method with `#[flux::trusted]`
  --&gt; ../opaque.rs:18:5
   |
18 | /     pub fn get(&amp;self, k: &amp;K) -&gt; Option&lt;&amp;V&gt;
19 | |     where
20 | |         K: Eq + std::hash::Hash,
   | |________________________________^
   = note: fields of opaque structs can only be accessed inside trusted code
</code></pre>
<p>Here is an example of how to use the <code>opaque</code> attribute:</p>
<pre><code class="language-rust noplayground">#[flux::opaque]
#[flux::refined_by(a: int, b: int)]
#[flux::invariant(a &lt;= b)]
pub struct Range {
    a: i32,
    b: i32,
}

impl Range {
    #[flux::trusted]
    #[flux::sig(fn(a: i32, b: i32{b &gt;= a}) -&gt; Range[a, b])]
    pub fn new(a: i32, b: i32) -&gt; Range {
        Range { a, b }
    }

    #[flux::trusted]
    #[flux::sig(fn(&amp;Range[@r]) -&gt; i32[r.a])]
    pub fn fst(&amp;self) -&gt; i32 {
        self.a
    }

    #[flux::trusted]
    #[flux::sig(fn(&amp;Range[@r]) -&gt; i32[r.b])]
    pub fn snd(&amp;self) -&gt; i32 {
        self.b
    }
}

#[flux::sig(fn(Range) -&gt; bool[true])]
fn test(r: Range) -&gt; bool {
    r.snd() - r.fst() &gt;= 0
}</code></pre>
<h2 id="refining-enums-1"><a class="header" href="#refining-enums-1">Refining Enums</a></h2>
<pre><code class="language-rust noplayground">#[flux::refined_by(b:bool)]
pub enum Opt&lt;T&gt; {
    #[flux::variant(Opt&lt;T&gt;[false])]
    None,
    #[flux::variant({T} -&gt; Opt&lt;T&gt;[true])]
    Some(T),
}

#[flux::sig(fn(Opt&lt;T&gt;[@b]) -&gt; bool[b])]
pub fn is_some&lt;T&gt;(x: Opt&lt;T&gt;) -&gt; bool {
    match x {
        Opt::None =&gt; false,
        Opt::Some(_) =&gt; true,
    }
}

#[flux::sig(fn(Opt&lt;T&gt;[@b]) -&gt; bool[b])]
pub fn is_some_flip&lt;T&gt;(x: Opt&lt;T&gt;) -&gt; bool {
    match x {
        Opt::Some(_) =&gt; true,
        Opt::None =&gt; false,
    }
}

#[flux::sig(fn(i32{v:false}) -&gt; T)]
pub fn never&lt;T&gt;(_x: i32) -&gt; T {
    loop {}
}

#[flux::sig(fn(Opt&lt;T&gt;[true]) -&gt; T)]
pub fn unwrap&lt;T&gt;(x: Opt&lt;T&gt;) -&gt; T {
    match x {
        Opt::Some(v) =&gt; v,
        Opt::None =&gt; never(0),
    }
}</code></pre>
<pre><code class="language-rust noplayground">#[flux::refined_by(n: int)]
#[flux::invariant(n &gt; 0)]
pub enum Pos {
    #[flux::variant({Box&lt;Pos[@n]&gt;} -&gt; Pos[2*n])]
    XO(Box&lt;Pos&gt;),
    #[flux::variant({Box&lt;Pos[@n]&gt;} -&gt; Pos[2*n + 1])]
    XI(Box&lt;Pos&gt;),
    #[flux::variant(Pos[1])]
    XH,
}

impl Pos {
    #[flux::spec(fn(&amp;Pos[@n]) -&gt; i32[n])]
    pub fn to_i32(&amp;self) -&gt; i32 {
        match self {
            Pos::XH =&gt; 1,
            Pos::XI(rest) =&gt; 2 * rest.to_i32() + 1,
            Pos::XO(rest) =&gt; 2 * rest.to_i32(),
        }
    }

    #[flux::sig(fn(&amp;Pos[@n]) -&gt; bool[n == 1])]
    pub fn is_one(&amp;self) -&gt; bool {
        match self {
            Pos::XH =&gt; true,
            Pos::XI(_) =&gt; false,
            Pos::XO(_) =&gt; false,
        }
    }
}</code></pre>
<pre><code class="language-rust noplayground">#[flux::sig(fn(i32{v: false}) -&gt; T)]
pub fn never&lt;T&gt;(_: i32) -&gt; T {
    loop {}
}

#[flux::refined_by(n:int)]
#[flux::invariant(n &gt;= 0)]
pub enum List {
    #[flux::variant(List[0])]
    Nil,
    #[flux::variant((i32, Box&lt;List[@n]&gt;) -&gt; List[n+1])]
    Cons(i32, Box&lt;List&gt;),
}

#[flux::sig(fn(&amp;List[@n]) -&gt; bool[n == 0])]
pub fn empty(l: &amp;List) -&gt; bool {
    match l {
        List::Nil =&gt; true,
        List::Cons(_, _) =&gt; false,
    }
}

#[flux::sig(fn(&amp;List[@n]) -&gt; i32[n])]
pub fn len(l: &amp;List) -&gt; i32 {
    match l {
        List::Nil =&gt; 0,
        List::Cons(_, tl) =&gt; 1 + len(tl),
    }
}

#[flux::sig(fn({&amp;List[@n] | 0 &lt; n}) -&gt; i32)]
pub fn head(l: &amp;List) -&gt; i32 {
    match l {
        List::Nil =&gt; never(0),
        List::Cons(h, _) =&gt; *h,
    }
}

#[flux::sig(fn({&amp;List[@n] | 0 &lt; n}) -&gt; &amp;List)]
pub fn tail(l: &amp;List) -&gt; &amp;List {
    match l {
        List::Nil =&gt; never(0),
        List::Cons(_, t) =&gt; t,
    }
}

#[flux::sig(fn(i32, n: usize) -&gt; List[n])]
pub fn clone(val: i32, n: usize) -&gt; List {
    if n == 0 {
        List::Nil
    } else {
        List::Cons(val, Box::new(clone(val, n - 1)))
    }
}

#[flux::sig(fn(List[@n1], List[@n2]) -&gt; List[n1+n2])]
pub fn append(l1: List, l2: List) -&gt; List {
    match l1 {
        List::Nil =&gt; l2,
        List::Cons(h1, t1) =&gt; List::Cons(h1, Box::new(append(*t1, l2))),
    }
}

#[flux::sig(fn(l1: &amp;strg List[@n1], List[@n2]) ensures l1: List[n1+n2])]
pub fn mappend(l1: &amp;mut List, l2: List) {
    match l1 {
        List::Nil =&gt; *l1 = l2,
        List::Cons(_, t1) =&gt; mappend(&amp;mut *t1, l2),
    }
}

#[flux::sig(fn(&amp;List[@n], k:usize{k &lt; n} ) -&gt; i32)]
pub fn get_nth(l: &amp;List, k: usize) -&gt; i32 {
    match l {
        List::Cons(h, tl) =&gt; {
            if k == 0 {
                *h
            } else {
                get_nth(tl, k - 1)
            }
        }
        List::Nil =&gt; never(0),
    }
}</code></pre>
<h3 id="invariants-on-enums"><a class="header" href="#invariants-on-enums">Invariants on Enums</a></h3>
<pre><code class="language-rust noplayground">#[flux::refined_by(n: int)]
#[flux::invariant(n &gt;= 0)]
pub enum E {
    #[flux::variant({{i32[@n] | n &gt; 0}} -&gt; E[n])]
    Pos(i32),
    #[flux::variant({i32[0]} -&gt; E[0])]
    Zero(i32),
}

#[flux::sig(fn(E[@n], i32[n]) -&gt; i32{v: v &gt; 0})]
pub fn is_zero(_: E, x: i32) -&gt; i32 {
    x + 1
}</code></pre>
<h3 id="reflecting-enums"><a class="header" href="#reflecting-enums">Reflecting Enums</a></h3>
<pre><code class="language-rust noplayground">#[flux::reflect]
pub enum State {
    On,
    Off,
}

#[flux_rs::sig(fn () -&gt; State[State::On])]
pub fn test00() -&gt; State {
    State::On
}

#[flux_rs::sig(fn () -&gt; State[State::Off])]
pub fn test01() -&gt; State {
    State::Off
}

#[flux::sig(fn () -&gt; State[State::Off])]
pub fn test02() -&gt; State {
    State::On //~ ERROR refinement type
}

#[flux::sig(fn (State[State::On]) -&gt; usize[1])]
pub fn test03(s: State) -&gt; usize {
    match s {
        State::On =&gt; 1,
        State::Off =&gt; 0,
    }
}

#[flux::sig(fn (State[@squig], zig: usize, tag: Day) -&gt; usize[tag])]
pub fn test04(s: State, _zig: usize, tag: Day) -&gt; usize {
    match s {
        State::On =&gt; 1,  //~ ERROR refinement type
        State::Off =&gt; 0, //~ ERROR refinement type
    }
}

#[flux::refined_by(day: int)]
pub enum Day {
    #[flux::variant(Day[0])]
    Mon,
    #[flux::variant(Day[1])]
    Tue,
    #[flux::variant(Day[2])]
    Wed,
}

#[flux::sig(fn (s:State, zig: usize, tag: Day) -&gt; usize[tag])]
pub fn test05(s: State, _zig: usize, _tag: Day) -&gt; usize {
    match s {
        State::On =&gt; 1,  //~ ERROR refinement type
        State::Off =&gt; 0, //~ ERROR refinement type
    }
}</code></pre>
<h2 id="field-syntax-for-indices"><a class="header" href="#field-syntax-for-indices">Field Syntax for Indices</a></h2>
<h3 id="structs"><a class="header" href="#structs">Structs</a></h3>
<pre><code class="language-rust noplayground">#[flux::refined_by(x: int, y: int)]
pub struct X {
    #[flux::field(u32[x])]
    x: u32,
    #[flux::field(u32[y])]
    y: u32,
}

#[flux::sig(fn (x: X[@old_x]) -&gt; X[X { y: 2, x: 1 }])]
fn f(mut x: X) -&gt; X {
    x.x = 1;
    x.y = 2;
    x
}</code></pre>
<h3 id="enums"><a class="header" href="#enums">Enums</a></h3>
<pre><code class="language-rust noplayground">#[flux::refined_by(x: int, y: int)]
pub enum E {
    #[flux::variant(E[0, 1])]
    Variant1,
    #[flux::variant(E[1, 2])]
    Variant2,
    #[flux::variant(E[2, 3])]
    Variant3,
}

#[flux::sig(fn (e: E[@old_enum]) -&gt; E[E { x: 1, y: 2 }])]
fn f(e: E) -&gt; E {
    E::Variant2
}</code></pre>
<h3 id="updates"><a class="header" href="#updates">Updates</a></h3>
<pre><code class="language-rust noplayground">#[flux::refined_by(x: int, y: int)]
pub struct S {
    #[flux::field(u32[x])]
    x: u32,
    #[flux::field(u32[y])]
    y: u32,
}

impl S {
    #[flux::sig(fn (self: &amp;strg S[@old_x]) ensures self: S[S { x: 1, ..old_x }])]
    pub fn update(&amp;mut self) {
        self.x = 1;
    }
}</code></pre>
<pre><code class="language-rust noplayground">#![flux::defs {
    fn some_computation(s: S) -&gt; S { s }
}]

#[flux::refined_by(x: int, y: int)]
pub struct S {
    #[flux::field(u32[x])]
    x: u32,
    #[flux::field(u32[y])]
    y: u32,
}

impl S {
    #[flux::sig(fn (self: &amp;strg S[@old_x]) ensures self: S[S { x: 1, ..some_computation(old_x) }])]
    pub fn update(&amp;mut self) {
        self.x = 1;
    }

    #[flux::sig(fn (self: &amp;strg S[@old_x]) ensures self: S[S { x: 1, ..S { x: 2, ..old_x } }])]
    pub fn update2(&amp;mut self) {
        self.x = 1;
    }
}</code></pre>
<pre><code class="language-rust noplayground">use flux_rs::*;

#[refined_by(start: T, end: T)]
pub struct Range&lt;T&gt; {
    #[flux::field(T[start])]
    pub start: T,
    #[flux::field(T[end])]
    pub end: T,
}

#[sig(fn(r: Range&lt;T&gt;[@old]) -&gt; Range&lt;T&gt;[ Range { ..old } ])]
pub fn foo&lt;T&gt;(r: Range&lt;T&gt;) -&gt; Range&lt;T&gt; {
    r
}

#[sig(fn(r: Range&lt;i32&gt;{v: v == Range { start: 0, end: 0 } }))]
pub fn foo2(_r: Range&lt;i32&gt;) {}

#[sig(fn(r: Range&lt;i32&gt;[Range { start: 0, end: 0 } ]))]
pub fn foo3(_r: Range&lt;i32&gt;) {}</code></pre>
<pre><code class="language-rust noplayground">#![flux::defs {
    fn some_computation(s: S) -&gt; S { s }
}]

#[flux::refined_by(x: int, y: int)]
pub struct S {
    #[flux::field(u32[x])]
    x: u32,
    #[flux::field(u32[y])]
    y: u32,
}

impl S {
    #[flux::sig(fn (self: &amp;strg S[@old_x]) ensures self: S[{ x: 1, ..some_computation(old_x) }])]
    pub fn update(&amp;mut self) {
        self.x = 1;
    }

    #[flux::sig(fn (self: &amp;strg S[@old_x]) ensures self: S[{ x: 1, ..S { x: 2, ..old_x } }])]
    pub fn update2(&amp;mut self) {
        self.x = 1;
    }
}</code></pre>
<h2 id="const"><a class="header" href="#const">Const</a></h2>
<p>You can use <code>int</code>-ish <code>const</code> in refinements e.g.</p>
<pre><code class="language-rust noplayground">pub struct Cow {}

impl Cow {
    const GRASS: usize = 12;

    #[flux_rs::sig(fn () -&gt; usize[12])]
    pub fn test() -&gt; usize {
        Self::GRASS
    }
}</code></pre>
<pre><code class="language-rust noplayground">#[repr(u32)]
pub enum SyscallReturnVariant {
    Failure = 0,
}

#[flux_rs::sig(fn() -&gt; u32[0])]
pub fn test() -&gt; u32 {
    SyscallReturnVariant::Failure as u32
}</code></pre>
<pre><code class="language-rust noplayground">pub struct Cow {}

const GRASS: usize = 12;
impl Cow {
    #[flux_rs::sig(fn () -&gt; usize[12])]
    fn test() -&gt; usize {
        GRASS
    }
}</code></pre>
<h2 id="requires-with-forall"><a class="header" href="#requires-with-forall">Requires with <code>forall</code></a></h2>
<p>We allow a <code>forall</code> on the requires clauses, e.g.</p>
<pre><code class="language-rust noplayground">#[flux::sig(fn(bool[true]))]
fn assert(_: bool) {}
#[flux::sig(
    fn(x: i32)
    requires forall y. y &gt;= 0 =&gt; y &gt; x
)]
fn requires_negative(x: i32) {
    assert(x + 1 == 1 + x); // make sure there's something to check to avoid optimizing the entire constraint away
}

fn test2() {
    requires_negative(-1);
}</code></pre>
<h2 id="refined-associated-types"><a class="header" href="#refined-associated-types">Refined Associated Types</a></h2>
<pre><code class="language-rust noplayground">use flux_rs::*;

#[sig(fn(bool[true]))]
fn assert(_: bool) {}

trait MyTrait {
    type Assoc;

    #[sig(fn(Self::Assoc[@x]) -&gt; Self::Assoc[x])]
    fn f0(x: Self::Assoc) -&gt; Self::Assoc;

    #[sig(fn(x: Self::Assoc) -&gt; Self::Assoc{ v: v == x })]
    fn f1(x: Self::Assoc) -&gt; Self::Assoc;
}

impl MyTrait for () {
    type Assoc = i32;

    #[sig(fn(x: i32) -&gt; i32[x])]
    fn f0(x: i32) -&gt; i32 {
        x
    }

    #[sig(fn(x: i32) -&gt; i32[x])]
    fn f1(x: i32) -&gt; i32 {
        x
    }
}

fn test00() {
    let x = &lt;() as MyTrait&gt;::f0(0);
    assert(x == 0);
}

fn test01() {
    let x = &lt;() as MyTrait&gt;::f1(0);
    assert(x == 0);
}</code></pre>
<h2 id="ignored-and-trusted-code"><a class="header" href="#ignored-and-trusted-code">Ignored and trusted code</a></h2>
<p>Flux offers two attributes for controlling which parts of your code it analyzes: <code>#[flux_rs::ignore]</code> and <code>#[flux_rs::trusted]</code>.</p>
<ul>
<li><code>#[flux_rs::ignore]</code>: This attribute is applicable to any item, and it instructs Flux to completely skip some code. Flux won't even look at it.</li>
<li><code>#[flux_rs::trusted]</code>: This attribute affects whether Flux checks the body of a function. If a function is marked as trusted, Flux won't verify its body against its signature. However, it will still be able to reason about its signature when used elsewhere.</li>
</ul>
<p>The above means that an <em>ignored</em> function can only be called from ignored or trusted code, while a <em>trusted</em> function can also be called from analyzed code.</p>
<p>Both attributes apply recursively. For instance, if a module is marked as <code>#[flux_rs::ignore]</code>, all its nested elements will also be ignored. This transitive behavior can be disabled by marking an item with <code>#[flux_rs::ignore(no)]</code><sup class="footnote-reference" id="fr-ignore-shorthand-1"><a href="#footnote-ignore-shorthand">1</a></sup>, which will include all nested elements for analysis. Similarly,
the action of <code>#[flux_rs::trusted]</code> can be reverted using <code>#[flux_rs::trusted(no)]</code>.</p>
<p>Consider the following example:</p>
<pre><code class="language-rust noplayground">#[flux_rs::ignore]
mod A {

   #[flux_rs::ignore(no)]
   mod B {
      mod C {
         fn f1() {}
      }
   }

   mod D {
      fn f2() {}
   }

   fn f3() {}
}</code></pre>
<p>In this scenario, functions <code>f2</code> and <code>f3</code> will be ignored, while <code>f1</code> will be analyzed.</p>
<p>A typical pattern when retroactively adding Flux annotations to existing code is to ignore an entire crate (using the inner attribute <code>#![flux_rs::ignore]</code> at the top of the crate) and then selectively include specific sections for analysis.</p>
<p>Here is an example</p>
<pre><code class="language-rust noplayground">#![flux::ignore] // default to ignore for the entire crate

#[flux::ignore(no)] // include this module
mod included {
    #[flux::sig(fn(bool[true]))]
    pub fn assert(_: bool) {}

    pub fn test1() {
        // we are indeed checking this code
        assert(20 &lt; 10); //~ ERROR refinement type error
    }

    pub fn test2() {
        // we cannot use an ignored function in included code
        crate::ignored_fun(); //~ERROR use of ignored function
    }
}

// bad refinement, but no error since we are ignoring this function
#[flux::sig(fn(i32, i32))]
pub fn malformed(_: i32) {}

// an ignored function that cannot be used in included code
pub fn ignored_fun() {}</code></pre>
<h2 id="pragma-should_fail"><a class="header" href="#pragma-should_fail">Pragma: <code>should_fail</code></a></h2>
<p>Used to tell <code>flux</code> to <em>expect</em> a failure when checking a function.</p>
<pre><code class="language-rust noplayground">// This function has an error
// but it's marked as should_fail so that ok.
// flux would yell if instead it verified!

#[flux::should_fail]
#[flux::sig(fn(x: i32) -&gt; i32[x + 1])]
fn test00(x: i32) -&gt; i32 {
    x + 2
}</code></pre>
<h2 id="const-generics-2"><a class="header" href="#const-generics-2">Const Generics</a></h2>
<p><code>flux</code> lets you use Rust's const-generics inside refinements.</p>
<p><strong>Refining Array Lengths</strong></p>
<pre><code class="language-rust noplayground">// https://github.com/flux-rs/flux/issues/625

const BUFLEN: usize = 100;

pub struct Blob {
    data: [i32; BUFLEN],
}

pub fn test(buf: &amp;[i32; BUFLEN]) -&gt; i32 {
    let x0 = buf[0];
    let x1 = buf[10];
    let x2 = buf[BUFLEN - 1];
    let xbad = buf[BUFLEN]; //~ ERROR assertion might fail
    x0 + x1 + x2 + xbad
}

pub fn test_blob(blob: Blob) -&gt; i32 {
    let x0 = blob.data[0];
    let x1 = blob.data[10];
    let x2 = blob.data[BUFLEN - 1];
    let xbad = blob.data[BUFLEN]; //~ ERROR assertion might fail
    x0 + x1 + x2 + xbad
}</code></pre>
<p><strong>Refining Struct Fields</strong></p>
<pre><code class="language-rust noplayground">#[flux::invariant(N &gt; 0)]
pub struct MPU&lt;const N: usize&gt; {
    #[flux::field({ i32 | N &gt; 0 })]
    field: i32,
}

pub fn foo&lt;const N: usize&gt;(x: usize, _mpu: MPU&lt;N&gt;) {
    let _x = x % N;
}

#[flux::invariant(N &gt; 0)]
pub struct MPUGOOD&lt;const N: usize&gt; {
    field: i32,
}

pub fn bar&lt;const N: usize&gt;(x: usize, _mpu: MPUGOOD&lt;N&gt;) {
    let _x = x % N;
}

pub fn baz&lt;const N: usize&gt;() -&gt; i32 {
    if N &gt; 0 {
        let mpu = MPUGOOD::&lt;N&gt; { field: 12 };
        mpu.field
    } else {
        0
    }
}</code></pre>
<p><strong>Refining Function Signatures</strong></p>
<pre><code class="language-rust noplayground">#[path = "../../lib/rvec.rs"]
mod rvec;
use rvec::RVec;

/// A statically sized matrix represented with a linear vector
struct Matrix&lt;const N: usize, const M: usize&gt; {
    #[flux::field(RVec&lt;i32&gt;[N * M])]
    inner: RVec&lt;i32&gt;,
}

impl&lt;const N: usize, const M: usize&gt; Matrix&lt;N, M&gt; {
    fn new() -&gt; Matrix&lt;N, M&gt; {
        Matrix { inner: RVec::from_elem_n(0, N * M) }
    }

    #[flux::sig(fn(&amp;mut Self, i: usize{ i &lt; N }, j: usize{ j &lt; M }, v: i32))]
    fn set(&amp;mut self, i: usize, j: usize, v: i32) {
        self.inner[i * M + j] = v
    }

    #[flux::sig(fn(&amp;Self, i: usize{ i &lt; N }, j: usize{ j &lt; M }) -&gt; i32)]
    fn get(&amp;self, i: usize, j: usize) -&gt; i32 {
        self.inner[i * M + j]
    }
}</code></pre>
<h2 id="type-aliases"><a class="header" href="#type-aliases">Type Aliases</a></h2>
<p>You can define refined <strong>type aliases</strong> for Rust types.</p>
<p><strong>Note</strong></p>
<ol>
<li>They are connected to an underlying Rust type,</li>
<li>They may also be parameterized by refinements, e.g. <code>Lb</code></li>
<li>There are two different kinds of parametrizations
<ul>
<li><em>early</em> (<code>Nat</code>) and</li>
<li><em>late</em> (<code>Lb</code>).</li>
</ul>
</li>
</ol>
<pre><code class="language-rust noplayground">#[flux::alias(type Nat[n: int] = {i32[n] | 0 &lt;= n})]
type Nat = i32;

#[flux::alias(type Lb(n: int)[v: int] = {i32[v] | n &lt;= v})]
type Lb = i32;

#[flux::sig(fn(x: Nat) -&gt; Nat)]
pub fn test1(x: Nat) -&gt; Nat {
    x + 1
}

#[flux::sig(fn(x: Lb(10)) -&gt; Lb(10))]
pub fn test2(x: Lb) -&gt; Lb {
    x + 1
}</code></pre>
<h2 id="spec-function-definitions"><a class="header" href="#spec-function-definitions">Spec Function Definitions</a></h2>
<p>You can define <strong>spec functions</strong> that abstract complicated refinements into refinement-level
functions, which can then be used in refinements.</p>
<h3 id="plain-expressions"><a class="header" href="#plain-expressions">Plain Expressions</a></h3>
<pre><code class="language-rust noplayground">#![flux::defs {
    fn is_btwn(v:int, lo:int, hi: int) -&gt; bool { lo &lt;= v &amp;&amp; v &lt;= hi }
    fn ok_day(d:int) -&gt; bool { is_btwn(d, 1, 31) }
    fn is_month30(m:int) -&gt; bool { m == 4 || m == 6 || m == 9 || m == 11 }
    fn ok_month(d:int, m:int) -&gt; bool { is_btwn(m, 1, 12) &amp;&amp; (is_month30(m) =&gt; d &lt;= 30) }
    fn is_leap_year(y:int) -&gt; bool { y % 400 == 0 || (y % 4 == 0 &amp;&amp; (y % 100) &gt; 0) }
    fn is_feb_day(d:int, y:int) -&gt; bool { d &lt;= 29 &amp;&amp; ( d == 29 =&gt; is_leap_year(y) ) }
    fn ok_year(d:int, m:int, y:int) -&gt; bool { 1 &lt;= y &amp;&amp; (m == 2 =&gt; is_feb_day(d, y)) }
}]

// https://github.com/chrisdone/sandbox/blob/master/liquid-haskell-dates.hs

#[allow(dead_code)]
#[flux::refined_by(d:int, m:int, y:int)]
pub struct Date {
    #[flux::field({ usize[d] | ok_day(d) })]
    day: usize,
    #[flux::field({ usize[m] | ok_month(d, m)})]
    month: usize,
    #[flux::field({ usize[y] | ok_year(d, m, y)})]
    year: usize,
}

pub fn test() {
    let _ok_date = Date { day: 9, month: 8, year: 1977 };
}

// TODO: Tedious to duplicate the definitions if you want to use them in rust code.
// Maybe some macro magic can unify?

#[flux::sig(fn(m:usize) -&gt; bool[is_month30(m)])]
fn is_month30(m: usize) -&gt; bool {
    m == 4 || m == 6 || m == 9 || m == 11
}

#[flux::sig(fn(y:usize) -&gt; bool[is_leap_year(y)])]
fn is_leap_year(y: usize) -&gt; bool {
    y % 400 == 0 || (y % 4 == 0 &amp;&amp; y % 100 != 0)
}

#[flux::sig(fn(d:usize, y:usize) -&gt; bool[is_feb_day(d, y)])]
fn is_feb_day(d: usize, y: usize) -&gt; bool {
    d &lt;= 29 &amp;&amp; (d != 29 || is_leap_year(y))
}

pub fn mk_date(day: usize, month: usize, year: usize) -&gt; Option&lt;Date&gt; {
    if 1 &lt;= year &amp;&amp; 1 &lt;= month &amp;&amp; month &lt;= 12 &amp;&amp; 1 &lt;= day &amp;&amp; day &lt;= 31 {
        if !is_month30(month) || day &lt;= 30 {
            if month != 2 || is_feb_day(day, year) {
                return Some(Date { day, month, year });
            }
        }
    }
    return None;
}</code></pre>
<h3 id="let-binders"><a class="header" href="#let-binders"><code>let</code> binders</a></h3>
<pre><code class="language-rust noplayground">use flux_rs::attrs::*;

defs! {
    fn times2(x: int) -&gt; int {
        x * 2
    }

    fn test(x: int) -&gt; int {
        let y = times2(x);
        let z = times2(y);
        z * z * y
    }
}

#[sig(fn() -&gt; i32[test(10)])]
fn test() -&gt; i32 {
    32000
}</code></pre>
<h3 id="bounded-quantification"><a class="header" href="#bounded-quantification">Bounded Quantification</a></h3>
<pre><code class="language-rust noplayground">#![flux::defs {
    fn magic(xing:int, yonk:int) -&gt; bool;

    fn magic_all(noob:int) -&gt; bool {
        forall i in 0 .. 4 {
            magic(i, noob)
        }
    }

    fn magic_ex(n:int) -&gt; bool {
        exists i in 0 .. 4 {
            i == n
        }
    }
}]

#[flux::trusted]
#[flux::sig(fn(x:i32, y:i32) ensures magic(x, y))]
pub fn do_magic(_x: i32, _y: i32) {}

// forall tests ----------------------------------------------------------------

#[flux::sig(fn({i32[@n] | magic_all(n)}) ensures magic(3, n))]
pub fn test_all_l(_x: i32) {}

#[flux::sig(fn(n:i32) ensures magic_all(n))]
pub fn test_all_r(n: i32) {
    do_magic(0, n);
    do_magic(1, n);
    do_magic(2, n);
    do_magic(3, n);
}

// exists tests ----------------------------------------------------------------
#[flux::sig(fn({i32[@n] | magic_ex(n)}) -&gt; bool[true])]
pub fn test_exi_l(n: i32) -&gt; bool {
    n == 0 || n == 1 || n == 2 || n == 3
}

#[flux::sig(fn(n:i32) -&gt; bool[magic_ex(n)])]
pub fn test_exi_r(n: i32) -&gt; bool {
    n == 0 || n == 1 || n == 2 || n == 3
}</code></pre>
<h3 id="no-cycles"><a class="header" href="#no-cycles">No Cycles!</a></h3>
<p>However, there should be no <em>cyclic dependencies</em> in the function definitions.</p>
<pre><code class="language-rust noplayground">#![flux::defs {
    fn even(x: int) -&gt; bool { x == 0 || odd(x-1) }
    fn odd(x: int) -&gt; bool { x == 1 || even(x-1) } //~ ERROR cycle
}]

#[flux::sig(fn(x:i32) -&gt; i32[x+1])]
pub fn test(x: i32) -&gt; i32 {
    x + 1
}</code></pre>
<h2 id="uninterpreted-function-declarations"><a class="header" href="#uninterpreted-function-declarations">Uninterpreted Function Declarations</a></h2>
<p>You can also declare <em>uninterpreted</em> functions -- about which <code>flux</code> knows nothing
other than the congruence property -- and then use them in refinements. Note that
in this case you have to use a <code>trusted</code> annotation for the function (e.g. <code>is_valid</code>)
that asserts facts over the uninterpreted function</p>
<pre><code class="language-rust noplayground">#![flux::defs {
    fn valid(x:int) -&gt; bool;
}]

#[flux::trusted]
#[flux::sig(fn(x:i32) -&gt; bool[valid(x)])]
fn is_valid(x: i32) -&gt; bool {
    0 &lt;= x &amp;&amp; x &lt;= 100
}

#[flux::sig(fn (i32{v:valid(v)}) -&gt; i32)]
fn bar(a: i32) -&gt; i32 {
    return a;
}

#[flux::sig(fn(i32))]
pub fn test(n: i32) {
    let ok = is_valid(n);
    if ok {
        bar(n);
    }
}</code></pre>
<pre><code class="language-rust noplayground">#![flux::defs {
    fn foo(x:int, y:int) -&gt; int;
}]

#[flux::trusted]
#[flux::sig(fn(x: i32, y:i32) -&gt; i32[foo(x, y)])]
fn foo(x: i32, y: i32) -&gt; i32 {
    x + y
}

#[flux::sig(fn (i32[foo(10, 20)]) -&gt; i32)]
fn bar(a: i32) -&gt; i32 {
    return a;
}

#[flux::sig(fn())]
pub fn test() {
    let a = 10;
    let b = 20;
    let c = foo(a, b);
    bar(c);
}</code></pre>
<h2 id="hiding-and-revealing-function-definitions"><a class="header" href="#hiding-and-revealing-function-definitions">Hiding and Revealing Function Definitions</a></h2>
<p>By default all the function definitions are either <em>inlined</em> or sent to the SMT solver
as <code>define-fun</code> (when run with <code>FLUX_SMT_DEFINE_FUN=1</code>). Sometimes we want to <em>hide</em> the
definition because reasoning about those functions can kill the solver -- or the function
is super complex and we just want to reason about it via congruence. For that you can</p>
<ul>
<li>use the <code>#[hide]</code> attribute at the spec function definition, to make the function <em>uninterpreted</em> by default, and</li>
<li>use the <code>#[reveal]</code> attribute at specific Rust function definition, to indicate you
want to use the actual definition when checking that Rust function.</li>
</ul>
<pre><code class="language-rust noplayground">#![flux::defs {
    #[hide]
    fn mod33(n:int) -&gt; int {
        n % 33
    }

    #[hide]
    fn foo(n:int, k:int) -&gt; bool {
      mod33(n) == k
    }

}]

#[flux::sig(fn (a:i32) requires foo(a, 7))]
pub fn assert_foo(_a: i32) {}

#[flux::reveal(foo, mod33)]
pub fn use_foo(n: i32) {
    if n == 40 {
        assert_foo(n)
        // without `reveal(foo)` we want to see an error in the above line.
    }
}

#[flux::sig(fn (xs: &amp;[i32{v: foo(v, 7)}][100]) -&gt; i32{v : foo(v, 7)})]
pub fn bar(xs: &amp;[i32]) -&gt; i32 {
    xs[0] // `foo` as uninterpreted works fine
}</code></pre>
<h2 id="spec-functions-in-smtlib"><a class="header" href="#spec-functions-in-smtlib">Spec Functions in SMTLIB</a></h2>
<p>By default <code>flux</code> inlines all such function definitions.</p>
<p>Monomorphic functions may <em>optionally</em> be encoded
as functions in SMT by using the <code>FLUX_SMT_DEFINE_FUN=1</code>
environment variable.</p>
<h2 id="type-holes"><a class="header" href="#type-holes">Type Holes</a></h2>
<p>You can (sometimes!) use <code>_</code> in the <code>flux</code> signatures to omit the Rust components, e.g.</p>
<h3 id="function-signatures"><a class="header" href="#function-signatures">Function Signatures</a></h3>
<pre><code class="language-rust noplayground">#[flux::sig(fn(_) -&gt; Option&lt;_&gt;)]
fn test00(x: i32) -&gt; Option&lt;i32&gt; {
    Some(x)
}

#[flux::sig(fn(x: &amp;strg _) ensures x: i32[0])]
fn test01(x: &amp;mut i32) {
    *x = 0;
}

#[flux::sig(fn(x: &amp;strg i32) ensures x: _)]
fn test02(x: &amp;mut i32) {
    *x = 0;
}</code></pre>
<h3 id="structs-and-enums"><a class="header" href="#structs-and-enums">Structs and Enums</a></h3>
<pre><code class="language-rust noplayground">// Type holes in structs and enums

pub struct S {
    #[flux::field(Option&lt;_&gt;)]
    x: Option&lt;i32&gt;,
}

pub fn test_s(s: S) -&gt; Option&lt;i32&gt; {
    s.x
}

pub enum E {
    #[flux::variant((_) -&gt; E)]
    A(i32),
}

pub fn test_e(e: E) -&gt; i32 {
    match e {
        E::A(x) =&gt; x,
    }
}</code></pre>
<h3 id="type-aliases-1"><a class="header" href="#type-aliases-1">Type Aliases</a></h3>
<pre><code class="language-rust noplayground">#[flux::alias(type Test = Vec&lt;_&gt;)]
type Test = Vec&lt;i32&gt;;

fn test(x: Test) -&gt; Vec&lt;i32&gt; {
    x
}</code></pre>
<h3 id="generic-args"><a class="header" href="#generic-args">Generic Args</a></h3>
<pre><code class="language-rust noplayground">#[flux_rs::refined_by(m: Map&lt;int, int&gt;)]
#[flux_rs::opaque]
pub struct S1&lt;const N: usize&gt; {
    _arr: [usize; N],
}

const MY_N: usize = 10;

#[flux_rs::refined_by(gloop: S1)]
pub struct S2 {
    #[field(S1&lt;_&gt;[gloop])]
    pub s1: S1&lt;MY_N&gt;,
}

#[flux_rs::refined_by(zoo: S1)]
pub struct S3&lt;const M: usize&gt; {
    #[field(S1&lt;_&gt;[zoo])]
    pub s1: S1&lt;M&gt;,
}</code></pre>
<h2 id="closures"><a class="header" href="#closures">Closures</a></h2>
<pre><code class="language-rust noplayground">use flux_rs::attrs::*;

#[trusted]
#[spec(fn(c: Option&lt;bool&gt;) -&gt; Option&lt;i32{v:0 &lt;= v}&gt;)]
pub fn test0(c: Option&lt;bool&gt;) -&gt; Option&lt;i32&gt; {
    c.map(|b| if b { 1 } else { 2 })
}

// pub fn test0_buddy(x: i32) -&gt; i32 {
//     x + 1
// }

// #[flux::sig(fn(c: Option&lt;bool&gt;) -&gt; Option&lt;i32{v:1 &lt;= v}&gt;)]
// pub fn test1(c: Option&lt;bool&gt;) -&gt; Option&lt;i32&gt; {
//     c.map(|b| if b { 1 } else { 2 })
// }

// #[flux::sig(fn(c: Option&lt;bool[true]&gt;) -&gt; Option&lt;i32[1]&gt;)]
// pub fn test2(c: Option&lt;bool&gt;) -&gt; Option&lt;i32&gt; {
//     c.map(|b| if b { 1 } else { 2 })
// }

// #[flux::sig(fn(n:usize) -&gt; usize[n + 2])]
// pub fn test3(n: usize) -&gt; usize {
//     checked_add(n, 1)
//         .and_then(|m| Some(m + 1))
//         .expect("overflow")
// }

// #[flux::trusted]
// #[flux::sig(fn(n:usize, m:usize) -&gt; Option&lt;usize[n + m]&gt;)]
// pub fn checked_add(n: usize, m: usize) -&gt; Option&lt;usize&gt; {
//     n.checked_add(m)
// }</code></pre>
<pre><code class="language-rust noplayground">#[path = "../../lib/rvec.rs"]
mod rvec;
use rvec::RVec;

#[flux::trusted]
fn smap&lt;S, F, A, B&gt;(s: S, v: Vec&lt;A&gt;, f: F) -&gt; Vec&lt;B&gt;
where
    F: Fn(S, A) -&gt; B,
    S: Copy,
{
    v.into_iter().map(|x| f(s, x)).collect()
}

#[flux::sig(fn(vs: Vec&lt;i32{v:0&lt;=v}&gt;) -&gt; Vec&lt;i32{v:3&lt;=v}&gt;)]
pub fn test1_old(vs: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    let st = 3;
    smap(st, vs, |s, x| s + x)
}

#[flux::sig(fn(vs: Option&lt;i32{v:0&lt;=v}&gt;) -&gt; Option&lt;i32{v:3&lt;=v}&gt;)]
pub fn test2_old(vs: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    let y = 1;
    let z = 2;
    vs.map(|x| x + y + z)
}

pub struct Foo {
    #[flux::field(i32{v: 10 &lt;= v})]
    pub val: i32,
}

pub fn test1(c: Option&lt;bool&gt;) -&gt; Option&lt;Foo&gt; {
    let x = 6;
    let y = 10;
    c.map(|b| if b { Foo { val: x + y } } else { Foo { val: 20 } })
}

#[flux::sig(fn(vec:&amp;RVec&lt;i32{v: 10 &lt;= v}&gt;{v: 0 &lt; v}) -&gt; Foo)]
fn bob(vec: &amp;RVec&lt;i32&gt;) -&gt; Foo {
    Foo { val: vec[0] }
}

pub fn test2(c: Option&lt;bool&gt;) -&gt; Option&lt;Foo&gt; {
    let vec = rvec![100, 200, 300];
    c.map(|b| if b { bob(&amp;vec) } else { Foo { val: 20 } })
}

#[flux::trusted]
fn frob(_vec: &amp;RVec&lt;RVec&lt;i32&gt;&gt;) -&gt; Foo {
    todo!()
}

pub fn test3(c: Option&lt;bool&gt;, vec: RVec&lt;RVec&lt;i32&gt;&gt;) -&gt; Option&lt;Foo&gt; {
    // let mut vec = rvec![rvec![100, 200, 300]];
    c.map(|b| if b { frob(&amp;vec) } else { Foo { val: 20 } })
}</code></pre>
<h2 id="function-pointers"><a class="header" href="#function-pointers">Function Pointers</a></h2>
<pre><code class="language-rust noplayground">#![allow(unused)]

#[flux::sig(fn (x:usize) -&gt; usize[x+1])]
fn inc(x: usize) -&gt; usize {
    x + 1
}

#[flux::sig(fn(c: Option&lt;usize[99]&gt;) -&gt; Option&lt;usize[100]&gt;)]
pub fn test_ok(c: Option&lt;usize&gt;) -&gt; Option&lt;usize&gt; {
    c.map(inc)
}</code></pre>
<pre><code class="language-rust noplayground">#![allow(unused)]

fn id&lt;T&gt;(x: T) -&gt; T {
    x
}

#[flux::sig(fn(c: Option&lt;usize[99]&gt;) -&gt; Option&lt;usize[99]&gt;)]
pub fn test_ok(c: Option&lt;usize&gt;) -&gt; Option&lt;usize&gt; {
    c.map(id)
}

#[flux::sig(fn(Option&lt;i32[99]&gt;) -&gt; Option&lt;i32[99]&gt;)]
fn test_also_ok(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    let f = id;
    x.map(f)
}</code></pre>
<pre><code class="language-rust noplayground">use flux_rs::*;

#[sig(fn(x: i32{x != 0}) -&gt; i32[1/x])]
fn div(x: i32) -&gt; i32 {
    1 / x
}

fn apply&lt;A, B&gt;(f: impl FnOnce(A) -&gt; B, x: A) -&gt; B {
    f(x)
}

#[sig(fn() -&gt; i32[0])]
fn test() -&gt; i32 {
    apply(div, 10)
}</code></pre>
<h2 id="traits-and-implementations"><a class="header" href="#traits-and-implementations">Traits and Implementations</a></h2>
<pre><code class="language-rust noplayground">pub trait MyTrait {
    fn foo() -&gt; i32;
    fn bar();
}

pub struct MyTy;

impl MyTrait for MyTy {
    #[flux::sig(fn () -&gt; i32[10])]
    fn foo() -&gt; i32 {
        10
    }

    fn bar() {}
}

#[flux::sig(fn () -&gt; i32[10])]
pub fn test() -&gt; i32 {
    let n = MyTy::foo();
    MyTy::bar();
    n
}</code></pre>
<pre><code class="language-rust noplayground">pub trait Mono {
    #[flux::sig(fn (zing: &amp;strg i32[@n]) ensures zing: i32{v:n &lt; v})]
    fn foo(z: &amp;mut i32);
}

pub struct Tiger;

impl Mono for Tiger {
    #[flux::sig(fn (pig: &amp;strg i32[@m]) ensures pig: i32{v:m &lt; v})]
    fn foo(pig: &amp;mut i32) {
        *pig += 1;
    }
}

pub struct Snake;

impl Mono for Snake {
    #[flux::sig(fn (pig: &amp;strg i32[@m]) ensures pig: i32[m+1])]
    fn foo(pig: &amp;mut i32) {
        *pig += 1;
    }
}</code></pre>
<pre><code class="language-rust noplayground">pub trait Mono {
    #[flux::sig(fn (zing: &amp;strg i32[@n])
                  requires 100 &lt; n
                  ensures zing: i32{v:n &lt; v})]
    fn foo(z: &amp;mut i32);
}

pub struct Tiger;

impl Mono for Tiger {
    #[flux::sig(fn (pig: &amp;strg i32[@m])
                  requires 0 &lt; m
                  ensures pig: i32{v:m &lt; v})]
    fn foo(pig: &amp;mut i32) {
        *pig += 1;
    }
}

pub struct Snake;

impl Mono for Snake {
    #[flux::sig(fn (pig: &amp;strg {i32[@m] | 0 &lt; m})
                ensures pig: i32[m+1])]
    fn foo(pig: &amp;mut i32) {
        *pig += 1;
    }
}</code></pre>
<pre><code class="language-rust noplayground">pub trait MyTrait {
    #[flux::sig(fn[hrn p: Self -&gt; bool](&amp;Self{v: p(v)}) -&gt; Self{v: p(v)})]
    fn foo1(&amp;self) -&gt; Self;

    fn foo2(&amp;self) -&gt; Self;
}

impl MyTrait for i32 {
    // TODO: error-message when below is missing (currently: fixpoint crash!) see tests/tests/todo/trait13.rs
    #[flux::sig(fn[hrn p: Self -&gt; bool](&amp;Self{v: p(v)}) -&gt; Self{v: p(v)})]
    fn foo1(&amp;self) -&gt; Self {
        *self
    }

    #[flux::sig(fn[hrn q: Self -&gt; bool](&amp;Self{v: q(v)}) -&gt; Self{v: q(v)})]
    fn foo2(&amp;self) -&gt; Self {
        *self
    }
}

#[flux::sig(fn[hrn q: T -&gt; bool](&amp;T{v:q(v)}) -&gt; T{v: q(v)})]
pub fn bar1&lt;T: MyTrait&gt;(x: &amp;T) -&gt; T {
    x.foo1()
}

#[flux::sig(fn(bool[true]))]
fn assert(_b: bool) {}

pub fn test() {
    let x = 42;
    assert(bar1(&amp;x) == 42);
    assert(x.foo2() == 42);
}</code></pre>
<pre><code class="language-rust noplayground">pub trait Silly&lt;A&gt; {
    #[flux::sig(fn(&amp;Self, z: A) -&gt; i32{v:100 &lt; v})]
    fn bloop(&amp;self, z: A) -&gt; i32;
}

impl Silly&lt;bool&gt; for i32 {
    #[flux::sig(fn(&amp;Self, b : bool) -&gt; i32[2000])]
    fn bloop(&amp;self, _b: bool) -&gt; i32 {
        2000
    }
}

#[flux::sig(fn(i32) -&gt; i32{v: 100 &lt; v})]
pub fn client(x: i32) -&gt; i32 {
    let y = x.bloop(true);
    y + 1
}

#[flux::sig(fn(_, _) -&gt; i32{v:100 &lt; v})]
pub fn client2&lt;A, B: Silly&lt;A&gt;&gt;(x: B, y: A) -&gt; i32 {
    x.bloop(y)
}</code></pre>
<h2 id="impl-trait"><a class="header" href="#impl-trait">Impl Trait</a></h2>
<pre><code class="language-rust noplayground">pub fn test1() -&gt; impl Iterator&lt;Item = i32&gt; {
    Some(10).into_iter()
}

#[flux::sig(fn () -&gt; impl Iterator&lt;Item = i32{v:1&lt;=v}&gt;)]
pub fn test2() -&gt; impl Iterator&lt;Item = i32&gt; {
    Some(10).into_iter()
}

#[flux::sig(fn () -&gt; impl Iterator&lt;Item = i32{v:1&lt;=v}&gt;)]
pub fn test_lib() -&gt; impl Iterator&lt;Item = i32&gt; {
    Some(10).into_iter()
}

#[flux::sig(fn () -&gt; Option&lt;i32{v:0&lt;=v}&gt;)]
pub fn test_client() -&gt; Option&lt;i32&gt; {
    let mut it = test_lib();
    it.next()
}</code></pre>
<pre><code class="language-rust noplayground">#[flux::sig(fn (x:i32) -&gt; impl Iterator&lt;Item = i32{v:x&lt;=v}&gt;)]
pub fn lib(x: i32) -&gt; impl Iterator&lt;Item = i32&gt; {
    Some(x).into_iter()
}

#[flux::sig(fn (k:i32) -&gt; Option&lt;i32{v:k&lt;=v}&gt;)]
pub fn test_client(k: i32) -&gt; Option&lt;i32&gt; {
    let mut it = lib(k);
    it.next()
}</code></pre>
<h2 id="dynamic-trait-objects"><a class="header" href="#dynamic-trait-objects">Dynamic Trait Objects</a></h2>
<pre><code class="language-rust noplayground">#![allow(unused)]

// ------------------------------------------------------

trait Shape {
    #[flux::sig(fn(self: _) -&gt; i32{v: 0 &lt;= v})]
    fn vertices(&amp;self) -&gt; i32;
}

// ------------------------------------------------------

struct Circle {}

impl Shape for Circle {
    #[flux::sig(fn(self: _) -&gt; i32{v: 0 &lt;= v})]
    fn vertices(&amp;self) -&gt; i32 {
        0
    }
}

// ------------------------------------------------------

#[flux::sig(fn(shape: _) -&gt; i32{v: 0 &lt;= v})]
fn count(shape: &amp;dyn Shape) -&gt; i32 {
    shape.vertices()
}

#[flux::sig(fn(shape: _) -&gt; i32{v: 10 &lt;= v})]
fn count_bad(shape: &amp;dyn Shape) -&gt; i32 {
    shape.vertices() //~ ERROR: refinement type
}

fn main() {
    let c = Circle {};
    count(&amp;c);
    count_bad(&amp;c);
}</code></pre>
<h2 id="generic-refinements"><a class="header" href="#generic-refinements">Generic Refinements</a></h2>
<p><code>flux</code> supports <em>generic refinements</em> see <a href="https://dl.acm.org/doi/10.1145/3704885">this paper for details</a></p>
<p><strong>Horn Refinements</strong></p>
<pre><code class="language-rust noplayground">// Define a function whose type uses the Horn generic refinement `p`
#[flux::sig(
    fn[hrn p: int -&gt; bool](x: i32, y: i32) -&gt; i32{v: p(v) &amp;&amp; v &gt;= x &amp;&amp; v &gt;= y}
    requires p(x) &amp;&amp; p(y)
)]
fn max(x: i32, y: i32) -&gt; i32 {
    if x &gt; y { x } else { y }
}

// A client of `max` where the generic is instantiated to `|v| {v % 2 == 0}`
#[flux::sig(fn() -&gt; i32{v: v % 2 == 0})]
pub fn test00() -&gt; i32 {
    max(4, 10)
}

// A client of `max` where the generic is instantiated to `|v| {v == 4 || v == 10}`
#[flux::sig(fn() -&gt; i32[10])]
pub fn test01() -&gt; i32 {
    max(4, 10)
}</code></pre>
<pre><code class="language-rust noplayground">#[flux::refined_by(a: int, b: int, hrn p: (int, int) -&gt; bool)]
struct Pair {
    #[flux::field(i32[a])]
    fst: i32,
    #[flux::field({i32[b] | p(a, b)})]
    snd: i32,
}

#[flux::sig(fn() -&gt; Pair)]
fn test00() -&gt; Pair {
    Pair { fst: 0, snd: 1 }
}

#[flux::sig(fn(Pair[@a, @b, |a, b| a &lt; b]) -&gt; i32{v: v &gt; 0})]
fn test01(pair: Pair) -&gt; i32 {
    pair.snd - pair.fst
}

fn test02() {
    let pair = Pair { fst: 0, snd: 1 };
    let x = test01(pair);
}

#[flux::sig(fn(x: i32, Pair[@a, @b, |a, b| a &gt; x]) -&gt; i32{v: v &gt; x})]
fn test03(x: i32, pair: Pair) -&gt; i32 {
    pair.fst
}

fn test04() {
    let pair = Pair { fst: 10, snd: 0 };
    test03(0, pair);
}</code></pre>
<pre><code class="language-rust noplayground">#[derive(Clone, Copy)]
#[flux::refined_by(hrn p: int -&gt; bool)]
pub struct S;

#[flux::sig(fn(x: i32) -&gt; S[|y| y &gt; x])]
pub fn gt(x: i32) -&gt; S {
    S
}

#[flux::sig(fn(x: i32) -&gt; S[|y| y &lt; x])]
pub fn lt(x: i32) -&gt; S {
    S
}

#[flux::sig(fn(S[@p1], S[@p2]) -&gt; S[|x| p1(x) || p2(x)])]
pub fn or(_: S, _: S) -&gt; S {
    S
}

#[flux::sig(fn(S[@p], x: i32{ p(x) }))]
pub fn check(_: S, x: i32) {}

pub fn test() {
    let s = or(gt(10), lt(0));
    check(s, 11);
    check(s, -1);
}</code></pre>
<p><strong>Hindley Refinements</strong></p>
<p>TODO</p>
<h2 id="bitvector-refinements"><a class="header" href="#bitvector-refinements">Bitvector Refinements</a></h2>
<h3 id="operators"><a class="header" href="#operators">Operators</a></h3>
<pre><code class="language-rust noplayground">// https://github.com/flux-rs/flux/issues/1010

use flux_rs::{attrs::*, bitvec::BV32};

#[sig(fn (x:BV32{x == 1}) ensures (bv_shl(x, 3) == 8))]
pub fn test_shl_a(_x: BV32) {}

#[sig(fn (x:BV32{x == 1}) ensures (x &lt;&lt; 3 == 8))]
pub fn test_shl_b(_x: BV32) {}

#[sig(fn (x:BV32{x == 8}) ensures (bv_lshr(x, 3) == 1))]
pub fn test_shr_a(_x: BV32) {}

#[sig(fn (x:BV32{x == 8}) ensures (x &gt;&gt; 3 == 1))]
pub fn test_shr_b(_x: BV32) {}

#[sig(fn (x:BV32{x == 8}) ensures (bv_or(x, 3) == 11))]
pub fn test_or_a(_x: BV32) {}

#[sig(fn (x:BV32{x == 8}) ensures (x | 3 == 11))]
pub fn test_or_b(_x: BV32) {}

#[sig(fn (x:BV32{x == 10}) ensures (bv_and(x, 3) == 2))]
pub fn test_and_a(_x: BV32) {}

#[sig(fn (x:BV32{x == 10}) ensures (x &amp; 3 == 2))]
pub fn test_and_b(_x: BV32) {}</code></pre>
<pre><code class="language-rust noplayground">use flux_rs::{attrs::*, bitvec::BV32};

#[sig(fn(x: BV32) -&gt; BV32[bv_add(x, bv_int_to_bv32(1))])]
pub fn test_00(x: BV32) -&gt; BV32 {
    x + BV32::new(1)
}

#[sig(fn(x: BV32) -&gt; BV32[x + bv_int_to_bv32(1)])]
pub fn test_01(x: BV32) -&gt; BV32 {
    x + BV32::new(1)
}

#[sig(fn(x: BV32) -&gt; BV32[x + 1])]
pub fn test_02(x: BV32) -&gt; BV32 {
    x + BV32::new(1)
}

#[sig(fn(x: i32) -&gt; i32[x + (1 + 2)])]
pub fn test_03(x: i32) -&gt; i32 {
    x + 3
}

#[sig(fn() -&gt; BV32[bv_int_to_bv32(0x5)])]
pub fn test_04() -&gt; BV32 {
    BV32::new(0x5)
}

#[sig(fn() -&gt; BV32[5])]
pub fn test_05() -&gt; BV32 {
    BV32::new(0x5)
}

#[sig(fn(x: BV32, y:BV32) -&gt; bool[x + y &gt; 5])]
pub fn test_06(x: BV32, y: BV32) -&gt; bool {
    x + y &gt; BV32::new(5)
}

#[sig(fn(x: BV32, y:BV32) -&gt; bool[x + y &gt; x - y])]
pub fn test_07(x: BV32, y: BV32) -&gt; bool {
    x + y &gt; x - y
}</code></pre>
<pre><code class="language-rust noplayground">use std::ops::{Add, Sub};

#[flux::opaque]
#[flux::refined_by(x: bitvec&lt;32&gt;)]
pub struct BV32(u32);

impl BV32 {
    #[flux::trusted]
    #[flux::sig(fn (u32[@x]) -&gt; BV32[bv_int_to_bv32(x)])]
    pub fn new(x: u32) -&gt; Self {
        BV32(x)
    }
}

impl Add for BV32 {
    type Output = BV32;

    #[flux_rs::trusted]
    #[flux_rs::sig(fn (BV32[@val1], BV32[@val2]) -&gt; BV32[bv_add(val1, val2)])]
    fn add(self, rhs: Self) -&gt; BV32 {
        BV32(self.0 + rhs.0)
    }
}

impl Sub for BV32 {
    type Output = BV32;

    #[flux_rs::trusted]
    #[flux_rs::sig(fn (BV32[@val1], BV32[@val2]) -&gt; BV32[bv_sub(val1, val2)])]
    fn sub(self, rhs: Self) -&gt; BV32 {
        BV32(self.0.wrapping_add(!rhs.0))
    }
}

impl PartialEq for BV32 {
    #[flux::trusted]
    #[flux::sig(fn (&amp;BV32[@val1], &amp;BV32[@val2]) -&gt; bool[val1 == val2])]
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        self.0 == other.0
    }

    #[flux::trusted]
    #[flux::sig(fn (&amp;BV32[@val1], &amp;BV32[@val2]) -&gt; bool[val1 != val2])]
    fn ne(&amp;self, other: &amp;Self) -&gt; bool {
        self.0 != other.0
    }
}

impl PartialOrd for BV32 {
    #[flux::trusted]
    fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;std::cmp::Ordering&gt; {
        self.0.partial_cmp(&amp;other.0)
    }

    #[flux::trusted]
    #[flux::sig(fn (&amp;BV32[@x], &amp;BV32[@y]) -&gt; bool[bv_ule(x, y)])]
    fn le(&amp;self, other: &amp;Self) -&gt; bool {
        self.0 &lt;= other.0
    }

    #[flux::trusted]
    #[flux::sig(fn (&amp;BV32[@x], &amp;BV32[@y]) -&gt; bool[bv_ult(x, y)])]
    fn lt(&amp;self, other: &amp;Self) -&gt; bool {
        self.0 &lt; other.0
    }

    #[flux::trusted]
    #[flux::sig(fn (&amp;BV32[@x], &amp;BV32[@y]) -&gt; bool[bv_uge(x, y)])]
    fn ge(&amp;self, other: &amp;Self) -&gt; bool {
        self.0 &gt;= other.0
    }

    #[flux::trusted]
    #[flux::sig(fn (&amp;BV32[@x], &amp;BV32[@y]) -&gt; bool[bv_ugt(x, y)])]
    fn gt(&amp;self, other: &amp;Self) -&gt; bool {
        self.0 &gt; other.0
    }
}

#[flux::sig(fn (BV32[@x]) -&gt; bool[bv_ule(x, x)])]
pub fn trivial_le(x: BV32) -&gt; bool {
    x &lt;= x
}

#[flux::sig(fn (BV32[@x]) -&gt; bool[bv_ult(x, x)])]
pub fn trivial_lt(x: BV32) -&gt; bool {
    x &lt; x
}

#[flux::sig(fn (BV32[@x]) -&gt; bool[bv_uge(x, x)])]
pub fn trivial_ge(x: BV32) -&gt; bool {
    x &lt;= x
}

#[flux::sig(fn (BV32[@x]) -&gt; bool[bv_ugt(x, x)])]
pub fn trivial_gt(x: BV32) -&gt; bool {
    x &lt; x
}

#[flux::sig(fn (BV32[@x], BV32[@y]) -&gt; bool[
    bv_ule(x, bv_int_to_bv32(10))
    &amp;&amp; 
    bv_uge(y, bv_int_to_bv32(20))
    &amp;&amp;
    bv_ult(x, bv_int_to_bv32(11))
    &amp;&amp;
    bv_ugt(y, bv_int_to_bv32(21))
])]
pub fn real_example(x: BV32, y: BV32) -&gt; bool {
    x &lt;= BV32::new(10) &amp;&amp; y &gt;= BV32::new(20) &amp;&amp; x &lt; BV32::new(11) &amp;&amp; y &gt; BV32::new(21)
}


#[flux_rs::sig(fn (BV32[@x], BV32[@y]) -&gt; bool[true] requires bv_ult(x, y) &amp;&amp; bv_ugt(x, bv_int_to_bv32(0x20)) &amp;&amp; bv_ult(y, bv_int_to_bv32(0xFF)))]
fn lt_imp(x: BV32, y: BV32) -&gt; bool {
    x - BV32::new(0x20) &lt; y + BV32::new(0x20)
}

#[flux_rs::sig(fn (BV32[@x], BV32[@y]) -&gt; bool[true] requires bv_ule(x, y) &amp;&amp; bv_uge(x, bv_int_to_bv32(0x20)) &amp;&amp; bv_ule(y, bv_int_to_bv32(0xFF)))]
fn le_imp(x: BV32, y: BV32) -&gt; bool {
    x - BV32::new(0x20) &lt;= y + BV32::new(0x20)
}

#[flux_rs::sig(fn (BV32[@x], BV32[@y]) -&gt; bool[true] requires bv_ugt(x, y) &amp;&amp; bv_ugt(y, bv_int_to_bv32(0x20)) &amp;&amp; bv_ult(x, bv_int_to_bv32(0xFF)))]
fn gt_imp(x: BV32, y: BV32) -&gt; bool {
    x + BV32::new(0x20) &gt; y - BV32::new(0x20)
}

#[flux_rs::sig(fn (BV32[@x], BV32[@y]) -&gt; bool[true] requires bv_uge(x, y) &amp;&amp; bv_uge(y, bv_int_to_bv32(0x20)) &amp;&amp; bv_ule(x, bv_int_to_bv32(0xFF)))]
fn ge_imp(x: BV32, y: BV32) -&gt; bool {
    x + BV32::new(0x20) &gt;= y - BV32::new(0x20)
}</code></pre>
<h3 id="specification-functions"><a class="header" href="#specification-functions">Specification functions</a></h3>
<pre><code class="language-rust noplayground">use flux_rs::{attrs::*, bitvec::BV32};

defs! {
    fn is_pow2(x: bitvec&lt;32&gt;) -&gt; bool {
        (x &gt; 0) &amp;&amp; ((x &amp; x - 1) == 0)
    }
}

#[sig(fn(x: BV32) requires is_pow2(x) &amp;&amp; 8 &lt;= x ensures x % 8 == 0)]
fn theorem_pow2_octet(x: BV32) {}</code></pre>
<h3 id="extensions"><a class="header" href="#extensions">Extensions</a></h3>
<pre><code class="language-rust noplayground">// https://github.com/flux-rs/flux/issues/686

#[allow(dead_code)]
#[flux::sig(fn(x: bool[true]))]
pub fn assert(_x: bool) {}

#[flux::opaque]
#[flux::refined_by(v: bitvec&lt;32&gt;)]
struct Register {
    inner: u32,
}

impl Register {
    #[flux::sig(fn(u32[@n]) -&gt; Register[bv_int_to_bv32(n)])]
    #[flux::trusted]
    fn new(v: u32) -&gt; Self {
        Register { inner: v }
    }

    #[flux::sig(fn(&amp;Register[@n]) -&gt; u64[bv_bv64_to_int(bv_zero_extend_32_to_64(n))])]
    #[flux::trusted]
    fn zero_extend(&amp;self) -&gt; u64 {
        self.inner as u64
    }

    #[flux::sig(fn(&amp;Register[@n]) -&gt; u64[bv_bv64_to_int(bv_sign_extend_32_to_64(n))])]
    #[flux::trusted]
    fn sign_extend(&amp;self) -&gt; u64 {
        self.inner as i32 as i64 as u64
    }
}

pub fn test_bv_extensions() {
    let r = Register::new(u32::MAX);
    assert(r.zero_extend() == u32::MAX as u64);
    assert(r.zero_extend() == 12); //~ ERROR refinement type
    assert(r.sign_extend() == u64::MAX);
    assert(r.sign_extend() == 12); //~ ERROR refinement type
}</code></pre>
<h3 id="bitvector-constants"><a class="header" href="#bitvector-constants">Bitvector Constants</a></h3>
<pre><code class="language-rust noplayground">#![flux::defs(
    fn is_start(x:bitvec&lt;32&gt;) -&gt; bool { x == START }
)]

#[flux::opaque]
#[flux::refined_by(val: bitvec&lt;32&gt;)]
pub struct BV32(u32);

impl BV32 {
    #[flux::trusted]
    #[flux::sig(fn (x:u32) -&gt; BV32[bv_int_to_bv32(x)])]
    const fn new(val: u32) -&gt; Self {
        BV32(val)
    }
}

#[flux_rs::constant(bv_int_to_bv32(0x4567))]
pub const START: BV32 = BV32::new(0x4567);

#[flux_rs::sig(fn () -&gt; BV32[START])]
pub fn test1() -&gt; BV32 {
    BV32::new(0x4567)
}

#[flux_rs::sig(fn () -&gt; BV32{v: is_start(v)})]
pub fn test2() -&gt; BV32 {
    BV32::new(0x4567)
}

#[flux_rs::sig(fn () -&gt; BV32{v: is_start(v)})]
pub fn test3() -&gt; BV32 {
    BV32::new(0x4568) //~ ERROR: refinement type
}</code></pre>
<h2 id="char-literals"><a class="header" href="#char-literals"><code>char</code> Literals</a></h2>
<pre><code class="language-rust noplayground">#[flux::sig(fn() -&gt; char['a'])]
pub fn char00() -&gt; char {
    'a'
}

#[flux::sig(fn(c: char{v: 'a' &lt;= v &amp;&amp; v &lt;= 'z'}) -&gt; bool[true])]
pub fn lowercase(c: char) -&gt; bool {
    'c' == 'c'
}</code></pre>
<h2 id="string-literals"><a class="header" href="#string-literals"><code>String</code> Literals</a></h2>
<pre><code class="language-rust noplayground">#[flux::sig(fn (&amp;str["cat"]))]
fn require_cat(_x: &amp;str) {}

pub fn test_cat() {
    require_cat("cat");
    require_cat("dog"); //~ ERROR refinement type
}

#[flux::sig(fn (&amp;str[@a], &amp;{str[@b] | a == b}))]
fn require_eq(_x: &amp;str, _y: &amp;str) {}

pub fn test_eq() {
    require_eq("a", "a");
    require_eq("a", "b"); //~ ERROR refinement type
}</code></pre>
<h2 id="extern-specs"><a class="header" href="#extern-specs">Extern Specs</a></h2>
<p>Sometimes you may want to refine a struct or function that outside your code. We
refer to such a specification as an "extern spec," which is short for "external
specification."</p>
<p>Currently, Flux supports extern specs for functions, structs, enums, traits and impls.
The support is a bit rudimentary. For example, multiple impls for a struct (such as <code>&amp;[T]</code>
and <code>[T]</code>) may conflict, and extern specs for structs only support opaque refinements.</p>
<p>Extern specs are given using <code>extern_spec</code> attribute macro, which is provided
by the procedural macros package <code>flux_rs</code>.</p>
<pre><code>use flux_rs::extern_spec;
</code></pre>
<p>The <code>extern_spec</code> is used to provide <code>flux</code> signatures for functions defined in <em>external</em> crates. See the <a href="guide/specs.html">specifications guide</a> for more details.</p>
<h3 id="extern-functions"><a class="header" href="#extern-functions">Extern Functions</a></h3>
<p>An example of refining an extern function can be found
<a href="https://github.com/flux-rs/flux/blob/d49a74dc59b2b9bb1dda01ee019d0ab9a66cdd89/flux-tests/tests/pos/surface/extern_spec_macro.rs">here</a>.</p>
<p>To define an extern spec on a function, you need to do three things, which
happen to correspond to each of the below lines.</p>
<pre><code class="language-rust noplayground">#[extern_spec(std::mem)]
#[spec(fn(x: &amp;mut T[@vx], y: &amp;mut T[@vy]) ensures x: T[vy], y: T[vx])]
fn swap&lt;T&gt;(a: &amp;mut T, b: &amp;mut T);</code></pre>
<ol>
<li>Add the <code>#[extern_spec]</code> attribute. This attribute optionally takes a path;
in the above example, this is <code>std::mem</code>. You can use this path to qualify
the function. So in the above example, the function we are targeting has the
full path of <code>std::mem::swap</code>.</li>
<li>Add a <code>#[spec(...)]</code> (or equivalently <code>#[flux_rs::sig(...)]</code>) attribute, which
is required for any extern spec on a function. This signature behaves as if
the <code>#[flux_rs::trusted]</code> attribute was added, because we cannot <em>actually</em>
check the implementation. Instead, flux just verifies some simple things,
like that the function arguments have compatible types.</li>
<li>Write a function stub whose rust signature matches the external function.</li>
</ol>
<p>If you do the above, you can use <code>std::mem::swap</code> as if it were refined by the
above type.</p>
<p>Here are two examples:</p>
<pre><code class="language-rust noplayground">pub fn test_swap() {
    let mut x = 5;
    let mut y = 10;
    swap(&amp;mut x, &amp;mut y); // actually calls `std::mem::swap`
    assert(x == 10); // verified by flux
    assert(y == 5); // verified by flux
    assert(y == 10); //~ ERROR refinement type
}</code></pre>
<pre><code class="language-rust noplayground">use std::slice::from_ref;

use flux_rs::extern_spec;

#[extern_spec]
#[flux::sig(fn(&amp;T) -&gt; &amp;[T][1])]
fn from_ref&lt;T&gt;(s: &amp;T) -&gt; &amp;[T];

#[flux::sig(fn(&amp;i32) -&gt; &amp;[i32]{n: n &gt; 0})]
pub fn test(x: &amp;i32) -&gt; &amp;[i32] {
    from_ref(x)
}</code></pre>
<h3 id="options"><a class="header" href="#options">Options</a></h3>
<pre><code class="language-rust noplayground">use flux_attrs::*;

#[extern_spec]
#[refined_by(is_some: bool)]
enum Option&lt;T&gt; {
    #[variant(Option&lt;T&gt;[false])]
    None,
    #[variant((T) -&gt; Option&lt;T&gt;[true])]
    Some(T),
}

#[extern_spec]
impl&lt;T&gt; Option&lt;T&gt; {
    #[sig(fn(&amp;Self[@b]) -&gt; bool[b])]
    const fn is_some(&amp;self) -&gt; bool;

    #[sig(fn(&amp;Self[@b]) -&gt; bool[!b])]
    const fn is_none(&amp;self) -&gt; bool;

    #[sig(fn(Option&lt;T&gt;[true]) -&gt; T)]
    const fn unwrap(self) -&gt; T;

    #[sig(fn(&amp;Self[@b]) -&gt; Option&lt;&amp;T&gt;[b])]
    fn as_ref(&amp;self) -&gt; Option&lt;&amp;T&gt;;

    #[sig(fn(&amp;mut Self[@b]) -&gt; Option&lt;&amp;mut T&gt;[b])]
    fn as_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt;;

    #[sig(fn(&amp;Self[@b]) -&gt; &amp;[T][if b { 1 } else { 0 }])]
    fn as_slice(&amp;self) -&gt; &amp;[T];

    #[sig(fn(&amp;mut Self[@b]) -&gt; &amp;mut [T][if b { 1 } else { 0 }])]
    fn as_mut_slice(&amp;mut self) -&gt; &amp;mut [T];
}</code></pre>
<pre><code class="language-rust noplayground">use flux_rs::{assert, attrs::*};

extern crate flux_core;

#[flux::trusted]
#[spec(fn(i32{v: false}) -&gt; T)]
pub fn never&lt;T&gt;(_: i32) -&gt; T {
    loop {}
}

#[spec(fn(x:Option&lt;T&gt;[true]) -&gt; T)]
pub fn my_unwrap&lt;T&gt;(x: Option&lt;T&gt;) -&gt; T {
    match x {
        Option::Some(v) =&gt; v,
        Option::None =&gt; never(0),
    }
}

#[spec(fn(T) -&gt; Option&lt;T&gt;[true])]
fn my_some&lt;T&gt;(x: T) -&gt; Option&lt;T&gt; {
    Option::Some(x)
}

pub fn test1() {
    let x = my_some(42);
    let y = my_unwrap(x);
    assert(y == 42);
}

pub fn test3() {
    let x = Option::Some(42);
    let y = my_unwrap(x);
    assert(y == 42);
}

pub fn test_opt_specs() {
    let a = Some(42);
    assert(a.is_some());
    let b: Option&lt;i32&gt; = None;
    assert(b.is_none());
    let c = a.unwrap();
    assert(c == 42);
}

#[spec(fn (numerator: u32, denominator: u32) -&gt; Option&lt;u32[numerator / denominator]&gt;[denominator != 0])]
pub fn safe_div(numerator: u32, denominator: u32) -&gt; Option&lt;u32&gt; {
    if denominator == 0 { None } else { Some(numerator / denominator) }
}

pub fn test_safe_div() {
    let res = safe_div(42, 2).unwrap();
    assert(res == 21);
}</code></pre>
<h3 id="vec"><a class="header" href="#vec">Vec</a></h3>
<pre><code class="language-rust noplayground">use std::{
    alloc::{Allocator, Global},
    ops::{Index, IndexMut},
    slice::SliceIndex,
};

use flux_attrs::*;

//---------------------------------------------------------------------------------------
#[extern_spec]
#[refined_by(len: int)]
#[invariant(0 &lt;= len)]
struct Vec&lt;T, A: Allocator = Global&gt;;

//---------------------------------------------------------------------------------------

#[extern_spec]
impl&lt;T&gt; Vec&lt;T&gt; {
    #[flux::sig(fn() -&gt; Vec&lt;T&gt;[0])]
    fn new() -&gt; Vec&lt;T&gt;;
}

#[extern_spec]
impl&lt;T, A: Allocator&gt; Vec&lt;T, A&gt; {
    #[spec(fn(self: &amp;mut Vec&lt;T, A&gt;[@n], T) ensures self: Vec&lt;T, A&gt;[n+1])]
    fn push(v: &amp;mut Vec&lt;T, A&gt;, value: T);

    #[spec(fn(&amp;Vec&lt;T, A&gt;[@n]) -&gt; usize[n])]
    fn len(v: &amp;Vec&lt;T, A&gt;) -&gt; usize;

    #[spec(fn(self: &amp;mut Vec&lt;T, A&gt;[@n]) -&gt; Option&lt;T&gt; ensures self: Vec&lt;T, A&gt;[if n &gt; 0 { n-1 } else { 0 }])]
    fn pop(&amp;mut self) -&gt; Option&lt;T&gt;;
}

//---------------------------------------------------------------------------------------

#[extern_spec]
impl&lt;T, I: SliceIndex&lt;[T]&gt;, A: Allocator&gt; Index&lt;I&gt; for Vec&lt;T, A&gt; {
    #[spec(fn(&amp;Vec&lt;T, A&gt;[@len], {I[@idx] | &lt;I as SliceIndex&lt;[T]&gt;&gt;::in_bounds(idx, len)}) -&gt; _)]
    fn index(z: &amp;Vec&lt;T, A&gt;, index: I) -&gt; &amp;&lt;I as SliceIndex&lt;[T]&gt;&gt;::Output;
}

#[extern_spec]
impl&lt;T, I: SliceIndex&lt;[T]&gt;, A: Allocator&gt; IndexMut&lt;I&gt; for Vec&lt;T, A&gt; {
    #[spec(fn(&amp;mut Vec&lt;T,A&gt;[@len], {I[@idx] | &lt;I as SliceIndex&lt;[T]&gt;&gt;::in_bounds(idx, len)}) -&gt; _)]
    fn index_mut(z: &amp;mut Vec&lt;T, A&gt;, index: I) -&gt; &amp;mut &lt;I as SliceIndex&lt;[T]&gt;&gt;::Output;
}

//---------------------------------------------------------------------------------------

#[extern_spec]
impl&lt;'a, T, A: Allocator&gt; IntoIterator for &amp;'a Vec&lt;T, A&gt; {
    #[spec(fn (&amp;Vec&lt;T, A&gt;[@n]) -&gt; &lt;&amp;Vec&lt;T, A&gt; as IntoIterator&gt;::IntoIter[0,n])]
    fn into_iter(v: &amp;'a Vec&lt;T, A&gt;) -&gt; &lt;&amp;'a Vec&lt;T, A&gt; as IntoIterator&gt;::IntoIter;
}

#[extern_spec]
#[assoc(fn with_size(self: Self, n:int) -&gt; bool { self.len == n })]
impl&lt;T&gt; FromIterator&lt;T&gt; for Vec&lt;T&gt; {}</code></pre>
<h3 id="extern-structs"><a class="header" href="#extern-structs">Extern Structs</a></h3>
<p>Here is an example of refining an extern struct</p>
<pre><code class="language-rust noplayground">use flux_rs::extern_spec;

#[extern_spec(std::string)]
#[flux::refined_by(len: int)]
struct String;

#[flux::sig(fn(String[@n]) requires n == 3)]
fn expect_string_len_3(s: String) {}

#[flux::sig(fn(String[2]))]
fn test_string_len_2(s: String) {
    expect_string_len_3(s); //~ ERROR refinement type
}</code></pre>
<p>Here's a longer example of refining an extern <code>struct</code> as well as an <code>impl</code></p>
<pre><code class="language-rust noplayground">use flux_rs::extern_spec;

#[extern_spec]
#[flux::refined_by(len: int)]
struct String;

#[extern_spec]
impl String {
    #[flux::sig(fn() -&gt; String[0])]
    fn new() -&gt; String;

    #[flux::sig(fn(&amp;String[@n]) -&gt; usize[n])]
    fn len(s: &amp;String) -&gt; usize;

    #[flux::sig(fn(&amp;String[@n]) -&gt; bool[n == 0])]
    fn is_empty(s: &amp;String) -&gt; bool;

    #[flux::sig(fn(s: &amp;mut String[@n], char) ensures s: String[n+1])]
    fn push(s: &amp;mut String, c: char);

    #[flux::sig(fn(s: &amp;mut String[@n]) -&gt; Option&lt;char&gt;
                requires n &gt; 0
                ensures s: String[n-1])]
    fn pop(s: &amp;mut String) -&gt; Option&lt;char&gt;;

    #[flux::sig(fn(&amp;String[@n]) -&gt; &amp;[u8][n])]
    fn as_bytes(s: &amp;String) -&gt; &amp;[u8];
}

#[extern_spec]
impl&lt;T&gt; [T] {
    #[flux::sig(fn(&amp;[T][@n]) -&gt; usize[n])]
    fn len(v: &amp;[T]) -&gt; usize;

    #[flux::sig(fn(&amp;[T][@n]) -&gt; bool[n == 0])]
    fn is_empty(v: &amp;[T]) -&gt; bool;
}

#[flux::sig(fn(bool[@b]) requires b)]
pub fn assert_true(_: bool) {}

pub fn test_string() {
    let mut s = String::new();
    assert_true(s.is_empty());
    assert_true(s.as_bytes().is_empty());
    s.push('h');
    s.push('i');
    assert_true(s.len() == 2);
    s.pop();
    assert_true(s.len() == 1);
    s.pop();
    assert_true(s.is_empty());
    assert_true(s.as_bytes().is_empty());
}</code></pre>
<p>The syntax for an extern spec on a struct is very similar to that for a
function. Once again, each line in the example happens to correspond to a step.</p>
<pre><code>#[extern_spec(std::string)]
#[flux_rs::refined_by(len: int)]
struct String;
</code></pre>
<ol>
<li>Add the <code>#[extern_spec]</code> attribute. This attribute optionally takes a path;
in the above example, this is <code>std::string</code>. You can use this path to qualify
the function. So in the above example, the struct we are targeting has the
full path of <code>std::string::String</code>.</li>
<li>Add a <code>#[flux_rs::refined_by(...)]</code> attribute. This is required for any extern
spec on a struct. Right now these attributes behave as if they were opaque
(<code>#[flux_rs::opaque]</code>), although we may support non-opaque extern structs.</li>
<li>Write a stub for the extern struct.</li>
</ol>
<p>If you do the above, you can use <code>std::string::String</code> as if it were refined by
an integer index.</p>
<p>The syntax for an extern impl is a little different than that for functions or
structs.</p>
<pre><code>#[extern_spec(std::string)]
impl String {
    #[flux_rs::sig(fn() -&gt; String[0])]
    fn new() -&gt; String;

    #[flux_rs::sig(fn(&amp;String[@n]) -&gt; usize[n])]
    fn len(s: &amp;String) -&gt; usize;
}
</code></pre>
<ol>
<li>You still need to add the <code>#[extern_spec]</code> attribute, with the same optional
argument of the path as above.</li>
<li>You need to write out the <code>impl</code> block for the struct you want to refine.
This struct does not need an extern spec, since by refining the <code>impl</code> you're
only refining its methods.</li>
<li>Write an extern spec for each function you wish to refine (this may be a
subset). This is written just like a function extern spec with the caveat
that the <code>self</code> parameter is not presently supported. So for example, instead
of writing <code>fn len(&amp;self) -&gt; usize;</code>, you need to write <code>fn len(s: &amp;String) -&gt; usize;</code>.</li>
</ol>
<p>If you do the above, you can use the above methods of<code>std::string::String</code> as if
they were refined.</p>
<pre><code class="language-rust noplayground">// Testing we can add external specs to "transparent" structs.

use flux_rs::extern_spec;

#[extern_spec(std::ops)]
#[refined_by(start: Idx, end: Idx)]
struct Range&lt;Idx&gt; {
    #[field(Idx[start])]
    start: Idx,
    #[field(Idx[end])]
    end: Idx,
}

#[extern_spec(std::ops)]
impl&lt;Idx: PartialOrd&lt;Idx&gt;&gt; Range&lt;Idx&gt; {
    // This specification is actually unsound for `Idx`s where the `PartialOrd` implementation doesn't
    // match the logical `&lt;`.
    #[sig(fn(&amp;Range&lt;Idx&gt;[@r]) -&gt; bool[!(r.start &lt; r.end)])]
    fn is_empty(&amp;self) -&gt; bool;
}

#[flux::sig(fn(bool[true]))]
fn assert(_: bool) {}

fn test00() {
    let r = 0..1;
    assert(!r.is_empty());
}</code></pre>
<pre><code class="language-rust noplayground">// Extern spec of a type with a lifetime

use std::slice::Iter;

use flux_rs::*;

#[extern_spec]
#[refined_by(len: int)]
struct Iter&lt;'a, T&gt;;

#[extern_spec]
impl&lt;'a, T&gt; Iter&lt;'a, T&gt; {
    #[spec(fn as_slice(&amp;Iter&lt;T&gt;[@n]) -&gt; &amp;[T][n])]
    fn as_slice(v: &amp;Iter&lt;'a, T&gt;) -&gt; &amp;'a [T];
}

#[extern_spec]
impl&lt;T&gt; [T] {
    #[spec(fn iter(&amp;[T][@n]) -&gt; Iter&lt;T&gt;[n])]
    fn iter(v: &amp;[T]) -&gt; Iter&lt;'_, T&gt;;
}

#[spec(fn test00(x: &amp;[i32][@n]) -&gt; &amp;[i32][n])]
fn test00(x: &amp;[i32]) -&gt; &amp;[i32] {
    x.iter().as_slice()
}</code></pre>
<h3 id="extern-impls"><a class="header" href="#extern-impls">Extern Impls</a></h3>
<pre><code class="language-rust noplayground">use flux_rs::extern_spec;

#[extern_spec]
#[flux::refined_by(len: int)]
struct String;

#[extern_spec]
impl String {
    #[flux::sig(fn() -&gt; String[0])]
    fn new() -&gt; String;

    #[flux::sig(fn(&amp;String[@n]) -&gt; usize[n])]
    fn len(s: &amp;String) -&gt; usize;

    #[flux::sig(fn(&amp;String[@n]) -&gt; bool[n == 0])]
    fn is_empty(s: &amp;String) -&gt; bool;

    #[flux::sig(fn(s: &amp;mut String[@n], char) ensures s: String[n+1])]
    fn push(s: &amp;mut String, c: char);

    #[flux::sig(fn(s: &amp;mut String[@n]) -&gt; Option&lt;char&gt;
                requires n &gt; 0
                ensures s: String[n-1])]
    fn pop(s: &amp;mut String) -&gt; Option&lt;char&gt;;

    #[flux::sig(fn(&amp;String[@n]) -&gt; &amp;[u8][n])]
    fn as_bytes(s: &amp;String) -&gt; &amp;[u8];
}

#[extern_spec]
impl&lt;T&gt; [T] {
    #[flux::sig(fn(&amp;[T][@n]) -&gt; usize[n])]
    fn len(v: &amp;[T]) -&gt; usize;

    #[flux::sig(fn(&amp;[T][@n]) -&gt; bool[n == 0])]
    fn is_empty(v: &amp;[T]) -&gt; bool;
}

#[flux::sig(fn(bool[@b]) requires b)]
pub fn assert_true(_: bool) {}

pub fn test_string() {
    let mut s = String::new();
    assert_true(s.is_empty());
    assert_true(s.as_bytes().is_empty());
    s.push('h');
    s.push('i');
    assert_true(s.len() == 2);
    s.pop();
    assert_true(s.len() == 1);
    s.pop();
    assert_true(s.is_empty());
    assert_true(s.as_bytes().is_empty());
}</code></pre>
<pre><code class="language-rust noplayground">//@aux-build:extern_spec_impl01_aux.rs

extern crate extern_spec_impl01_aux;

use extern_spec_impl01_aux::MyTrait;
use flux_rs::extern_spec;

#[extern_spec]
impl&lt;T&gt; MyTrait for Vec&lt;T&gt; {
    #[flux::sig(fn() -&gt; i32[10])]
    fn foo() -&gt; i32;
}

#[flux::sig(fn () -&gt; i32[10])]
pub fn test_ok() -&gt; i32 {
    &lt;Vec&lt;i32&gt; as MyTrait&gt;::foo()
}</code></pre>
<h3 id="extern-traits"><a class="header" href="#extern-traits">Extern Traits</a></h3>
<pre><code class="language-rust noplayground">use flux_rs::*;

#[extern_spec(std::cmp)]
#[assoc(fn eq_rel(lhs: Self, rhs: Rhs) -&gt; bool)]
trait PartialEq&lt;Rhs&gt; {
    #[sig(fn(&amp;Self[@lhs], &amp;Rhs[@rhs]) -&gt; bool[&lt;Self as PartialEq&lt;Rhs&gt;&gt;::eq_rel(lhs, rhs)])]
    fn eq(&amp;self, other: &amp;Rhs) -&gt; bool;
}

#[refined_by(n: int)]
struct MyInt(#[field(i32[n])] i32);

#[assoc(fn eq_rel(lhs: MyInt, rhs: MyInt) -&gt; bool { lhs == rhs })]
impl PartialEq for MyInt {
    #[sig(fn(&amp;Self[@lhs], &amp;MyInt[@rhs]) -&gt; bool[&lt;MyInt as PartialEq&lt;MyInt&gt;&gt;::eq_rel(lhs, rhs)])]
    fn eq(&amp;self, other: &amp;MyInt) -&gt; bool {
        self.0 == other.0
    }
}

#[sig(fn(x: T, y: T) -&gt; bool[&lt;T as PartialEq&lt;T&gt;&gt;::eq_rel(x, y)])]
fn test00&lt;T: PartialEq&gt;(x: T, y: T) -&gt; bool {
    x == y
}

#[sig(fn(x: MyInt, y: MyInt) -&gt; bool[x == y])]
fn test01(x: MyInt, y: MyInt) -&gt; bool {
    test00(x, y)
}</code></pre>
<h3 id="for-loops-with-range-ij"><a class="header" href="#for-loops-with-range-ij"><code>for</code> loops with range <code>i..j</code></a></h3>
<p>To see how <code>flux</code> handles <code>for i in 0..n</code> style loops:</p>
<pre><code class="language-rust noplayground">#![feature(step_trait)]
#![allow(unused)]

extern crate flux_core;

#[flux_rs::sig(fn (bool[true]))]
fn assert(b: bool) {}

fn donald() {
    let n: i32 = 10;
    let mut thing = 0..n;
    let a = thing.next().unwrap();
    assert(a == 0);
    let b = thing.next().unwrap();
    assert(b == 1);
    let c = thing.next().unwrap();
    assert(c == 2);
}

#[flux_rs::sig(fn (n:i32{n == 99}))]
fn goofy(n: i32) {
    let mut thing = 0..n;
    let a0 = thing.end;
    assert(a0 == n);
    while let Some(i) = thing.next() {
        assert(0 &lt;= i);
        assert(i &lt; n);
    }
}

#[flux_rs::sig(fn (n:i32{n == 99}))]
fn mickey(n: i32) {
    for i in 0..n {
        assert(0 &lt;= i);
        assert(i &lt; n);
    }
}

#[flux_rs::trusted]
fn cond() -&gt; bool {
    todo!()
}

fn test(len: i32) {
    if len &gt;= 0 {
        let mut del = 0;
        for i in 0..len {
            assert(del &lt;= i);
            if cond() {
                del += 1;
            }
        }
        assert(del &lt;= len)
    }
}</code></pre>
<h2 id="associated-refinements-1"><a class="header" href="#associated-refinements-1">Associated Refinements</a></h2>
<h3 id="basic"><a class="header" href="#basic">Basic</a></h3>
<pre><code class="language-rust noplayground">#![allow(dead_code)]

use flux_rs::attrs::*;

trait MyTrait {
    #![reft(fn f(x: int) -&gt; int)]
    //
}

struct Add1;

impl MyTrait for Add1 {
    #![reft(fn f(x: int) -&gt; int { x + 1 })]
    //
}

#[sig(fn(x: i32{v: v == &lt;Add1 as MyTrait&gt;::f(0) }))]
fn test00(_x: i32) {}

fn test01() {
    test00(1);
}</code></pre>
<h3 id="check-subtyping-at-impl"><a class="header" href="#check-subtyping-at-impl">Check Subtyping at Impl</a></h3>
<pre><code class="language-rust noplayground">// test that implementations with extra const generics work as expected

use flux_rs::attrs::*;

#[reft(fn p(x: int) -&gt; bool)]
trait MyTrait {
    #[sig(fn() -&gt; i32{ v: &lt;Self as MyTrait&gt;::p(v) })]
    fn method() -&gt; i32;
}

struct MyStruct&lt;const N: i32&gt;;

// This implementation requires proving `x == N =&gt; x &gt;= N`
#[reft(fn p(x: int) -&gt; bool { x &gt;= N })]
impl&lt;const N: i32&gt; MyTrait for MyStruct&lt;N&gt; {
    #[sig(fn() -&gt; i32{v: v == N})]
    fn method() -&gt; i32 {
        N
    }
}</code></pre>
<h3 id="default"><a class="header" href="#default">Default</a></h3>
<pre><code class="language-rust noplayground">use flux_rs::attrs::*;

pub trait MyTrait {
    #![reft(fn f(x: int) -&gt; int { x + 1 })]
    //
}

// -----------------------------------------------------------------------------

pub struct Add1;

// Use the "default" assoc reft for Add1
impl MyTrait for Add1 {}

#[flux::sig(fn() -&gt; i32{v: v == &lt;Add1 as MyTrait&gt;::f(0)})]
pub fn test1_ok() -&gt; i32 {
    1
}

#[flux::sig(fn() -&gt; i32{v: v == &lt;Add1 as MyTrait&gt;::f(0)})]
pub fn test1_fail() -&gt; i32 {
    99 //~ ERROR: refinement type error
}

// -----------------------------------------------------------------------------

pub struct Add2;

// Specify a custom assoc reft for Add2
impl MyTrait for Add2 {
    #![reft(fn f(x: int) -&gt; int { x + 2 })]
    //
}

#[flux::sig(fn() -&gt; i32{v: v == &lt;Add2 as MyTrait&gt;::f(0)})]
pub fn test2() -&gt; i32 {
    2
}</code></pre>
<h3 id="use-in-extern-spec"><a class="header" href="#use-in-extern-spec">Use in Extern Spec</a></h3>
<pre><code class="language-rust noplayground">use flux_rs::*;

#[extern_spec(std::cmp)]
#[assoc(fn eq_rel(lhs: Self, rhs: Rhs) -&gt; bool)]
trait PartialEq&lt;Rhs&gt; {
    #[sig(fn(&amp;Self[@lhs], &amp;Rhs[@rhs]) -&gt; bool[&lt;Self as PartialEq&lt;Rhs&gt;&gt;::eq_rel(lhs, rhs)])]
    fn eq(&amp;self, other: &amp;Rhs) -&gt; bool;
}

#[refined_by(n: int)]
struct MyInt(#[field(i32[n])] i32);

#[assoc(fn eq_rel(lhs: MyInt, rhs: MyInt) -&gt; bool { lhs == rhs })]
impl PartialEq for MyInt {
    #[sig(fn(&amp;Self[@lhs], &amp;MyInt[@rhs]) -&gt; bool[&lt;MyInt as PartialEq&lt;MyInt&gt;&gt;::eq_rel(lhs, rhs)])]
    fn eq(&amp;self, other: &amp;MyInt) -&gt; bool {
        self.0 == other.0
    }
}

#[sig(fn(x: T, y: T) -&gt; bool[&lt;T as PartialEq&lt;T&gt;&gt;::eq_rel(x, y)])]
fn test00&lt;T: PartialEq&gt;(x: T, y: T) -&gt; bool {
    x == y
}

#[sig(fn(x: MyInt, y: MyInt) -&gt; bool[x == y])]
fn test01(x: MyInt, y: MyInt) -&gt; bool {
    test00(x, y)
}</code></pre>
<pre><code class="language-rust noplayground">use std::{
    alloc::{Allocator, Global},
    ops::{Index, IndexMut},
    slice::SliceIndex,
};

use flux_attrs::*;

//---------------------------------------------------------------------------------------
#[extern_spec]
#[refined_by(len: int)]
#[invariant(0 &lt;= len)]
struct Vec&lt;T, A: Allocator = Global&gt;;

//---------------------------------------------------------------------------------------

#[extern_spec]
impl&lt;T&gt; Vec&lt;T&gt; {
    #[flux::sig(fn() -&gt; Vec&lt;T&gt;[0])]
    fn new() -&gt; Vec&lt;T&gt;;
}

#[extern_spec]
impl&lt;T, A: Allocator&gt; Vec&lt;T, A&gt; {
    #[spec(fn(self: &amp;mut Vec&lt;T, A&gt;[@n], T) ensures self: Vec&lt;T, A&gt;[n+1])]
    fn push(v: &amp;mut Vec&lt;T, A&gt;, value: T);

    #[spec(fn(&amp;Vec&lt;T, A&gt;[@n]) -&gt; usize[n])]
    fn len(v: &amp;Vec&lt;T, A&gt;) -&gt; usize;

    #[spec(fn(self: &amp;mut Vec&lt;T, A&gt;[@n]) -&gt; Option&lt;T&gt; ensures self: Vec&lt;T, A&gt;[if n &gt; 0 { n-1 } else { 0 }])]
    fn pop(&amp;mut self) -&gt; Option&lt;T&gt;;
}

//---------------------------------------------------------------------------------------

#[extern_spec]
impl&lt;T, I: SliceIndex&lt;[T]&gt;, A: Allocator&gt; Index&lt;I&gt; for Vec&lt;T, A&gt; {
    #[spec(fn(&amp;Vec&lt;T, A&gt;[@len], {I[@idx] | &lt;I as SliceIndex&lt;[T]&gt;&gt;::in_bounds(idx, len)}) -&gt; _)]
    fn index(z: &amp;Vec&lt;T, A&gt;, index: I) -&gt; &amp;&lt;I as SliceIndex&lt;[T]&gt;&gt;::Output;
}

#[extern_spec]
impl&lt;T, I: SliceIndex&lt;[T]&gt;, A: Allocator&gt; IndexMut&lt;I&gt; for Vec&lt;T, A&gt; {
    #[spec(fn(&amp;mut Vec&lt;T,A&gt;[@len], {I[@idx] | &lt;I as SliceIndex&lt;[T]&gt;&gt;::in_bounds(idx, len)}) -&gt; _)]
    fn index_mut(z: &amp;mut Vec&lt;T, A&gt;, index: I) -&gt; &amp;mut &lt;I as SliceIndex&lt;[T]&gt;&gt;::Output;
}

//---------------------------------------------------------------------------------------

#[extern_spec]
impl&lt;'a, T, A: Allocator&gt; IntoIterator for &amp;'a Vec&lt;T, A&gt; {
    #[spec(fn (&amp;Vec&lt;T, A&gt;[@n]) -&gt; &lt;&amp;Vec&lt;T, A&gt; as IntoIterator&gt;::IntoIter[0,n])]
    fn into_iter(v: &amp;'a Vec&lt;T, A&gt;) -&gt; &lt;&amp;'a Vec&lt;T, A&gt; as IntoIterator&gt;::IntoIter;
}

#[extern_spec]
#[assoc(fn with_size(self: Self, n:int) -&gt; bool { self.len == n })]
impl&lt;T&gt; FromIterator&lt;T&gt; for Vec&lt;T&gt; {}</code></pre>
<pre><code class="language-rust noplayground">mod adapters;
#[cfg(flux)]
mod range;
mod traits;</code></pre>
<pre><code class="language-rust noplayground">#![allow(unused)]
#![feature(allocator_api)]

use std::{iter::Enumerate, slice::Iter};

extern crate flux_alloc;
extern crate flux_core;

#[flux::sig(fn(bool[true]))]
pub fn assert(_b: bool) {}

// Tests
#[flux::sig(fn(slice: &amp;[u8]{n: n &gt; 0}))]
fn test_iter1(slice: &amp;[u8]) {
    let mut iter = slice.iter();
    let next = iter.next();
    assert(next.is_some());
}

#[flux::sig(fn(slice: &amp;[u8]{n: n &gt; 1}))]
fn test_enumerate1(slice: &amp;[u8]) {
    assert(slice.len() &gt; 0);
    let mut enumer = slice.iter().enumerate();

    let next = enumer.next();
    assert(next.is_some());
    let (idx, _) = next.unwrap();
    assert(idx == 0);

    let next_next = enumer.next();
    assert(next_next.is_some());
    let (idx, _) = next_next.unwrap();
    assert(idx == 1);
}

#[flux::sig(fn(&amp;[usize][1]) )]
pub fn test_enumer2(slice: &amp;[usize]) {
    assert(slice.len() == 1);
    let mut enumer = slice.iter().enumerate();

    let next = enumer.next();
    assert(next.is_some());

    let next_next = enumer.next();
    assert(next_next.is_none())
}

#[flux::sig(fn(&amp;[usize][@n]) )]
pub fn test_enumer3(slice: &amp;[usize]) {
    let mut e = slice.iter().enumerate();
    while let Some((idx, _)) = e.next() {
        assert(idx &lt; slice.len())
    }
}

#[flux::sig(fn(&amp;[usize][@n]) )]
pub fn test_enumer4(slice: &amp;[usize]) {
    for (idx, _) in slice.iter().enumerate() {
        assert(idx &lt; slice.len())
    }
}</code></pre>
<h3 id="associated-types"><a class="header" href="#associated-types">Associated Types</a></h3>
<pre><code class="language-rust noplayground">use flux_rs::attrs::*;

trait MyTrait {
    #![reft(fn f(x: int) -&gt; int)]
    //
}

struct Add1;

#[assoc(fn f(x: int) -&gt; int { x + 1 })]
impl MyTrait for Add1 {}

#[sig(fn(x: i32{v: v == &lt;Add1 as MyTrait&gt;::f(0) }))]
fn test00(x: i32) {}

fn test01() {
    test00(0); //~ ERROR refinement type error
}</code></pre>
<pre><code class="language-rust noplayground">// Testing that we properly map generics in trait's default associated refinement
// body into the impl.

use flux_rs::attrs::*;

trait MyTrait {
    #![reft(fn p(x: Self) -&gt; bool { true })]

    #[sig(fn(&amp;Self{v: &lt;Self as MyTrait&gt;::p(v)}))]
    fn method(&amp;self);
}

impl MyTrait for i32 {
    #[sig(fn(&amp;Self{v: &lt;Self as MyTrait&gt;::p(v)}))]
    fn method(&amp;self) {}
}

impl&lt;T&gt; MyTrait for S&lt;T&gt; {
    #[sig(fn(&amp;Self{v: &lt;Self as MyTrait&gt;::p(v)}))]
    fn method(&amp;self) {}
}

struct S&lt;T&gt; {
    f: T,
}</code></pre>
<h3 id="refined-associated-types-1"><a class="header" href="#refined-associated-types-1">Refined Associated Types</a></h3>
<pre><code class="language-rust noplayground">use flux_rs::*;

#[assoc(fn can_fit(self: Self, animal: Self::Animal) -&gt; bool)]
trait Barn {
    type Animal;

    #[sig(fn(self: &amp;mut Self[@barn], animal: Self::Animal{ &lt;Self as Barn&gt;::can_fit(barn, animal) }))]
    fn put_animal_in_house(&amp;mut self, animal: Self::Animal);
}

#[refined_by(size: int)]
struct Horse {
    #[field(i32[size])]
    size: i32,
}

#[refined_by(max_size: int)]
struct HorseBarn {
    #[field(i32[max_size])]
    max_size: i32,
}

#[assoc(fn can_fit(self: HorseBarn, horse: Horse) -&gt; bool { horse.size &lt;= self.max_size })]
impl Barn for HorseBarn {
    type Animal = Horse;

    #[trusted]
    #[sig(fn(self: &amp;mut Self[@barn], horse: Horse { horse.size &lt;= barn.max_size}))]
    fn put_animal_in_house(&amp;mut self, horse: Horse) {}
}

fn test00() {
    let mut barn = HorseBarn { max_size: 20 };
    let horse = Horse { size: 10 };

    barn.put_animal_in_house(horse);
}</code></pre>
<h2 id="checking-overflows"><a class="header" href="#checking-overflows">Checking Overflows</a></h2>
<p>You can switch on overflow checking</p>
<ul>
<li><em>globally</em> <a href="http://localhost:3000/guide/run.html?highlight=cache#flux-flags">with a flag</a> or</li>
<li><em>locally</em> with an attribute as shown below</li>
</ul>
<pre><code class="language-rust noplayground">const MAX: u32 = std::u32::MAX;

// Error on this as it may overflow
#[flux::opts(check_overflow = "strict")]
#[flux::sig(fn (u32[@x], u32[@y], u32[@z]) -&gt; u32[x + y + z] requires x + y + z &lt;= MAX)]
fn add_three(x: u32, y: u32, z: u32) -&gt; u32 {
    x + y + z
}</code></pre>
<pre><code class="language-rust noplayground">#[flux::opts(check_overflow = "strict")]
mod my_mod {
    const MAX: u32 = std::u32::MAX;

    #[flux::sig(fn(u32[@x], u32[@y]) -&gt; u32[x + y] requires x + y &lt;= MAX)]
    fn add(x: u32, y: u32) -&gt; u32 {
        x + y
    }

    #[flux::sig(fn(u32[@x]) -&gt; u32[x + 2] requires x + 2 &lt;= MAX)]
    fn add2(x: u32) -&gt; u32 {
        x + 2
    }
}</code></pre>
<pre><code class="language-rust noplayground">const MAX: u32 = std::u32::MAX;

#[flux_rs::refined_by(inner: int)]
struct MyStruct {
    #[field(u32[inner])]
    inner: u32,
}

impl MyStruct {
    fn add1(&amp;self) -&gt; u32 {
        self.inner + 1
    }

    // Error as this may overflow
    #[flux::opts(check_overflow = "strict")]
    #[flux::sig(fn (&amp;MyStruct[@inner]) -&gt; u32[inner + 2] requires inner + 2 &lt;= MAX)]
    fn add2(&amp;self) -&gt; u32 {
        self.inner + 2
    }
}</code></pre>
<pre><code class="language-rust noplayground">const MAX: u32 = std::u32::MAX;

struct MyStruct {
    inner: u32,
}

#[flux::opts(check_overflow = "strict")]
trait MyTrait {
    #[flux::sig(fn(u32[@x], { u32[@y] | x + y &lt;= MAX }) -&gt; u32[x + y] )]
    fn add(x: u32, y: u32) -&gt; u32;
}

impl MyTrait for MyStruct {
    #[flux::sig(fn(u32[@x], { u32[@y] | x + y &lt;= MAX }) -&gt; u32[x + y] )]
    fn add(x: u32, y: u32) -&gt; u32 {
        x + y
    }
}</code></pre>
<h2 id="extensible-properties-for-primitive-ops"><a class="header" href="#extensible-properties-for-primitive-ops">Extensible Properties for Primitive Ops</a></h2>
<p>You can provide <em>properties</em> to be used when doing computations with
primitive operations like <code>&lt;&lt;</code> or <code>&gt;&gt;</code>.</p>
<p>Given a primop <code>op</code> with signature <code>(t1,...,tn) -&gt; t</code> we define
a refined type for <code>op</code> expressed as a [<code>RuleMatcher</code>]</p>
<pre><code class="language-rust noplayground">op :: (x1: t1, ..., xn: tn) -&gt; { t[op_val[op](x1,...,xn)] | op_rel[x1,...,xn] }</code></pre>
<p>that is, using two <em>uninterpreted functions</em> <code>op_val</code> and <code>op_rel</code> that respectively denote</p>
<ol>
<li>The <em>value</em> of the primop, and</li>
<li>Some invariant <em>relation</em> that holds for the primop.</li>
</ol>
<p>The latter can be extended by the user via a <code>property</code> definition,
which allows us to customize primops like <code>&lt;&lt;</code> with extra "facts"
or lemmas. See <code>tests/tests/pos/surface/primops00.rs</code> for an example.</p>
<pre><code class="language-rust noplayground">use flux_rs::{assert, attrs::*, defs};

defs! {
    property ShiftByTwo[&lt;&lt;](x, y) {
        [&lt;&lt;](x, 2) == 4*x
    }

    property ShiftRightByFour[&gt;&gt;](x, y) {
        16 * [&gt;&gt;](x, 4) == x
    }

    property MaskBy[&amp;](x, y) {
        [&amp;](x, y) &lt;= y
    }

    property XorSelfInverse[^](x, y) {
        x == y =&gt; [^](x, y) == 0
    }
}

pub fn test0() {
    let x: usize = 1 &lt;&lt; 2;
    assert(x == 4);
}

pub fn test1() {
    let x = 1;
    let x = x &lt;&lt; 2;
    let x = x &lt;&lt; 2;
    assert(x == 16)
}

#[spec(fn (x: u32) -&gt; u32[16*x])]
pub fn test2(x: u32) -&gt; u32 {
    let x = x &lt;&lt; 2;
    let x = x &lt;&lt; 2;
    x
}

#[spec(fn (byte: u8{byte &lt;= 127}))]
pub fn test3(byte: u8) {
    let tmp1 = byte &gt;&gt; 4;
    let tmp2 = byte &amp; 0xf;
    assert(byte &lt;= 127);
    assert(tmp1 &lt;= 0xf);
    assert(tmp2 &lt;= 0xf);
}

static POW10: [i32; 10] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];

pub fn test4(n: usize) -&gt; i32 {
    POW10[n &amp; 7]
}

#[spec(fn(x: usize) -&gt; usize[0])]
pub fn test5(x: usize) -&gt; usize {
    x ^ x
}</code></pre>
<h2 id="casting-sorts"><a class="header" href="#casting-sorts">Casting Sorts</a></h2>
<p>You can convert refinements of different sorts -- e.g. <code>int</code> to <code>char</code> or <code>int</code> to <code>bool</code> --
using the <code>cast</code> internal function.</p>
<pre><code class="language-rust noplayground">#![flux::defs {
    fn is_ascii_digit(c: char) -&gt; bool {
        let i = cast(c);
        48 &lt;= i &amp;&amp; i &lt;= 57
    }

    fn is_ascii(c: char) -&gt; bool {
        let i = cast(c);
        0 &lt;= i &amp;&amp; i &lt;= 127
    }
}]

use flux_rs::{assert, attrs::*};

// extern specs for is_ascii and is_ascii_digit
#[extern_spec]
impl char {
    #[spec(fn (&amp;Self[@c]) -&gt; bool[is_ascii(c)])]
    fn is_ascii(&amp;self) -&gt; bool;

    #[spec(fn (&amp;Self[@c]) -&gt; bool[is_ascii_digit(c)])]
    fn is_ascii_digit(&amp;self) -&gt; bool;
}

pub fn test_ok(x: char) {
    if x.is_ascii_digit() {
        assert(x.is_ascii())
    }
}

#[spec(fn (char{v: '0' &lt;= v &amp;&amp; v &lt;= '9'}))]
pub fn test_digit(x: char) {
    assert(x.is_ascii_digit())
}</code></pre>
<h2 id="detached-specifications"><a class="header" href="#detached-specifications">Detached Specifications</a></h2>
<p>Sometimes you may want to write specs for functions etc. but not <em>directly</em> attached to the function
i.e. as an attribute of the function, for example, because you don't want to modify the original source file.</p>
<p>You can do this using the "detached" <code>spec</code> as illustrated by the following</p>
<pre><code class="language-rust noplayground">#![flux::specs {

   fn inc(n:i32) -&gt; i32{v: n &lt; v};

   fn id(n:i32) -&gt; i32[n];

}]

pub fn inc(n: i32) -&gt; i32 {
    n - 1 //~ ERROR refinement type
}

pub fn id(n: i32) -&gt; i32 {
    n
}</code></pre>
<h2 id="include-patterns"><a class="header" href="#include-patterns">Include Patterns</a></h2>
<p>You can include patterns to restrict <code>flux</code> to only check a subset of a codebase.
A <code>def_id</code> is checked if it matches any of the patterns.</p>
<pre><code>cargo x run tests/tests/pos/detached/detach00.rs -- -Fdump-checker-trace -Fdump-constraint -Finclude=span:tests/tests/pos/detached/detach00.rs:13:1 -Finclude=def:id -Finclude=path/to/file.rs
</code></pre>
<hr>
<ol class="footnote-definition"><li id="footnote-ignore-shorthand">
<p><code>#[flux_rs::ignore]</code> (resp. <code>#[flux_rs::trusted]</code>) is shorthand for <code>#[flux_rs::ignore(yes)]</code> (resp. <code>#[flux_rs::trusted(yes)]</code>). <a href="#fr-ignore-shorthand-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="developers-guide"><a class="header" href="#developers-guide">Developer's Guide</a></h1>
<h2 id="backtraces"><a class="header" href="#backtraces">Backtraces</a></h2>
<p>You can use the usual <code>RUST_BACKTRACE=1</code> environment variable to enable backtraces.
With the regular <code>release</code> build (<code>cargo x install</code>) you get some backtraces, but
the <code>dev</code> build, which you can install as shown below, gives more information e.g.
the source-spans of various calls in the backtrace.</p>
<pre><code class="language-sh">$ cargo x install --profile dev
</code></pre>
<h2 id="regression-tests"><a class="header" href="#regression-tests">Regression Tests</a></h2>
<p>You can run the various regression tests in the <code>tests/pos</code> and <code>tests/neg</code> directories using
<code>cargo xtask test</code></p>
<p>This will build the flux binary and then run it against the entire test suite.
You can optionally pass a <em>filter</em> to only run tests containing some substring.
For example:</p>
<pre><code class="language-console">$ cargo xtask test impl_trait
   Compiling xtask v0.1.0 (/path/to/flux/xtask)
    Finished dev [unoptimized + debuginfo] target(s) in 0.29s
     Running `target/debug/xtask test impl_trait`
$ cargo build
    Finished dev [unoptimized + debuginfo] target(s) in 0.05s
$ cargo test -p tests -- --test-args impl_trait
   Compiling fluxtests v0.1.0 (/path/to/flux/tests)
    Finished test [unoptimized + debuginfo] target(s) in 0.62s
     Running tests/compiletest.rs (target/debug/deps/compiletest-1241128f1f51caa4)

running 5 tests
test [ui] pos/surface/impl_trait04.rs ... ok
test [ui] pos/surface/impl_trait03.rs ... ok
test [ui] pos/surface/impl_trait01.rs ... ok
test [ui] pos/surface/impl_trait00.rs ... ok
test [ui] pos/surface/impl_trait02.rs ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 191 filtered out; finished in 0.10s


running 2 tests
test [compile-fail] neg/surface/impl_trait00.rs ... ok
test [compile-fail] neg/surface/impl_trait02.rs ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 207 filtered out; finished in 0.09s
</code></pre>
<h2 id="testing-flux-on-a-file"><a class="header" href="#testing-flux-on-a-file">Testing Flux on a File</a></h2>
<p>When working on Flux, you may want to test your changes by running it against a test file.
You can use <code>cargo xtask run &lt;input&gt;</code> to run Flux on a single input file.
The command will set appropriate flags to be able to use custom Flux attributes and macros,
plus some extra flags useful for debugging.
For example:</p>
<pre><code class="language-console">$ cat test.rs
#[flux::sig(fn(x: i32) -&gt; i32[x + 1])]
fn add1(x: i32) -&gt; i32 {
    x + 1
}
$ cargo xtask run test.rs
</code></pre>
<p>The command will use a super set of the flags passed when running regression tests.
Thus, a common workflow is to identify a failing test and run it directly with <code>cargo xtask run</code>,
or alternatively copy it to a different file.</p>
<p>You may also find useful to create a directory in the root of the project and add it to
<a href="https://git-scm.com/docs/gitignore"><code>.git/info/exclude</code></a>.
You can keep files there, outside of version control, and test Flux against them.
I have a directory called <code>attic/</code> where I keep a file named <code>playground.rs</code>.
To run Flux on it, I do <code>cargo xtask run attic/playground.rs</code>.</p>
<h2 id="reporting-locations-where-errors-are-emitted"><a class="header" href="#reporting-locations-where-errors-are-emitted">Reporting locations where errors are emitted</a></h2>
<p>When you use <code>cargo xtask run</code> you'll see that we report the location an error was emitted, e.g.,</p>
<pre><code class="language-console">error[FLUX]: refinement type error
 --&gt; attic/playground.rs:4:5
  |
4 |     0
  |     ^ a postcondition cannot be proved
-Ztrack-diagnostics: created at crates/flux-refineck/src/lib.rs:114:15   &lt;------- this
</code></pre>
<p>You can also pass <code>-Ztrack-diagnostics=y</code> to enable it if you are not using <code>cargo xtask run</code></p>
<h2 id="macro-expansion"><a class="header" href="#macro-expansion">Macro expansion</a></h2>
<p>For example if you have code like in <code>path/to/file.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[extern_spec]
#[flux::refined_by(elems: Set&lt;T&gt;)]
struct HashSet&lt;T, S = RandomState&gt;;
<span class="boring">}</span></code></pre></pre>
<p>and you want to see what the <code>extern_spec</code> macro expands it out to, then run</p>
<pre><code class="language-shell">cargo x run -- -Zunpretty=expanded path/to/file.rs
</code></pre>
<p>Or you can run the <code>xtask</code> command directly</p>
<pre><code class="language-shell">cargo x expand path/to/file.rs
</code></pre>
<h2 id="reporting-and-dealing-with-bugs"><a class="header" href="#reporting-and-dealing-with-bugs">Reporting and dealing with bugs</a></h2>
<p>As Flux is under active development, there are many aspects of Rust that Flux does not yet support, are
only partially implemented, or where the implementation may contain bugs. These issues typically manifest
as unreachable arms in a match statement (that turn out not to be unreachable) or preemtive assertions to
guard against code we don't yet support. To help identify the code that triggers these bugs, there are a few
recommended methods for reporting them:</p>
<ul>
<li><code>QueryErr::bug</code>: Use this method to report a bug if the code already returns a <code>QueryResult</code>. This
approach is preferred because we will correctly recover from the error.</li>
<li><code>span_bug!</code>: When you have a <code>Span</code> at hand, you can use this macro in place of <code>panic!</code> to report
the span before panicking.</li>
<li><code>tracked_span_bug!</code>: This macro is similar to <code>span_bug!</code>, but it uses a span stored in a thread local
variable (if one exists). To track a span in the thread local variable you can use <code>flux_common::bug::track_span</code>.</li>
<li><code>bug!</code>: For other cases where none of the above applies, you can use the <code>bug!</code> macro. This behaves
mostly like <code>panic!</code> but with nicer formatting.</li>
</ul>
<p>When running Flux in a new code base, consider setting the flag <code>FLUX_CATCH_BUGS=1</code>. If this flag is set,
Flux will try to catch and recover from panics emitted with one of the bug macros (using
<code>std::panic::catch_unwind</code>). Bugs are caught at item boundaries. This may leave Flux or rustc
in an inconsistent state, so there are no guarantees that Flux will behave correctly after recovering
from a panic. However, this may still be useful to gather as many errors as possible. Code can
be selectively ignored later.</p>
<h2 id="dumping-the-checker-trace"><a class="header" href="#dumping-the-checker-trace">Dumping the Checker Trace</a></h2>
<pre><code>cargo x install --debug
FLUX_DUMP_CHECKER_TRACE=1 FLUX_CHECK_DEF=mickey cargo flux
python3  path/to/flux/tools/logreader.py
</code></pre>
<h2 id="debugging-extern-specs"><a class="header" href="#debugging-extern-specs">Debugging Extern Specs</a></h2>
<p>To see the expanded code of an <code>extern_spec</code> macro, you can do</p>
<pre><code>cargo x expand path/to/file.rs
</code></pre>
<h2 id="rebuilding-libraries"><a class="header" href="#rebuilding-libraries">(Re)building Libraries</a></h2>
<p>When making changes to the libraries, including <code>flux-core</code> which has the
<code>extern_spec</code>ifications for the standard library, you can force a rebuild
of the libraries by running:</p>
<pre><code class="language-sh">cargo x build-sysroot
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="high-level-architecture"><a class="header" href="#high-level-architecture">High-level Architecture</a></h1>
<p>Flux is implemented as a compiler <a href="https://rustc-dev-guide.rust-lang.org/rustc-driver.html?highlight=Callbacks%5C#rustc_driver-and-rustc_interface">driver</a>. We hook into the compiler by implementing the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_driver/trait.Callbacks.html"><code>Callbacks</code></a> trait. The implementation is located is in the <code>flux-driver</code> crate, and it is the main entry point to Flux.</p>
<h2 id="crates"><a class="header" href="#crates">Crates</a></h2>
<ul>
<li><code>crates/flux-bin</code>: Contains the <code>cargo-flux</code> and <code>flux</code> binaries used to launch the <code>flux-driver</code>.</li>
<li><code>crates/flux-common</code>: Common utility definitions used across all crates.</li>
<li><code>crates/flux-config</code>: Crate containing logic associated with global configuration flags that change the behavior of Flux, e.g, to enable or disable overflow checking.</li>
<li><code>crates/flux-desugar</code>: Implementation of name resolution and desugaring from Flux surface syntax into Flux high-level intermediate representation (<code>fhir</code>). This includes name resolution.</li>
<li><code>crates/flux-driver</code>: Main entry point to Flux. It contains the <code>flux-driver</code> binary and the implementation of the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_driver/trait.Callbacks.html"><code>Callbacks</code></a> trait.</li>
<li><code>crates/flux-errors</code>: Utility definitions for user facing error reporting.</li>
<li><code>crates/flux-fhir-analysis</code>: Implements the "analyses" performed in the <code>fhir</code>, most notably well-formedness checking and conversion from <code>fhir</code> into <code>rty</code>.</li>
<li><code>crates/flux-fixpoint</code>: Code to interact with the Liquid Fixpoint binary.</li>
<li><code>crates/flux-macros</code>: Procedural macros used internally to implement Flux.</li>
<li><code>crates/flux-metadata</code>: Logic for saving Flux crate metadata that can be used to import refined signatures from external crates.</li>
<li><code>crates/flux-middle</code>: This crate contains common type definitions that are used by the rest of Flux like the <code>rty</code> and <code>fhir</code> intermediate representations. Akin to <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/index.html"><code>rustc_middle</code></a>.</li>
<li><code>crates/flux-refineck</code>: Implementation of refinement type checking.</li>
<li><code>crates/flux-syntax</code>: Definition of the surface syntax AST and parser.</li>
<li><code>tests</code>: Flux regression tests.</li>
<li><code>lib/flux-attrs</code>: Implementation of user facing procedural macros for annotating programs with Flux specs.</li>
<li><code>lib/flux-rs</code>: This is just a re-export of the macros implemented in <code>flux-attrs</code>. The intention is to eventually put Flux "standard library" here, i.e., a set of definitions that are useful when working with Flux.</li>
</ul>
<h2 id="intermediate-representations"><a class="header" href="#intermediate-representations">Intermediate Representations</a></h2>
<p>Flux has several intermediate representations (IR) for types. They represent a refined version of an equivalent type in some <code>rustc</code> IR. We have picked a distinct <em>verb</em> to refer to the process of going between these different representations to make it easier to refer to them. The following image summarizes all the IRs and the process for going between them.</p>
<p><img src="guide/../img/irs.svg" alt="IRs diagram" /></p>
<h3 id="surface"><a class="header" href="#surface">Surface</a></h3>
<p>The surface IR represents source level Flux annotations. It corresponds to the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/index.html"><code>rustc_ast</code></a> data structures in <code>rustc</code>. The definition as well as the parser is located in the <code>flux-syntax</code> crate.</p>
<h3 id="fhir"><a class="header" href="#fhir">Fhir</a></h3>
<p>The Flux High-Level Intermediate Representation (fhir) is a refined version of <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/index.html"><code>rustc</code>'s hir</a>. The definition is located in the <code>flux_middle</code> crate inside the <code>fhir</code> module. The process of going from <code>surface</code> to <code>fhir</code> is called <em>desugaring</em>, and it is implemented in the <code>flux-desugar</code> crate.</p>
<h3 id="rty"><a class="header" href="#rty">Rty</a></h3>
<p>The definition in the <code>flux_middle::rty</code> module correspond to a refined version of the main <code>rustc</code> representation for types defined in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/index.html"><code>rustc_middle::ty</code></a>. The process of going from <code>fhir</code> to <code>rty</code> is called <em>conversion</em>, and it is implemented in the <code>flux_fhir_analysis::conv</code> module.</p>
<h3 id="simplified-rustc"><a class="header" href="#simplified-rustc">Simplified Rustc</a></h3>
<p>The definition in the <code>flux_middle::rustc</code> module correspond to simplified version of data structures in <code>rustc</code>. They can be understood as the currently supported subset of Rust. The process of going from a definition in <code>rustc_middle</code> into <code>flux_middle::rustc</code> is called <em>lowering</em> and it is implemented in <code>flux_middle::rustc::lowering</code>.</p>
<h3 id="lifting-and-refining"><a class="header" href="#lifting-and-refining">Lifting and Refining</a></h3>
<p>Besides the different translation between Flux intermediate representations, there are two ways to get a refined version from a rust type. The process of going from a type in <code>hir</code> into a type in <code>fhir</code> is called <em>lifting</em>, and it is implemented in <code>flux_middle::fhir::lift</code>. The process for going from a type in <code>flux_middle::rustc::ty</code> into a <code>flux_middle::rty</code> is called <em>refining</em>, and it is implemented <code>flux_middle::rty::refining</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="mode-rust.js"></script>
        <script src="editor.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
