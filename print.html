<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Flux Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="flux_theme/flux.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Flux Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <img src="img/logo-wide.svg" class="flux-logo" alt="Flux Logo">
<!-- Types bring order to code.

For example, if a variable `i:usize` then we know `i`
is a number that can be used to index a vector.
Similarly, if `v: Vec<&str>` then we can be sure that
`v` is a collection of strings which may _be_ indexed
but of course, not used _as_ an index.

However, by itself, `usize` doesn't tell us how big
or small the number and hence the programmer must
still rely on their own wits, a lot of tests, and
a dash of optimism, to ensure that all the different
bits snap together correctly at run-time. -->
<p>Flux is a <a href="https://github.com/flux-rs/flux/"><strong>refinement type checker</strong></a> plugin
for Rust that lets you <em>specify</em> a range of correctness properties
and have them be <em>verified</em> at compile time.</p>
<p>Flux works by extending Rust's types with <a href="https://arxiv.org/abs/2010.07763">refinements</a>:
logical assertions describing additional correctness requirements
that are checked during compilation, thereby eliminating various
classes of run-time problems.</p>
<p>You can try it on the <a href="https://flux.goto.ucsd.edu/"><strong>online playground</strong></a>.</p>
<p>Better still, read the <a href="./tutorial/01-refinements.html"><strong>interactive tutorial</strong></a>,
to learn how you can use Flux on your Rust code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing-and-running-flux"><a class="header" href="#installing-and-running-flux">Installing and Running Flux</a></h1>
<p>You can install and then run Flux either on a single file or on an entire crate.</p>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<ul>
<li>
<p><a href="https://rustup.rs/">rustup</a></p>
<p>Rustup is required because Flux needs access to the source code of the Rust compiler, which we grab from rustup.</p>
</li>
<li>
<p><a href="https://github.com/ucsd-progsys/liquid-fixpoint">liquid-fixpoint</a></p>
<p>Nightly binary builds are avilable on <a href="https://github.com/ucsd-progsys/liquid-fixpoint/releases/tag/nightly">GitHub Releases</a>. If there is no binary available
for your platform, you will need to <a href="https://github.com/ucsd-progsys/liquid-fixpoint?tab=readme-ov-file#how-to-build-and-install">build it from source</a>.</p>
</li>
<li>
<p><a href="https://github.com/Z3Prover/z3">z3</a> 4.15 or later</p>
<p>You can download a binary for your platform from <a href="https://github.com/Z3Prover/z3/releases">Z3 GitHub Releases</a>. We recommend downloading the latest version, but older version should also work.</p>
</li>
</ul>
<p><strong>Note:</strong>
Make sure that the <code>liquid-fixpoint</code> and <code>z3</code> binaries are in your <code>$PATH</code>.</p>
<h2 id="install"><a class="header" href="#install">Install</a></h2>
<p>The only way to use Flux is to build it from source.</p>
<p>First you need to clone the repository</p>
<pre><code class="language-bash">git clone https://github.com/flux-rs/flux
cd flux
</code></pre>
<p>To build the source you need a nightly version of <code>rustc</code>.
We pin the version using a <a href="https://github.com/flux-rs/flux/blob/main/rust-toolchain">toolchain file</a> (more info <a href="https://rust-lang.github.io/rustup/overrides.html#the-toolchain-file">here</a>).
If you are using <code>rustup</code>, no special action is needed as it should install the correct <code>rustc</code> version and components based on the information on that file.</p>
<p>Next, run the following to build and install <code>flux</code> binaries</p>
<pre><code class="language-bash">cargo xtask install
</code></pre>
<p>This will install two binaries <code>flux</code> and <code>cargo-flux</code> in your cargo home. These two binaries should be used
respectively to run Flux on either a single file or on a project using cargo. The installation process will
also copy some files to <code>$HOME/.flux</code>.</p>
<p>In order to use Flux refinement attributes in a Cargo project, you will need to add the
following to your Cargo.toml</p>
<pre><code class="language-toml">[dependencies]
flux-rs = { git  = "https://github.com/flux-rs/flux.git" }
</code></pre>
<p>This will add the procedural macros Flux uses to your project; it is not a substitute for installing Flux, which must still be done.</p>
<h2 id="running-on-a-file-flux"><a class="header" href="#running-on-a-file-flux">Running on a File: <code>flux</code></a></h2>
<p>You can use <code>flux</code> as you would use <code>rustc</code>.
For example, the following command checks the file <code>test.rs</code>.</p>
<pre><code class="language-bash">flux path/to/test.rs
</code></pre>
<p>The flux binary accepts the same flags as <code>rustc</code>.
You could for example check a file as a library instead of a binary like so</p>
<pre><code class="language-bash">flux --crate-type=lib path/to/test.rs
</code></pre>
<h3 id="refinement-annotations-on-a-file"><a class="header" href="#refinement-annotations-on-a-file">Refinement Annotations on a File</a></h3>
<p>When running flux on a file with <code>flux path/to/test.rs</code>, refinement annotations should be prefixed with <code>flux::</code>.</p>
<p>For example, the refinement below will only work when running <code>flux</code> which is intended for use on a single file.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::spec(fn(x: i32) -&gt; i32{v: x &lt; v})]
fn inc(x: i32) -&gt; i32 {
    x - 1
}
<span class="boring">}</span></code></pre></pre>
<h2 id="running-on-a-package-cargo-flux"><a class="header" href="#running-on-a-package-cargo-flux">Running on a package: <code>cargo-flux</code></a></h2>
<p>See this an
Flux is integrated with <code>cargo</code> and can be invoked in a package as follows:</p>
<pre><code class="language-bash">cargo flux
</code></pre>
<p>By default, Flux won't verify a package unless it's explicitly enabled in the manifest.
To do so add the following to <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package.metadata.flux]
enabled = true
</code></pre>
<h3 id="refinement-annotations-on-a-cargo-projects"><a class="header" href="#refinement-annotations-on-a-cargo-projects">Refinement Annotations on a Cargo Projects</a></h3>
<p>Adding refinement annotations to cargo projects is simple. You can add <code>flux-rs</code> as a dependency in <code>Cargo.toml</code></p>
<pre><code class="language-toml">[dependencies]
flux-rs = { git  = "https://github.com/flux-rs/flux.git" }
</code></pre>
<p>Then, import attributes from <code>flux_rs</code> and add the appropriate refinement annoations.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use flux_rs::attrs::*;

#[spec(fn(x: i32) -&gt; i32{v: x &lt; v})]
fn inc(x: i32) -&gt; i32 {
    x - 1
}
<span class="boring">}</span></code></pre></pre>
<h2 id="a-tiny-example"><a class="header" href="#a-tiny-example">A tiny example</a></h2>
<p>The following example declares a function <code>inc</code>
that returns an integer greater than the input.
We use the nightly feature <code>register_tool</code>
to register the <code>flux</code> tool in order to
add refinement annotations to functions.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[flux::spec(fn(x: i32) -&gt; i32{v: x &lt; v})]
pub fn inc(x: i32) -&gt; i32 {
    x - 1
}
<span class="boring">}</span></code></pre></pre>
<p>You can save the above snippet in say <code>test0.rs</code> and then run</p>
<pre><code class="language-bash">flux --crate-type=lib path/to/test0.rs
</code></pre>
<p>you should see in your output</p>
<pre><code class="language-text">error[FLUX]: postcondition might not hold
 --&gt; test0.rs:3:5
  |
3 |     x - 1
  |     ^^^^^
</code></pre>
<p>as indeed <code>x - 1</code> is <em>not</em> greater than <code>x</code> as required by the output refinement <code>i32{v: x &lt; v}</code>.</p>
<p>If you fix the error by replacing <code>x - 1</code> with <code>x + 1</code>, you should get no errors
in the output (the output may be empty, but in this case no output is a good
thing).</p>
<p>Read <a href="guide/SUMMARY.html#learn">these chapters</a> to learn more about what you specify and verify with <code>flux</code>.</p>
<h2 id="a-note-about-the-flux-driver-binary"><a class="header" href="#a-note-about-the-flux-driver-binary">A note about the flux-driver binary</a></h2>
<p>The <code>flux-driver</code> binary is a <a href="https://rustc-dev-guide.rust-lang.org/rustc-driver.html?highlight=driver#the-rustc-driver-and-interface">rustc
driver</a>
(similar to how clippy works) meaning it uses rustc as a library to "drive"
compilation performing additional analysis along the way. Running the binary
requires dynamically linking a correct version of <code>librustc</code>. Thus, to avoid the
hassle you should never execute it directly. Instead, use <code>flux</code> or <code>cargo-flux</code>.</p>
<h2 id="editor-support"><a class="header" href="#editor-support">Editor Support</a></h2>
<p>This section assumes you have installed <code>cargo-flux</code>.</p>
<h3 id="rust-analyzer-in-vscode"><a class="header" href="#rust-analyzer-in-vscode">Rust-Analyzer in VSCode</a></h3>
<p>Add this to the workspace settings i.e. <code>.vscode/settings.json</code></p>
<pre><code class="language-json">{
  "rust-analyzer.check.overrideCommand": [
    "cargo",
    "flux",
    "--workspace",
    "--message-format=json-diagnostic-rendered-ansi"
  ]
}
</code></pre>
<p><strong>Note:</strong> Make sure to edit the paths in the above snippet to point to the correct locations on your machine.</p>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<h3 id="flux-flags"><a class="header" href="#flux-flags">Flux Flags</a></h3>
<p>The <code>flux</code> binary accepts configuration flags in the format <code>-Fname=value</code>. For boolean flags, the
<code>value</code> can be one of <code>y</code>, <code>yes</code>, <code>on</code>, <code>true</code>, <code>n</code>, <code>no</code>, <code>off</code>, <code>false</code>. Alternatively, the <code>value</code>
can be omitted which will default to <code>true</code>. For example, to set the solver to <code>cvc5</code> and enable
qualifier scraping:</p>
<pre><code class="language-console">flux -Fsolver=cvc5 -Fscrape-quals path/to/file.rs
</code></pre>
<p>For all available flags, see <a href="https://flux-rs.github.io/flux/doc/flux_config/flags/struct.Flags.html">https://flux-rs.github.io/flux/doc/flux_config/flags/struct.Flags.html</a></p>
<h3 id="cargo-projects"><a class="header" href="#cargo-projects">Cargo Projects</a></h3>
<p>When working with a Cargo project, some of the <a href="guide/install.html#Flux-Flags">flags</a> can be configured in the
<code>[package.metadata.flux]</code> table in <code>Cargo.toml</code>. For example, to enable query caching and set
<code>cvc5</code> as the solver:</p>
<pre><code class="language-toml"># Cargo.toml
[package.metadata.flux]
enabled = true
cache = true
solver = "cvc5"
</code></pre>
<p>Additionally, <code>cargo flux</code> searches for a configuration file called <code>flux.toml</code> with the same format
as the metadata table. The content of <code>flux.toml</code> takes precedence and it's merged with the
content of the <code>metadata</code> table. Note that the content of <code>flux.toml</code> will override the <code>metadata</code>
for all crates, including dependencies. This behavior is likely to change in the future as we figure
out what configurations make sense to have per package and which should only affect the current execution
of <code>cargo flux</code>.</p>
<p>You can see the format of the <code>metadata</code> in <a href="https://flux-rs.github.io/flux/doc/flux_bin/struct.FluxMetadata.html">https://flux-rs.github.io/flux/doc/flux_bin/struct.FluxMetadata.html</a>.</p>
<h3 id="fluxflags-environement-variable"><a class="header" href="#fluxflags-environement-variable"><code>FLUXFLAGS</code> Environement Variable</a></h3>
<p>When running <code>cargo flux</code>, flags defined in <code>FLUXFLAGS</code> will be passed to all <code>flux</code> invocations,
for example, to print timing information for all crates checked by Flux:</p>
<pre><code class="language-console">FLUXFLAGS="-Ftimings" cargo flux
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="about-flux"><a class="header" href="#about-flux">About Flux</a></h1>
<img src="img/logo-wide.svg" class="flux-logo" alt="Flux Logo">
<h2 id="team"><a class="header" href="#team">Team</a></h2>
<p>Flux is being developed by</p>
<ul>
<li><a href="https://github.com/nilehmann">Nico Lehmann</a>,</li>
<li><a href="https://www.cs.ubc.ca/~atgeller/">Adam Geller</a></li>
<li><a href="https://www.cole-k.com/">Cole Kurashige</a></li>
<li><a href="https://gbarthe.github.io/">Gilles Barthe</a></li>
<li><a href="https://nikivazou.github.io/">Niki Vazou</a></li>
<li><a href="https://cseweb.ucsd.edu/~rjhala">Ranjit Jhala</a></li>
</ul>
<h2 id="code"><a class="header" href="#code">Code</a></h2>
<p>Flux is open-source and available <a href="http://github.com/liquid-rust/flux">here</a></p>
<h2 id="publications"><a class="header" href="#publications">Publications</a></h2>
<ul>
<li><a href="https://dl.acm.org/doi/pdf/10.1145/3591283">Lehmann, Nico, Adam T. Geller, Niki Vazou, and Ranjit Jhala. "Flux: Liquid types for rust."  PLDI (2023)</a></li>
<li><a href="https://dl.acm.org/doi/pdf/10.1145/3704885">Lehmann, Nico, Cole Kurashige, Nikhil Akiti, Niroop Krishnakumar, and Ranjit Jhala. "Generic Refinement Types." POPL (2025)</a></li>
</ul>
<h2 id="talks"><a class="header" href="#talks">Talks</a></h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=3iYt2JTXCwM">PLDI'23</a></li>
<li><a href="https://www.youtube.com/watch?v=NIJtZ0yUDX0">SOAP'23</a></li>
</ul>
<h2 id="thanks"><a class="header" href="#thanks">Thanks</a></h2>
<p>This work was supported by the National Science Foundation, European Research Council,
and by generous gifts from Microsoft Research.</p>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<p>This is a prototype! Use at your own risk. Everything could break and it will break.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="refining-types"><a class="header" href="#refining-types">Refining Types</a></h1>
<p>Types bring order to code. For example, if a variable <code>i:usize</code>
then we know <code>i</code> is a number that can be used to index a vector.
Similarly, if <code>v: Vec&lt;&amp;str&gt;</code> then we can be sure that <code>v</code> is a
collection of strings which may <em>be</em> indexed but of course,
not used <em>as</em> an index. However, by itself <code>usize</code> doesn't
tell us how big or small the number and hence the programmer
must still rely on their own wits, a lot of tests, and a dash
of optimism, to ensure that all the different bits fit properly
at run-time.</p>
<p><a href="https://arxiv.org/abs/2010.07763">Refinements</a> are a promising new way to extend
type checkers with logical constraints that <em>specify</em> additional
correctness requirements that can be <em>verified</em> by the compiler,
thereby entirely eliminating various classes of run-time problems.</p>
<p>To begin, let's see how flux lets you refine <em>basic</em> or <em>primitive</em>
types like <code>i32</code> or <code>usize</code> or <code>bool</code> with logical constraints that
can be checked at compile time.</p>
<!-- more -->
<!-- SLIDE -->
<h2 id="indexed-types"><a class="header" href="#indexed-types">Indexed Types</a></h2>
<p>The simplest kind of refinement type in flux is a type that is
<em>indexed</em> by a logical value. For example</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left"><strong>Type</strong></th><th style="text-align: left"><strong>Meaning</strong></th></tr></thead><tbody>
<tr><td style="text-align: left"><code>i32[10]</code></td><td style="text-align: left">The (singleton) set of <code>i32</code> values equal to <code>10</code></td></tr>
<tr><td style="text-align: left"><code>bool[true]</code></td><td style="text-align: left">The (singleton) set of <code>bool</code> values equal to <code>true</code></td></tr>
</tbody></table>
</div><!-- SLIDE -->
<h3 id="flux-specifications"><a class="header" href="#flux-specifications">Flux Specifications</a></h3>
<p>First off, we need to add some incantations that pull in the mechanisms
for writing flux specifications as Rust <em>attributes</em>.</p>
<pre><pre class="playground"><code class="language-rust editable">#![allow(unused)]
extern crate flux_rs;
use flux_rs::attrs::*;</code></pre></pre>
<!-- SLIDE -->
<h3 id="post-conditions"><a class="header" href="#post-conditions">Post-Conditions</a></h3>
<p>We can already start using these indexed types to start writing (and checking)
code. For example, we can write the following specification which says that
the value <em>returned</em> by <code>mk_ten</code> must in fact be <code>10</code></p>
<pre><pre class="playground"><code class="language-rust editable">#[spec(fn() -&gt; i32[10])]
pub fn mk_ten() -&gt; i32 {
    5 + 4
}</code></pre></pre>
<p><strong>Push Play</strong>
Push the "run" button in the pane above. You will see a red squiggle that
and when you hover over the squiggle you will see an error message</p>
<pre><code class="language-bash">error[...]: refinement type error
  |
7 |     5 + 4
  |     ^^^^^ a postcondition cannot be proved
</code></pre>
<p>which says that that the <em>postcondition might not hold</em> which means
that the <em>output</em> produced by <code>mk_ten</code> may not in fact be an <code>i32[10]</code>
as indeed, in this case, the result is <code>9</code>! You can eliminate the error
by <em>editing</em> the body to <code>5 + 4 + 1</code> or <code>5 + 5</code> or just <code>10</code>.</p>
<!-- SLIDE -->
<h3 id="pre-conditions"><a class="header" href="#pre-conditions">Pre-Conditions</a></h3>
<p>You can use an index to <em>restrict the inputs</em> that a function expects
to be called with.</p>
<pre><pre class="playground"><code class="language-rust editable">#[spec(fn (b:bool[true]))]
pub fn assert(b:bool) {
  if !b { panic!("assertion failed") }
}</code></pre></pre>
<p>The specification for <code>assert</code> says you can <em>only</em> call
it with <code>true</code> as the input. So if you write</p>
<pre><pre class="playground"><code class="language-rust editable">fn test(){
  assert(2 + 2 == 4);
  assert(2 + 2 == 5); // fails to type check
}</code></pre></pre>
<p>then <code>flux</code> will complain that</p>
<pre><code class="language-bash">error[FLUX]: precondition might not hold
   |
12 |     assert(2 + 2 == 5); // fails to type check
   |     ^^^^^^^^^^^^^^^^^^
</code></pre>
<p>meaning at the second call to <code>assert</code> the input <em>may not</em>
be <code>true</code>, as of course, in this case, it is not!</p>
<p>Can you edit the code of <code>test</code> to fix the error?</p>
<!-- SLIDE -->
<h2 id="index-parameters-and-expressions"><a class="header" href="#index-parameters-and-expressions">Index Parameters and Expressions</a></h2>
<p>Its not terribly exciting to only talk about <em>fixed</em> values
like <code>10</code> or <code>true</code>. To be more useful, <code>flux</code> lets you index
types by refinement <em>parameters</em>. For example, you can write</p>
<pre><pre class="playground"><code class="language-rust editable">#[spec(fn(n:i32) -&gt; bool[0 &lt; n])]
pub fn is_pos(n: i32) -&gt; bool {
  if 0 &lt; n {
    true
  } else {
    false
  }
}</code></pre></pre>
<p>Here, the type says that <code>is_pos</code></p>
<ul>
<li><strong>takes</strong> as <em>input</em> some <code>i32</code> <em>indexed by</em> <code>n</code></li>
<li><strong>returns</strong> as <em>output</em> the <code>bool</code> <em>indexed by</em> <code>0 &lt; n</code></li>
</ul>
<p>That is, <code>is_pos</code> returns <code>true</code> <em>exactly when</em> <code>0 &lt; n</code>.</p>
<p>We might use this function to check that:</p>
<pre><pre class="playground"><code class="language-rust editable">pub fn test_pos(n: i32) {
  let m = if is_pos(n) { n - 1 } else { 0 };
  assert(0 &lt;= m);
}</code></pre></pre>
<!-- SLIDE -->
<h2 id="existential-types"><a class="header" href="#existential-types">Existential Types</a></h2>
<p>Often we don't care about the <em>exact</em> value of a thing -- but just
care about some <em>properties</em> that it may have. For example, we don't
care that an <code>i32</code> is equal to <code>5</code> or <code>10</code> or <code>n</code> but that it is
non-negative.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left"><strong>Type</strong></th><th style="text-align: left"><strong>Meaning</strong></th></tr></thead><tbody>
<tr><td style="text-align: left"><code>i32{v: 0 &lt;  v}</code></td><td style="text-align: left">The set of <code>i32</code> values that positive</td></tr>
<tr><td style="text-align: left"><code>i32{v: n &lt;= v}</code></td><td style="text-align: left">The set of <code>i32</code> values greater than or equal to <code>n</code></td></tr>
</tbody></table>
</div>
<p>Flux allows such specifications by pairing plain Rust types
with <em>assertions</em> <sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup> that constrain the value.</p>
<!-- SLIDE -->
<h2 id="existential-output-types"><a class="header" href="#existential-output-types">Existential Output Types</a></h2>
<p>For example, we can rewrite <code>mk_10</code> with the output type
<code>i32{v:0&lt;v}</code> that specifies a weaker property:
the value returned by <code>mk_ten_pos</code> is positive.</p>
<pre><pre class="playground"><code class="language-rust editable">#[spec(fn() -&gt; i32{v: 0 &lt; v})]
pub fn mk_ten_pos() -&gt; i32 {
    5 + 5
}</code></pre></pre>
<!-- SLIDE -->
<h2 id="example-absolute-value"><a class="header" href="#example-absolute-value">Example: <code>abs</code>olute value</a></h2>
<p>Similarly, you might specify that a function that computes the <em>absolute</em>
value of an <code>i32</code> with a type which says the result is non-negative <em>and</em>
exceeds the input <code>n</code>.</p>
<pre><pre class="playground"><code class="language-rust editable">#[spec(fn (n:i32) -&gt; i32{v:0&lt;=v &amp;&amp; n&lt;=v})]
pub fn abs(n: i32) -&gt; i32 {
    if 0 &lt;= n {
        n
    } else {
        0 - n
    }
}</code></pre></pre>
<!-- SLIDE -->
<h2 id="combining-indexes-and-constraints"><a class="header" href="#combining-indexes-and-constraints">Combining Indexes and Constraints</a></h2>
<p>Sometimes, we want to <em>combine</em> indexes and constraints in a specification.</p>
<p>For example, suppose we have some code that manipulates
<em>scores</em> which are required to be between <code>0</code> and <code>100</code>.
Now, suppose we want to write a function that adds <code>k</code>
points to a score <code>s</code>. We want to specify that</p>
<ul>
<li>The <em>inputs</em> <code>s</code> and <code>k</code> must be non-negative,</li>
<li>the <em>inputs</em> <code>s + k &lt;= 100</code>, and</li>
<li>The <em>output</em> equals <code>s + k</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">#[spec(fn ({usize[@s] | s + k &lt;= 100}, k:usize) -&gt; usize[s + k])]
fn add_points(s: usize, k: usize) -&gt; usize {
    s + k
}

fn test_add_points() {
    assert(add_points(20, 30) == 50);
    assert(add_points(90, 30) == 120); // fails to type check
}</code></pre></pre>
<p>Note that we use the <code>@s</code> to <em>index</em> the value of the <code>s</code> parameter,
so that we can</p>
<ol>
<li><em>constrain</em> the inputs to <code>s + k &lt;= 100</code>, and</li>
<li><em>refine</em> the value of the output to be exactly <code>usize[s + k]</code>.</li>
</ol>
<p><strong>EXERCISE</strong> Why does flux reject the second call to <code>add_points</code>?</p>
<!-- SLIDE -->
<h2 id="example-factorial"><a class="header" href="#example-factorial">Example: <code>factorial</code></a></h2>
<p>As a last example, you might write a function to compute the factorial of <code>n</code></p>
<pre><pre class="playground"><code class="language-rust editable">#[spec(fn (n:i32) -&gt; i32{v:1&lt;=v &amp;&amp; n&lt;=v})]
pub fn factorial(n: i32) -&gt; i32 {
    let mut i = 0;
    let mut res = 1;
    while i &lt; n {
        i += 1;
        res = res * i;
    }
    res
}</code></pre></pre>
<p>Here the specification says the input must be non-negative, and the
output is at least as large as the input. Note, that unlike the previous
examples, here we're actually <em>changing</em> the values of <code>i</code> and <code>res</code>.</p>
<!-- SLIDE -->
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>In this post, we saw how Flux lets you</p>
<ol>
<li>
<p><em>decorate</em> basic Rust types like <code>i32</code> and <code>bool</code> with
<strong>indices</strong> and <strong>constraints</strong> that let you respectively
<em>refine</em> the sets of values that inhabit that type, and</p>
</li>
<li>
<p><em>specify</em> contracts on functions that state <strong>pre-conditions</strong> on
the sets of legal inputs that they accept, and <strong>post-conditions</strong>
that describe the outputs that they produce.</p>
</li>
</ol>
<p>The whole point of Rust, of course, is to allow for efficient <em>imperative</em>
sharing and updates, without sacrificing thread- or memory-safety. Next time,
we'll see how Flux melds refinements and Rust's ownership to make refinements
happily coexist with imperative code.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<p>These are not arbitrary Rust expressions but a subset of expressions from logics that can be efficiently decided by <a href="https://github.com/flux-rs/flux/blob/main/book/src/guide/specs.md#grammar-of-refinements">SMT Solvers</a> <a href="#fr-1-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="ownership-in-flux"><a class="header" href="#ownership-in-flux">Ownership in Flux</a></h1>
<pre><pre class="playground"><code class="language-rust  editable  hidden">#![allow(unused)]
extern crate flux_rs;
use flux_rs::attrs::*;</code></pre></pre>
<p><a href="https://flux.goto.ucsd.edu/?example=ownership.rs">Online demo</a></p>
<p><a href="tutorial/./01-introducing-flux.html">Previously</a> we saw how to refine basic Rust
types like <code>i32</code> and <code>bool</code> with <em>indices</em> and <em>constraints</em> to
constrain the set of values described by those types. For instance, we
wrote the function <code>assert</code> function which can <em>only</em> be called with <code>true</code></p>
<pre><pre class="playground"><code class="language-rust editable">#[flux_rs::spec(fn (bool[true]))]
fn assert(b: bool) {
    if !b {
        panic!("assertion failed");
    }
}

fn test_assert() {
    assert(2 + 2 == 4);
    assert(2 + 2 == 5); // fails to type check
}</code></pre></pre>
<p>The whole point of Rust, of course, is to allow for efficient
imperative <em>sharing</em> and <em>updates</em>, via the clever type system
that keeps an eye on the <em>ownership</em> of resources to make sure
that aliasing and mutation cannot happen at the same time.</p>
<p>Next, lets see how Flux melds refinements and Rust's ownership
mechanisms to make refinements pleasant in the imperative setting.</p>
<!-- SLIDE -->
<h2 id="exclusive-ownership"><a class="header" href="#exclusive-ownership">Exclusive Ownership</a></h2>
<p>Rust's most basic form of sharing is <em>exclusive</em> ownership,
in which exactly one variable in a function has the right to
mutate a memory location. When a location is exclusively
owned, we can be sure that there are <em>no other references</em>
to it. Consequently, <code>flux</code> can <em>update</em> the type to precisely
track the value whenever the location is changed.</p>
<p>For example, consider the program</p>
<pre><pre class="playground"><code class="language-rust  editable">#[flux_rs::spec(fn () -&gt; i32[3])]
pub fn mk_three() -&gt; i32 {
  let mut r = 0;  // r: i32[0]
  r += 1;
  assert(r == 1); // r: i32[1]
  r += 1;
  assert(r == 2); // r: i32[2]
  r += 1;
  assert(r == 3); // r: i32[3]
  r
}</code></pre></pre>
<p>The variable <code>r</code> has <em>different types</em> at each point inside <code>mk_three</code>.
It starts off as <code>i32[0]</code>. The first increment changes it to <code>i32[1]</code>,
then <code>i32[2]</code> and finally, the returned type <code>i32[3]</code>.</p>
<!-- SLIDE -->
<h2 id="exclusive-ownership-and-loops"><a class="header" href="#exclusive-ownership-and-loops">Exclusive Ownership and Loops</a></h2>
<p>This exclusive ownership mechanism is at work in the <code>factorial</code> example
we signed off with <a href="tutorial/./01-introducing-flux.html">previously</a></p>
<pre><pre class="playground"><code class="language-rust  editable">#[flux_rs::spec(fn (n:i32{0 &lt;= n}) -&gt; i32{v:n &lt;= v})]
pub fn factorial(n: i32) -&gt; i32 {
    let mut i = 0;  // i: i32[0]
    let mut r = 1;  // r: i32[1]
    while i &lt; n {
                    // i: i32{v:0 &lt;= v &lt;= n}
                    // r: i32{v:1 &lt;= v &amp;&amp; i &lt;= v}
        i += 1;
        r = r * i;
    }
    r
}</code></pre></pre>
<p>In the above code, <code>i</code> and <code>r</code> start off at <code>0</code> and <code>1</code> but then
flux <em>infers</em> (a story for another day) that inside the <code>while</code>-loop<sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup></p>
<ul>
<li><code>i</code> has type <code>i32{v:0&lt;=v &amp;&amp; v &lt; n}</code></li>
<li><code>r</code> has type <code>i32{v:1&lt;=v &amp;&amp; i &lt;= v}</code></li>
</ul>
<p>and hence, upon exit since <code>i == n</code> we get that the result is at least <code>n</code>.</p>
<!-- SLIDE -->
<h2 id="borrowing-shared-references"><a class="header" href="#borrowing-shared-references">Borrowing: Shared References</a></h2>
<p>Exclusive ownership suffices for simple local updates
like in <code>factorial</code>. However, for more complex data,
functions must temporarily relinquish ownership to
allow <em>other</em> functions to mutate the data.</p>
<p>Rust cleverly allows this via the notion of
<em>borrowing</em> using two kinds of references
that give callee functions temporary access
to memory location.</p>
<p>The simplest kind of references are <code>&amp;T</code>
which denote <em>read-only</em> access to a value
of type <code>T</code>. For example, we might write <code>abs</code> to take
a shared reference to an <code>i32</code></p>
<pre><pre class="playground"><code class="language-rust  editable">#[flux_rs::spec(fn (p: &amp;i32[@n]) -&gt; i32{v:0&lt;=v &amp;&amp; n&lt;=v})]
pub fn abs(p: &amp;i32) -&gt; i32 {
    let n = *p;
    if 0 &lt;= n {
        n
    } else {
        0 - n
    }
}</code></pre></pre>
<p>Notice that the <em>input</em> type has changed. Now, the function</p>
<ul>
<li><strong>accepts</strong> <code>p</code>, a <em>reference</em> to an <code>i32</code> whose value is <code>n</code> as denoted by <code>@n</code></li>
<li><strong>returns</strong> an <code>i32</code> that is non-negative and larger than <code>n</code></li>
</ul>
<p>The <code>@</code> marks the <code>n</code> as a <em>refinement parameter</em> whose value
is automatically computed by flux during type checking.</p>
<!-- SLIDE -->
<h3 id="calling-abs-with-a-reference"><a class="header" href="#calling-abs-with-a-reference">Calling <code>abs</code> with a reference</a></h3>
<p>So, for example, Flux can check the below code by automatically
determining that the refinement parameter at the call-site is <code>10</code>.</p>
<pre><pre class="playground"><code class="language-rust  editable">pub fn test_abs() {
    let z = 10;
    assert(0 &lt;= abs(&amp;z));
    assert(10 &lt;= abs(&amp;z))
}</code></pre></pre>
<!-- SLIDE -->
<h3 id="refinement-parameters"><a class="header" href="#refinement-parameters">Refinement Parameters</a></h3>
<p>As an aside, we have secretly been using <em>refinement parameters</em>
like <code>@n</code> all along. For example, Flux automatically <em>desugars</em>
the signature <code>fn(n:i32{0 &lt;= n} -&gt; ...</code> that we wrote for <code>factorial</code> into</p>
<pre><code>fn ({i32[@n] : 0 &lt;= n}) -&gt; i32{v:n &lt;= v}
</code></pre>
<p>where <code>@n</code> is a refinement parameter that is <em>implicitly</em> determined
from the rust parameter <code>n:i32</code>. However, <em>explicit</em> parameters are
essential to <em>name</em> the value of what a reference points to.
In <code>abs</code> the <code>rust</code> parameter <code>p</code> names the reference but the
<code>@n</code> names the (input) <em>value</em> and lets us use it to provide
more information about the output of <code>abs</code>.</p>
<p><strong>EXERCISE</strong> Flux is <em>modular</em> in that the
<em>only</em> information it knows about the
implementation of <code>abs</code> is the signature.
For example, suppose we change the output type
of <code>abs</code> to <code>i32{v:0&lt;=v}</code>, that is, we remove the
<code>n &lt;= v</code> conjunct. Can you predict which <code>assert</code>
will be rejected by flux?</p>
<!-- SLIDE -->
<h2 id="borrowing-mutable-references"><a class="header" href="#borrowing-mutable-references">Borrowing: Mutable References</a></h2>
<p>References of type <code>&amp;mut T</code> denote <em>mutable</em> references that can be
used to (read and) write or update the contents of a <code>T</code> value.
Crucially, Rust ensures that while there may be multiple read-only (shared)
references to a location, there is at most one <em>active</em> writeable (mutable)
reference at any point in time.</p>
<p>Flux exploits the semantics of <code>&amp;mut T</code> to treat <code>T</code> as an <em>invariant</em>
of the underlying data. As an example, consider the following function
that <em>decrements</em> the value of a mutable reference while ensuring the
data is non-negative:</p>
<pre><pre class="playground"><code class="language-rust  editable">#[flux_rs::spec(fn(p: &amp;mut i32{v:0 &lt;= v}))]
pub fn decr(p: &amp;mut i32) {
    *p = *p - 1;
}</code></pre></pre>
<p>Flux complains that</p>
<pre><code>error[FLUX]: assignment might be unsafe
   |
13 |         *p = *p - 1;
   |         ^^^^^^^^^^^
</code></pre>
<p>as in fact, we <em>may</em> be writing a negative value into <code>*p</code>
for example, if the old value was zero. We can fix this
code by guarding the update with a test that ensures the
original contents are in fact <em>non-zero</em></p>
<p><strong>EXERCISE</strong> Can you <em>modify</em> the code for <code>decr</code> so that flux verifies it?</p>
<!-- SLIDE -->
<h3 id="aliased-references"><a class="header" href="#aliased-references">Aliased References</a></h3>
<p>Flux uses Rust's borrowing rules to track invariants even when
there may be aliasing. As an example, consider the function</p>
<pre><pre class="playground"><code class="language-rust  editable">#[flux_rs::spec(fn (bool) -&gt; i32{v:0 &lt;= v})]
fn test_alias(z: bool) -&gt; i32 {
    let mut x = 1;  // x: i32[1]
    let mut y = 2;  // y: i32[2]
    let r = if z { &amp;mut x } else { &amp;mut y };
                    // r: &amp;mut i32{v:0 &lt;= v}
    decr(r);
    *r
}</code></pre></pre>
<p>The reference <code>r</code> could point to <em>either</em> <code>x</code> or <code>y</code> depending
on the (unknown) value of the boolean <code>z</code>. Nevertheless, Flux
determines that <em>both</em> references <code>&amp;mut x</code> and <code>&amp;mut y</code> point
to values of the more general type <code>i32{v:0&lt;=v}</code> and hence,
infers <code>r : &amp;mut i32{v:0&lt;=v}</code> which allows us it to then call
<code>decr</code> with the reference and guarantee the result (after <code>decr</code>)
is still non-negative.</p>
<!-- SLIDE -->
<h3 id="invariants-are-not-enough"><a class="header" href="#invariants-are-not-enough">Invariants are not enough!</a></h3>
<p>In many situations, we want to lend a value to another function
that actually <em>changes</em> the value's (refinement) type upon exit.
For example, consider the following function to <em>increment</em>
a reference to a non-negative <code>i32</code></p>
<pre><pre class="playground"><code class="language-rust  editable">#[flux_rs::spec(fn (p: &amp;mut i32{v:0 &lt;= v}))]
fn incr_inv(p: &amp;mut i32) {
  *p += 1
}

fn test_incr_inv() {
  let mut z = 10;
  incr_inv(&amp;mut z);
  assert(z == 11);
}</code></pre></pre>
<p>The only information that <code>flux</code> has about <code>incr</code> what
it says in its <code>spec</code>, namely, that <code>p</code> remains non-negative.
Flux is blissfully unaware that <code>incr</code> <em>increments</em>
the value of <code>p</code>, and it cannot prove that after the
call, <code>z == 11</code> and hence, complains that <code>assert</code>
may fail even though it will obviously succeed!</p>
<!-- SLIDE -->
<h2 id="borrowing-updatable-references"><a class="header" href="#borrowing-updatable-references">Borrowing: <em>Updatable</em> References</a></h2>
<p>To verify <code>test_incr</code> we need a signature for <code>incr</code> that says
that its <em>output</em> is indeed one greater<sup class="footnote-reference" id="fr-2-1"><a href="#footnote-2">2</a></sup> than its input.</p>
<p>Flux extends Rust <code>&amp;mut T</code> with the notion of <strong>updatable references</strong>
which <em>additionally</em> specify how the type is <em>changed</em> when
the function exits<sup class="footnote-reference" id="fr-3-1"><a href="#footnote-3">3</a></sup>, using an <code>ensures</code> clause that specifies
the <em>modified</em> type of the reference.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[flux_rs::spec(fn(p: &amp;mut i32[@n]) ensures p:i32[n+1])]
fn incr(p: &amp;mut i32) {
  *p += 1
}</code></pre></pre>
<p>The Flux signature refines the plain Rust one to specify that</p>
<ol>
<li><code>p</code> is a strong reference to an <code>i32</code>,</li>
<li>the <em>input type</em> of <code>*p</code> is <code>i32[n]</code>, and</li>
<li>the <em>output type</em> of <code>*p</code> is <code>i32[n+1]</code>.</li>
</ol>
<p>With this specification, Flux merrily checks <code>test_incr</code>, by
determining that the refinement parameter <code>@n</code> is <code>10</code> and
hence, that upon return <code>x: i32[11]</code>.</p>
<pre><pre class="playground"><code class="language-rust  editable">fn test_incr() {
  let mut z = 10;
  incr_inv(&amp;mut z);
  assert(z == 11);
}</code></pre></pre>
<!-- SLIDE -->
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>To sum up, Flux exploits Rust's ownership mechanisms
to track properties of <em>shared</em> (<code>&amp;T</code>) and <em>mutable</em>
(<code>&amp;mut T</code>) references, and additionally uses (<code>ensures</code>)
clauses to specify when the type itself is <em>changed</em> by a call.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<p>For those familiar with the term, these types are <em>loop invariants</em> <a href="#fr-1-1">↩</a></p>
</li>
<li id="footnote-2">
<p>Setting aside the issue of overflows for now <a href="#fr-2-1">↩</a></p>
</li>
<li id="footnote-3">
<p>Thereby allowing so-called <em>strong updates</em> in the type specifications <a href="#fr-3-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="refining-structs"><a class="header" href="#refining-structs">Refining Structs</a></h1>
<pre><pre class="playground"><code class="language-rust  editable  hidden">#![allow(unused)]
extern crate flux_rs;
use flux_rs::attrs::*;

#[flux_rs::spec(fn (bool[true]))]
fn assert(b: bool) {
    if !b {
        panic!("assertion failed");
    }
}</code></pre></pre>
<p>Previously, we saw how to slap refinements on existing <em>built-in</em>
or <em>primitive</em> Rust types. For example,</p>
<ul>
<li><code>i32[10]</code> specifies the <code>i32</code> that is <em>exactly</em> equal to <code>10</code> and</li>
<li><code>i32{v: 0 &lt;= v &amp;&amp; v &lt; 10}</code> specifies an <code>i32</code> between <code>0</code> and <code>10</code>.</li>
</ul>
<p>Next, lets see how to attach refinements to <em>user-defined</em> types,
so we can precisely define the set of <em>legal</em> values of those types.</p>
<!-- SLIDE -->
<h2 id="positive-integers"><a class="header" href="#positive-integers">Positive Integers</a></h2>
<p>Lets start with an example posted on the <a href="https://github.com/flux-rs/flux/issues/1106">flux gitHub</a>:</p>
<blockquote>
<p>how do you create a Positivei32? I can think of two ways: <code>struct Positivei32 { val: i32, }</code> and struct <code>Positivei32(i32);</code> but I do not know how to apply the refinements for them. I want it to be an invariant that the i32 value is &gt;= 0. How would I do this?</p>
</blockquote>
<p>With flux, you can define the <code>Positivei32</code> type as follows:</p>
<pre><pre class="playground"><code class="language-rust  editable">#[refined_by(n: int)]
#[invariant(n &gt; 0)]
struct Positivei32 {
  #[field(i32[n])]
  val: i32
}</code></pre></pre>
<p>In addition to defining the plain Rust type <code>Positivei32</code>,
the flux refinements say <em>three</em> distinct things.</p>
<ol>
<li>The <code>refined_by(n: int)</code> tells flux to refine each
<code>Positivei32</code> with a special <code>int</code>-sorted <em>index</em> named <code>n</code>,</li>
<li>the <code>invariant(n &gt; 0)</code> says that the index <code>n</code>
is always positive, and,</li>
<li>the <code>field</code> attribute on <code>val</code> says that the
type of the field <code>val</code> is an <code>i32[n]</code>
i.e. is an <code>i32</code> whose exact value is <code>n</code>.</li>
</ol>
<!-- SLIDE -->
<h3 id="creating-positive-integers"><a class="header" href="#creating-positive-integers">Creating Positive Integers</a></h3>
<p>Now, you would create a <code>Positivei32</code> pretty much as you might in Rust:</p>
<pre><pre class="playground"><code class="language-rust  editable">#[spec(fn() -&gt; Positivei32)]
fn mk_positive_1() -&gt; Positivei32 {
  Positivei32 { val: 1 }
}</code></pre></pre>
<p>and flux will prevent you from creating an <em>illegal</em> <code>Positivei32</code>, like</p>
<pre><pre class="playground"><code class="language-rust  editable">#[spec(fn() -&gt; Positivei32)]
fn mk_positive_0() -&gt; Positivei32 {
  Positivei32 { val: 0 }
}</code></pre></pre>
<!-- SLIDE -->
<h3 id="a-constructor"><a class="header" href="#a-constructor">A Constructor</a></h3>
<p><strong>EXERCISE</strong> Consider the following <code>new</code> constructor for <code>Positivei32</code>. Why does flux reject it?
Can you figure out how to fix the <code>spec</code> for the constructor so flux will be appeased?</p>
<pre><pre class="playground"><code class="language-rust  editable">impl Positivei32 {
  pub fn new(val: i32) -&gt; Self {
    Positivei32 { val }
  }
}</code></pre></pre>
<!-- SLIDE -->
<h3 id="a-smart-constructor"><a class="header" href="#a-smart-constructor">A "Smart" Constructor</a></h3>
<p><strong>EXERCISE</strong> Here is a different, constructor that should work
for <em>any</em> input <code>n</code> but which may return <code>None</code> if the input is
invalid. Can you fix the code so that flux accepts <code>new_opt</code>?</p>
<pre><pre class="playground"><code class="language-rust  editable">impl Positivei32 {
  pub fn new_opt(val: i32) -&gt; Option&lt;Self&gt; {
      Some(Positivei32 { val })
  }
}</code></pre></pre>
<!-- SLIDE -->
<h3 id="tracking-the-field-value"><a class="header" href="#tracking-the-field-value">Tracking the Field Value</a></h3>
<p>In addition to letting us constrain the underlying <code>i32</code> to be positive,
the <code>n: int</code> index lets flux precisely <em>track</em> the value of the <code>Positivei32</code>.
For example, we can say that the following function returns a very specific <code>Positivei32</code>:</p>
<pre><pre class="playground"><code class="language-rust  editable">#[spec(fn() -&gt; Positivei32[{n:10}])]
fn mk_positive_10() -&gt; Positivei32 {
  Positivei32 { val: 10 }
}</code></pre></pre>
<p>(When there is a single index, we can just write <code>Positivei32[10]</code>.)</p>
<p>Since the field <code>val</code> corresponds to the <em>tracked index</em>,
flux "knows" what <code>val</code> is from the index, and hence lets us check that</p>
<pre><pre class="playground"><code class="language-rust  editable">#[spec(fn() -&gt; i32[10])]
fn test_ten() -&gt; i32 {
    let p = mk_positive_10(); // p   : Positivei32[{n: 10}]
    let res = p.val;          // res : i32[10]
    res
}</code></pre></pre>
<!-- SLIDE -->
<h3 id="tracking-the-value-in-the-constructor"><a class="header" href="#tracking-the-value-in-the-constructor">Tracking the Value in the Constructor</a></h3>
<p><strong>EXERCISE</strong> Scroll back up, and modify the <code>spec</code> for <code>new</code>
so that the below code verifies. That is, modify the <code>spec</code>
so that it says what the value of <code>val</code> is when <code>new</code> returns
a <code>Positivei32</code>. You will likely need to <em>combine</em> indexes
and constraints as shown in <a href="tutorial/./01-refinements.html#combining-indexes-and-constraints">the example <code>add_points</code></a>.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[spec(fn() -&gt; i32[99])]
fn test_new() -&gt; i32 {
    let p = Positivei32::new(99);
    let res = p.val;
    res
}</code></pre></pre>
<!-- SLIDE -->
<h3 id="field-vs-index"><a class="header" href="#field-vs-index">Field vs. Index?</a></h3>
<p>At this point, you might be wondering why, since <code>n</code> is the value of the field <code>val</code>,
we didn't just name the index <code>val</code> instead of <code>n</code>?</p>
<p>Indeed, we could have named it <code>val</code>.</p>
<p>However, we picked a different name to emphasize that the index is <em>distinct from</em>
the field. The field actually exists at run-time, but in contrast, the index is a
<em>type-level property</em> that only lives at compile-time.</p>
<!-- SLIDE -->
<h2 id="integers-in-a-range"><a class="header" href="#integers-in-a-range">Integers in a Range</a></h2>
<p>Of course, once we can index and constrain a single field, we can do so for many fields.</p>
<p>For instance, suppose we wanted to write a <code>Range</code> type with two fields <code>start</code> and <code>end</code>
which are integers such that <code>start &lt;= end</code>. We might do so as</p>
<pre><pre class="playground"><code class="language-rust  editable">#[refined_by(start: int, end: int)]
#[invariant(start &lt;= end)]
struct Range {
  #[field(i32[start])]
  start: i32,
  #[field(i32[end])]
  end: i32,
}</code></pre></pre>
<p>Note that this time around, we're using the <em>same names</em> for the index as the field
names (even though they are conceptually distinct things).</p>
<!-- SLIDE -->
<h3 id="legal-ranges"><a class="header" href="#legal-ranges">Legal Ranges</a></h3>
<p>Again, the refined <code>struct</code> specification will ensure we only create legal <code>Range</code> values.</p>
<pre><pre class="playground"><code class="language-rust  editable">fn test_range() {
    vec![
        Range { start: 0, end: 10 }, // ok
        Range { start: 15, end: 5 }, // rejected!
    ];
}</code></pre></pre>
<!-- SLIDE -->
<h3 id="a-range-constructor"><a class="header" href="#a-range-constructor">A Range Constructor</a></h3>
<p><strong>EXERCISE</strong> Fix the specification of the <code>new</code>
constructor for <code>Range</code> so that both <code>new</code> and
<code>test_range_new</code> are accepted by flux. (Again,
you will need to <em>combine</em> indexes and constraints
as shown in <a href="tutorial/./01-refinements.html#combining-indexes-and-constraints">the example <code>add_points</code></a>.)</p>
<pre><pre class="playground"><code class="language-rust  editable">impl Range {
    pub fn new(start: i32, end: i32) -&gt; Self {
        Range { start, end }
    }
}

#[spec(fn() -&gt; Range[{start: 0, end: 10}])]
fn test_range_new() -&gt; Range {
    let rng = Range::new(0, 10);
    assert(rng.start == 0);
    assert(rng.end == 10);
    rng
}</code></pre></pre>
<!-- SLIDE -->
<h3 id="combining-ranges"><a class="header" href="#combining-ranges">Combining Ranges</a></h3>
<p>Lets write a function that computes the <em>union</em> of two ranges.
For example, given the range from <code>10-20</code> and <code>15-25</code>, we might
want to return the the union is <code>10-25</code>.</p>
<pre><pre class="playground"><code class="language-rust  editable">fn min(x:i32, y:i32) -&gt; i32 {
  if x &lt; y { x } else { y }
}

fn max(x:i32, y:i32) -&gt; i32 {
  if x &lt; y { y } else { x }
}

fn union(r1: Range, r2: Range) -&gt; Range {
  let start = min(r1.start, r2.start);
  let end = max(r2.end, r2.end);
  Range { start, end }
}</code></pre></pre>
<p><strong>EXERCISE</strong> Can you figure out how to fix the <code>spec</code> for <code>min</code> and <code>max</code>
so that flux will accept that <code>union</code> only constructs legal <code>Range</code> values?</p>
<!-- SLIDE -->
<h2 id="refinement-functions"><a class="header" href="#refinement-functions">Refinement Functions</a></h2>
<p>When <em>code</em> get's more complicated, we like to abstract it into reusable
functions. Flux lets us do the same for refinements too. For example, we
can define refinement-level functions <code>min</code> and <code>max</code> which take <code>int</code>
(not <code>i32</code> or <code>usize</code> but logical <code>int</code>) as input and return that as output.</p>
<pre><pre class="playground"><code class="language-rust  editable">defs! {
    fn min(x: int, y: int) -&gt; int {
        if x &lt; y { x } else { y }
    }
    fn max(x: int, y: int) -&gt; int {
        if x &lt; y { y } else { x }
    }
}</code></pre></pre>
<p>We can now use refinement functions like <code>min</code> and <code>max</code> inside types.
For example, the output type of <code>decr</code> precisely tracks the decremented value.</p>
<pre><pre class="playground"><code class="language-rust  editable">impl Positivei32 {
  #[spec(fn(&amp;Self[@p]) -&gt; Self[max(1, p.n - 1)])]
  fn decr(&amp;self) -&gt; Self {
    let val = if self.val &gt; 1 { self.val - 1 } else { self.val };
    Positivei32 { val }
  }
}

fn test_decr() {
  let p = Positivei32{val: 2}; // p : Positivei32[2]
  assert(p.val == 2);
  let p = p.decr();            // p : Positivei32[1]
  assert(p.val == 1);
  let p = p.decr();            // p : Positivei32[1]
  assert(p.val == 1);
}</code></pre></pre>
<!-- SLIDE -->
<h3 id="combining-ranges-precisely"><a class="header" href="#combining-ranges-precisely">Combining Ranges, Precisely</a></h3>
<p><strong>EXERCISE</strong> The <code>union</code> function that we wrote
above says <em>some</em> <code>Range</code> is returned, but nothing
about <em>what</em> that range actually is! Fix the <code>spec</code>
for <code>union</code> below, so that flux accepts <code>test_union</code> below.</p>
<pre><pre class="playground"><code class="language-rust  editable">impl Range {
  #[spec(fn(&amp;Self[@r1], &amp;Self[@r2]) -&gt; Self)]
  pub fn union(&amp;self, other: &amp;Range) -&gt; Range {
    let start = if self.start &lt; other.start {
        self.start
    } else {
        other.start
    };
    let end = if self.end &lt; other.end {
        other.end
    } else {
        self.end
    };
    Range { start, end }
  }
}

fn test_union() {
  let r1 = Range { start: 10, end: 20 };
  let r2 = Range { start: 15, end: 25 };
  let r3 = r1.union(&amp;r2);
  assert(r3.start == 10);
  assert(r3.end == 25);
}</code></pre></pre>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<p>To conclude, we saw how you can use flux to refine user-defined <code>struct</code> to track,
at the type-level, the values of fields, and to then constrain the sets of <em>legal</em>
values for those structs.</p>
<p>To see a more entertaining example, <a href="https://github.com/flux-rs/flux/blob/f200714dfae5e7c9a3bdf7231191499f56aac45b/tests/tests/pos/surface/date.rs">check out this code</a>
which shows how we can use refinements to ensure that only legal <code>Date</code>s can be constructed
at compile time!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="refining-enums"><a class="header" href="#refining-enums">Refining Enums</a></h1>
<pre><pre class="playground"><code class="language-rust  editable  hidden">#![allow(unused)]
extern crate flux_rs;
use flux_rs::attrs::*;

#[flux_rs::spec(fn (bool[true]))]
fn assert(b: bool) {
    if !b {
        panic!("assertion failed");
    }
}</code></pre></pre>
<p><a href="tutorial/./03-structs.html">Previously</a> we saw how to refine structs to constrain the space
of legal values, for example, to define a <code>Positivei32</code> or a <code>Range</code> <code>struct</code> where
the <code>start</code> was less than or equal to the <code>end</code>. Next, lets see how the same mechanism
can be profitably used to let us check properties of <code>enums</code> at compile time.</p>
<!-- SLIDE -->
<h2 id="failure-is-an-option"><a class="header" href="#failure-is-an-option">Failure is an Option</a></h2>
<p>Rust's type system is really terrific for spotting all
manner of bugs at compile time. However, that just makes
it all the more disheartening to get runtime errors like</p>
<pre><code>thread ... panicked at ... called `Option::unwrap()` on a `None` value
</code></pre>
<p>Lets see how to refine <code>enum</code>'s like <code>Option</code> to
let us <code>unwrap</code> without the anxiety of run-time failure.</p>
<!-- SLIDE -->
<h3 id="a-refined-option"><a class="header" href="#a-refined-option">A Refined Option</a></h3>
<p>To do so, lets define a custom <code>Option</code> type <sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup> that
is indexed by a <code>bool</code> which indicates whether or not
the option is valid (i.e. <code>Some</code> or <code>None</code>):</p>
<pre><pre class="playground"><code class="language-rust  editable">#[refined_by(valid: bool)]
enum Option&lt;T&gt; {
    #[variant((T) -&gt; Option&lt;T&gt;[{valid: true}])]
    Some(T),
    #[variant(Option&lt;T&gt;[{valid: false}])]
    None,
}</code></pre></pre>
<p>As with <code>std::option::Option</code>, we have two variants</p>
<ul>
<li><code>Some</code>, with the "payload" <code>T</code> and</li>
<li><code>None</code>, without.</li>
</ul>
<p>However, we have tricked out the type in two ways.</p>
<ul>
<li>First, we added a <code>bool</code> sorted index that aims to track whether the option is <code>valid</code>;</li>
<li>Second, we used the <code>variant</code> attribute to specify the value of the index for the <code>Some</code> and <code>None</code> cases.</li>
</ul>
<!-- SLIDE -->
<h3 id="constructing-options"><a class="header" href="#constructing-options">Constructing Options</a></h3>
<p>The definition above tells flux that <code>Some(...)</code>
has the refined type <code>Option&lt;...&gt;[{valid: true}]</code>,
and <code>None</code> has the refined type <code>Option&lt;...&gt;[{valid: false}]</code>.</p>
<p><strong>NOTE</strong> When there is a <em>single</em> refinement index, we can skip the <code>{valid:b}</code>
and just write <code>b</code>.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[spec(fn () -&gt; Option&lt;i32&gt;[true])]
fn test_some() -&gt; Option&lt;i32&gt; {
  Option::Some(12)
}

#[spec(fn () -&gt; Option&lt;i32&gt;[false])]
fn test_none() -&gt; Option&lt;i32&gt; {
  Option::None
}</code></pre></pre>
<!-- SLIDE -->
<h3 id="destructing-options-by-pattern-matching"><a class="header" href="#destructing-options-by-pattern-matching">Destructing Options by Pattern Matching</a></h3>
<p>The neat thing about refining variants is that <em>pattern matching</em>
on the <code>enum</code> tells flux what the variant's refinements are.</p>
<p>For example, consider the following implementation of <code>is_some</code></p>
<pre><pre class="playground"><code class="language-rust  editable">impl&lt;T&gt; Option&lt;T&gt; {
  #[spec(fn(&amp;Self[@valid]) -&gt; bool[valid])]
  pub fn is_some(&amp;self) -&gt; bool {
    match self {
      Option::Some(_) =&gt; true,  // self : &amp;Option&lt;..&gt;[true]
      Option::None =&gt; false,    // self : &amp;Option&lt;..&gt;[false]
    }
  }
}</code></pre></pre>
<!-- SLIDE -->
<h3 id="never-do-this"><a class="header" href="#never-do-this">Never Do This!</a></h3>
<p>When working with <code>Option</code> types, or more generally,
with <code>enum</code>s, we often have situations in pattern-match
cases where we "know" that that case will not arise.</p>
<p>Typically we mark those cases with an <code>unreachable!()</code> call.</p>
<p>With flux, we can do even more: we can <em>prove</em>, at compile-time,
that those cases will never, in fact, be executed.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[spec(fn () -&gt; _ requires false)]
fn unreachable() -&gt; ! {
    assert(false);  // flux will prove this is unreachable
    unreachable!(); // panic if we ever get here
}</code></pre></pre>
<p>The <em>precondition</em> <code>false</code> ensures that the <em>only</em> way that
a call to <code>unreachable</code> can be verified is when flux can prove
that the call-site is "dead code".</p>
<pre><pre class="playground"><code class="language-rust  editable">fn test_unreachable(n: usize) {
  let x = 12;           // x : usize[12]
  let x = 12 + n;       // x : usize[12 + n] where 0 &lt;= n
  if x &lt; 12 {
    unreachable();      // impossible, as x &gt;= 12
  }
}</code></pre></pre>
<!-- SLIDE -->
<h3 id="unwrap-without-anxiety"><a class="header" href="#unwrap-without-anxiety">Unwrap Without Anxiety!</a></h3>
<p>Lets use our refined <code>Option</code> to implement a safe <code>unwrap</code> function.</p>
<pre><pre class="playground"><code class="language-rust  editable">impl &lt;T&gt; Option&lt;T&gt; {
  #[spec(fn(Self[true]) -&gt; T)]
  pub fn unwrap(self) -&gt; T {
    match self {
      Option::Some(v) =&gt; v,
      Option::None =&gt; unreachable(),
    }
  }
}</code></pre></pre>
<p>The <code>spec</code> requires that <code>unwrap</code> is <em>only</em> called
with an <code>Option</code> whose (<code>valid</code>) index is <code>true</code>,
i.e. <code>Some(...)</code>.</p>
<p>The <code>None</code> pattern is matched only when the index
is <code>false</code> which is impossible, as it contradicts
the precondition.</p>
<p>Hence, flux concludes that pattern is dead code
(like the <code>x &lt; 12</code> branch is dead code in the
<code>test_unreachable</code> above.)</p>
<!-- SLIDE -->
<h2 id="using-unwrap"><a class="header" href="#using-unwrap">Using <code>unwrap</code></a></h2>
<p>Next, lets see some examples of how to use refined options
to safely <code>unwrap</code>.</p>
<!-- SLIDE -->
<h3 id="safe-division"><a class="header" href="#safe-division">Safe Division</a></h3>
<p>Here's a safe divide-by-zero function that returns an <code>Option&lt;i32&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust  editable">#[spec(fn(n:i32, k:i32) -&gt; Option&lt;i32&gt;)]
pub fn safe_divide(n: i32, k: i32) -&gt; Option&lt;i32&gt; {
  if k &gt; 0 {
    Option::Some(n / k)
  } else {
    Option::None
  }
}</code></pre></pre>
<p><strong>EXERCISE</strong> Why does the test below fail to type check?
Can you fix the <code>spec</code> for <code>safe_divide</code> so flux is happy
with <code>test_safe_divide</code>?</p>
<pre><pre class="playground"><code class="language-rust  editable">fn test_safe_divide() -&gt; i32 {
    safe_divide(10, 2).unwrap()
}</code></pre></pre>
<!-- SLIDE -->
<h3 id="smart-constructors-revisited"><a class="header" href="#smart-constructors-revisited">Smart Constructors Revisited</a></h3>
<p>Recall the <a href="tutorial/./03-structs.html#positive-integers"><code>struct Positivei32</code></a>
and the smart constructor we wrote for it.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[refined_by(n: int)]
#[invariant(n &gt; 0)]
struct Positivei32 {
    #[field(i32[n])]
    val: i32
}

impl Positivei32 {
  #[spec(fn(val: i32) -&gt; Option&lt;Self&gt;)]
  pub fn new(val: i32) -&gt; Option&lt;Self&gt; {
    if val &gt; 0 {
      Option::Some(Positivei32 { val })
    } else {
      Option::None
    }
  }
}</code></pre></pre>
<p><strong>EXERCISE</strong> The code below has a function that
invokes the smart constructor and then <code>unwrap</code>s
the result. Why is flux complaining? Can you fix
the <code>spec</code> of <code>new</code> so that the <code>test_unwrap</code> figure
out how to fix the <code>spec</code> of <code>new</code> so that <code>test_new_unwrap</code>
is accepted?</p>
<pre><pre class="playground"><code class="language-rust  editable">fn test_new_unwrap() {
    Positivei32::new(10).unwrap();
}</code></pre></pre>
<!-- SLIDE -->
<h2 id="typestates-a-refined-timer"><a class="header" href="#typestates-a-refined-timer">TypeStates: A Refined Timer</a></h2>
<p>Lets look a different way to use refined <code>enum</code>s.
On the <a href="https://flux-rs.zulipchat.com/#narrow/channel/486098-general/topic/greetings/near/509911720">flux zulip</a> we were asked
if we could write an <code>enum</code> to represent a <code>Timer</code>
with two variants:</p>
<ul>
<li><code>Inactive</code> indicating that the timer is not running, and</li>
<li><code>CountDown(n)</code> indicating that the timer is counting down from <code>n</code> seconds.</li>
</ul>
<p>Somehow using refinements to ensure that the timer can only
be set to <code>Inactive</code> when <code>n &lt; 1</code>.</p>
<!-- SLIDE -->
<h3 id="refined-timers"><a class="header" href="#refined-timers">Refined Timers</a></h3>
<p>To do so, lets define the <code>Timer</code>, refined with an <code>int</code> index that tracks
the number of remaining seconds.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[flux::refined_by(remaining: int)]
enum Timer {
    #[flux::variant(Timer[0])]
    Inactive,

    #[flux::variant((usize[@n]) -&gt; Timer[n])]
    CountDown(usize)
}</code></pre></pre>
<p>The flux definitions ensure that <code>Timer</code> has two variants</p>
<ul>
<li><code>Inactive</code>, which has a <code>remaining</code> index of <code>0</code>, and</li>
<li><code>CountDown(n)</code>, which has a <code>remaining</code> index of <code>n</code>.</li>
</ul>
<!-- SLIDE -->
<h3 id="timer-implementation"><a class="header" href="#timer-implementation">Timer Implementation</a></h3>
<p>We can now implement the <code>Timer</code> with a constructor and a method to set it to <code>Inactive</code>.</p>
<pre><pre class="playground"><code class="language-rust  editable">impl Timer {
    #[spec(fn (n: usize) -&gt; Timer[n])]
    pub fn new(n: usize) -&gt; Self {
       Timer::CountDown(n)
    }

    #[spec(fn (self: &amp;mut Self[0]))]
    fn deactivate(&amp;mut self) {
        *self = Timer::Inactive
    }
}</code></pre></pre>
<!-- SLIDE -->
<h3 id="deactivate-the-timer"><a class="header" href="#deactivate-the-timer">Deactivate the Timer</a></h3>
<p>Now, you can see that flux will only let us <code>set_inactive</code>
a timer whose countdown is at <code>0</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn test_deactivate() {
  let mut t0 = Timer::new(0);
  t0.deactivate(); // verifies

  let mut t3 = Timer::new(3);
  t3.deactivate(); // rejected
}
<span class="boring">}</span></code></pre></pre>
<!-- SLIDE -->
<h3 id="ticking-the-timer"><a class="header" href="#ticking-the-timer">Ticking the Timer</a></h3>
<p>Here is a function to <code>tick</code> the timer down by one second.</p>
<!-- // #[spec(fn (self: &mut Self[@s]) ensures self: Self[if n > 1 then n-1 else 0])] -->
<pre><pre class="playground"><code class="language-rust  editable">impl Timer {
  #[spec(fn (self: &amp;mut Self[@s]) ensures self: Self)]
  fn tick(&amp;mut self) {
    match self {
      Timer::CountDown(s) =&gt; {
        let n = *s;
        if n &gt; 0 {
          *s = n - 1;
        }
      }
      Timer::Inactive =&gt; {},
    }
  }
}</code></pre></pre>
<p><strong>EXERCISE</strong> Can you fix the <code>spec</code> for <code>tick</code> so that flux accepts the following test?</p>
<pre><pre class="playground"><code class="language-rust  editable">fn test_tick() {
  let mut t = Timer::new(3);
  t.tick();       // should decrement to 2
  t.tick();       // should decrement to 1
  t.tick();       // should decrement to 0
  t.deactivate(); // should set to Inactive
}</code></pre></pre>
<h2 id="summary-3"><a class="header" href="#summary-3">Summary</a></h2>
<p>In this chapter, we saw how you refine an <code>enum</code> with indices, and then specify
the values of the indices for each <code>variant</code>. This let us, for example, determine
whether an <code>Option</code> is <code>Some</code> or <code>None</code> at compile time, and to safely <code>unwrap</code>
the former, and to encode a "typestate" mechanism for a <code>Timer</code> that tracks how
many seconds remain in a countdown, ensuring we only <code>deactivate</code> when the timer
has expired.</p>
<p>You can do various other fun things, like</p>
<ul>
<li>track the <a href="https://github.com/flux-rs/flux/blob/main/tests/tests/pos/enums/list00.rs">length</a> of a linked list or</li>
<li>track the set of <a href="https://github.com/flux-rs/flux/blob/main/tests/tests/pos/enums/list01.rs">elements</a> in the list, or</li>
<li>determine whether an expression is in <a href="tutorial/./10-case-study-anf.html">normal form</a>, or</li>
<li>ensure the layers of a <a href="tutorial/./12-case-study-neural.html">neural network</a>
are composed correctly.</li>
</ul>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<p>In the chapter on <a href="tutorial/06-extern-specs.html">extern specifications</a> we will explain how to "retrofit" these refinements onto the existing <code>std::option::Option</code> type. <a href="#fr-1-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="opaque-types-refined-vectors"><a class="header" href="#opaque-types-refined-vectors">Opaque Types: Refined Vectors</a></h1>
<pre><pre class="playground"><code class="language-rust  editable  hidden">#![allow(unused)]
extern crate flux_rs;
use flux_rs::attrs::*;

#[flux_rs::spec(fn (bool[true]))]
fn assert(b: bool) {
    if !b {
        panic!("assertion failed");
    }
}</code></pre></pre>
<p><a href="https://flux.goto.ucsd.edu/index.html#?demo=vectors.rs">Online demo</a></p>
<p>While <code>rustc</code> has a keen eye for spotting nasty bugs at
compile time, it is not omniscient. We've all groaned in
dismay at seeing deployed code crash with messages like</p>
<pre><code>panicked at 'index out of bounds: the len is ... but the index is ...'
</code></pre>
<p>Next, lets see how flux's <a href="tutorial/./01-refinements.html">refinement</a>
and <a href="tutorial/./02-ownership.html">ownership</a> mechanisms let us write
a <em>refined vector</em> API whose types track vector sizes and
ensure --- at compile time --- that vector accesses cannot
fail at runtime.</p>
<!-- SLIDE -->
<h2 id="refining-vectors-"><a class="header" href="#refining-vectors-">Refining Vectors ...</a></h2>
<p>To track sizes, lets define a <code>struct</code> that
is just a <em>wrapper</em> around the <code>std::vec::Vec</code>
type, but with a refinement index that tracks
the size of the vector.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[opaque]
#[refined_by(len: int)]
pub struct RVec&lt;T&gt; {
    inner: Vec&lt;T&gt;,
}</code></pre></pre>
<!-- SLIDE -->
<h3 id="-to-track-their-size"><a class="header" href="#-to-track-their-size">... to Track their Size</a></h3>
<p>As <a href="tutorial/./03-structs.html">with other structs</a> we're using <code>refined_by</code>
to <em>index</em> the <code>RVec</code> with an <code>int</code> value (that will represent
the vector's length.)</p>
<p>The idea is that</p>
<ul>
<li><code>RVec&lt;i32&gt;[10]</code> represents a vector of <code>i32</code> size 10, and</li>
<li><code>RVec&lt;bool&gt;{v:0 &lt; v}</code> represents a <em>non-empty</em> vector of <code>bool</code>, and</li>
<li><code>RVec&lt;RVec&lt;f32&gt;[n]&gt;[m]</code> represents a vector of vectors of <code>f32</code> of size <code>m</code> and
<em>each of</em> whose elements is a vector of size <code>n</code>.</li>
</ul>
<!-- SLIDE -->
<h3 id="-but-opaquely"><a class="header" href="#-but-opaquely">... but <em>Opaquely</em></a></h3>
<p>The <code>opaque</code> attribute tells flux that we're not
going to <em>directly</em> connect the <code>len</code> to any of
the <code>RVec</code>'s fields' values.</p>
<p>This is quite <em>unlike</em> <a href="tutorial/./03-structs.html"><code>Positivei32</code> example</a>
where the index held the actual value of the field,
or the <a href="tutorial/./04-enums.html"><code>Timer</code> example</a> where the
index held the value of the countdown.</p>
<p>Instead, with an <em>opaque</em> <code>struct</code> the idea is that the value
of the index will be tracked solely by the API for that struct.</p>
<p>Next, lets see how to build such an API for creating and
manipulating <code>RVec</code>, where the length is precisely tracked
in the index.</p>
<!-- SLIDE -->
<h3 id="creating-vectors"><a class="header" href="#creating-vectors">Creating Vectors</a></h3>
<p>I suppose one must start with nothing: the empty vector.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[trusted]
impl&lt;T&gt; RVec&lt;T&gt; {
    #[spec(fn() -&gt; RVec&lt;T&gt;[0])]
    pub fn new() -&gt; Self {
        Self { inner: Vec::new() }
    }
}</code></pre></pre>
<p>The above implements <code>RVec::new</code> as a wrapper around <code>Vec::new</code>.
The <code>#[trusted]</code> attribute tells flux to <em>not check</em> this code,
i.e. to simply <em>trust</em> that the specification is correct.
Indeed, flux <em>cannot</em> check this code.</p>
<p>If you remove the <code>#trusted</code> (do it!) then flux will
complain that you <em>cannot</em> access the <code>inner</code> field
of the opaque <code>struct</code>!</p>
<p>So the only way to use an <code>RVec</code> is to define a "trusted" API,
and then use that in client code, where for example, callers
of <code>RVec::new</code> get back an <code>RVec</code> indexed with <code>0</code> : the empty vector.</p>
<!-- SLIDE -->
<h3 id="pushing-values"><a class="header" href="#pushing-values">Pushing Values</a></h3>
<p>An empty vector is a rather desolate thing.</p>
<p>To be of any use, we need to be able to <code>push</code>
values into it, like so</p>
<pre><pre class="playground"><code class="language-rust  editable">#[trusted]
impl&lt;T&gt; RVec&lt;T&gt; {
    #[spec(fn(self: &amp;mut RVec&lt;T&gt;[@n], T) ensures self: RVec&lt;T&gt;[n+1])]
    pub fn push(&amp;mut self, item: T) {
        self.inner.push(item);
    }
}</code></pre></pre>
<p>The refined type for <code>push</code> says that it takes a <a href="tutorial/./02-ownership.html#borrowing-updatable-references"><em>updatable</em> reference</a> to an <code>RVec&lt;T&gt;</code> of size <code>n</code> and, a value <code>T</code>
and ensures that upon return, the size of <code>self</code> is increased by <code>1</code>.</p>
<h3 id="creating-a-vector-with-push"><a class="header" href="#creating-a-vector-with-push">Creating a Vector with <code>push</code></a></h3>
<p>Lets test that the types are in fact tracking sizes.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[spec(fn () -&gt; RVec&lt;i32&gt;[3])]
fn test_push() -&gt; RVec&lt;i32&gt; {
    let mut v = RVec::new(); // v: RVec&lt;i32&gt;[0]
    v.push(1);               // v: RVec&lt;i32&gt;[1]
    v.push(2);               // v: RVec&lt;i32&gt;[2]
    v.push(3);               // v: RVec&lt;i32&gt;[3]
    v
}</code></pre></pre>
<p><strong>EXERCISE</strong>: Can you correctly implement the code
for <code>zeros</code> so that it typechecks?</p>
<pre><pre class="playground"><code class="language-rust  editable">#[spec(fn(n: usize) -&gt; RVec&lt;i32&gt;[n])]
fn zeros(n:usize) -&gt; RVec&lt;i32&gt; {
    let mut v = RVec::new(); // v: RVec&lt;i32&gt;[0]
    let mut i = 0;
    while i &lt;= n {
        v.push(0);           // v: RVec&lt;i32&gt;[i]
        i += 1;
    }
    v
}</code></pre></pre>
<h3 id="popping-values"><a class="header" href="#popping-values">Popping Values</a></h3>
<p>Not much point stuffing things into a vector if we can't get them out again.
For that, we might implement a <code>pop</code> method that returns the <em>last</em> element
of the vector.</p>
<p>Aha, but what if the vector is empty? You <em>could</em> return an
<code>Option&lt;T&gt;</code> <em>or</em> since we're tracking sizes, we could
<em>require</em> that <code>pop</code> only be called with non-empty vectors.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[trusted]
impl&lt;T&gt; RVec&lt;T&gt; {
    #[spec(fn(self: &amp;mut {RVec&lt;T&gt;[@n] | 0 &lt; n}) -&gt; T
           ensures self: RVec&lt;T&gt;[n-1])]
    pub fn pop(&amp;mut self) -&gt; T {
      self.inner.pop().unwrap()
    }
}</code></pre></pre>
<p>Note that unlike <code>push</code> which works for <em>any</em> <code>RVec&lt;T&gt;[@n]</code>, the <code>pop</code>
method requires that <code>0 &lt; n</code> i.e. that the vector is <em>not</em> empty.</p>
<h3 id="using-the-pushpop-api"><a class="header" href="#using-the-pushpop-api">Using the <code>push/pop</code> API</a></h3>
<p>Now already <code>flux</code> can start checking some code, for example if you <code>push</code> two
elements, then you can <code>pop</code> twice, but flux will reject the third <code>pop</code> at
compile-time</p>
<pre><pre class="playground"><code class="language-rust  editable">fn test_push_pop() {
    let mut vec = RVec::new();   // vec: RVec&lt;i32&gt;[0]
    vec.push(10);                // vec: RVec&lt;i32&gt;[1]
    vec.push(20);                // vec: RVec&lt;i32&gt;[2]
    vec.pop();                   // vec: RVec&lt;i32&gt;[1]
    vec.pop();                   // vec: RVec&lt;i32&gt;[0]
    vec.pop();                   // rejected!
}</code></pre></pre>
<p>In fact, the error message from <code>flux</code> will point to exact condition that
does not hold</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[FLUX]: precondition might not hold
   |
24 |     v.pop();
   |     ^^^^^^^ call site
   |
   = note: a precondition cannot be proved at this call site
note: this is the condition that cannot be proved
   |
78 |     #[spec(fn(self: &amp;mut{RVec&lt;T&gt;[@n] | 0 &lt; n}) -&gt; T
   |                                        ^^^^^
<span class="boring">}</span></code></pre></pre>
<!--
We can use `push` to implement an `rvec!` macro for constructing vectors
and then test that lengths are tracked correctly

<img src="tutorial/../img/test_macro_pop.gif" width="100%"> -->
<!-- SLIDE -->
<h3 id="querying-the-size"><a class="header" href="#querying-the-size">Querying the Size</a></h3>
<p>Perhaps we should <em>peek</em> at the size of the vector
to make sure its not empty <em>before</em> we <code>pop</code> it.</p>
<p>We can do that by writing a <code>len</code> method that returns
a <code>usize</code> corresponding to (and hence, by indexed by)
the size of the input vector</p>
<pre><pre class="playground"><code class="language-rust  editable">#[flux_rs::trusted]
impl&lt;T&gt; RVec&lt;T&gt; {
    #[spec(fn(&amp;RVec&lt;T&gt;[@vec]) -&gt; usize)]
    pub fn len(&amp;self) -&gt; usize {
        self.inner.len()
    }
}</code></pre></pre>
<p><strong>EXERCISE</strong> Can you fix the <code>spec</code> for <code>len</code> so that the code below
verifies, i.e. so that flux "knows" that</p>
<ul>
<li>after two <code>push</code>es, the value returned by <code>.len()</code> is exactly <code>2</code>, and</li>
<li>after two <code>pop</code>s the size is <code>0</code> again.</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable">fn test_len() {
    let mut vec = RVec::new();
    vec.push(10);
    vec.push(20);
    assert(vec.len() == 2);
    vec.pop();
    vec.pop();
    assert(vec.len() == 0);
}</code></pre></pre>
<!-- SLIDE -->
<h2 id="random-access"><a class="header" href="#random-access">Random Access</a></h2>
<p>Of course, vectors are not just <em>stacks</em>, they also allow
<em>random</em> access to their elements which is where those
pesky panics occur, and where the refined vector API
gets rather useful.</p>
<p>Now that we're tracking sizes, we can <em>require</em>
that the method to <code>get</code> an element only be called
with a <em>valid index</em> less than the vector's size</p>
<pre><pre class="playground"><code class="language-rust  editable">impl&lt;T&gt; RVec&lt;T&gt; {
    #[spec(fn(&amp;RVec&lt;T&gt;[@n], i: usize{i &lt; n}) -&gt; &amp;T)]
    pub fn get(&amp;self, i: usize) -&gt; &amp;T {
        &amp;self.inner[i]
    }

    #[spec(fn(&amp;mut RVec&lt;T&gt;[@n], i: usize{i &lt; n}) -&gt; &amp;mut T)]
    pub fn get_mut(&amp;mut self, i: usize) -&gt; &amp;mut T {
        &amp;mut self.inner[i]
    }
}</code></pre></pre>
<!-- SLIDE -->
<h3 id="summing-the-elements-of-an-rvec"><a class="header" href="#summing-the-elements-of-an-rvec">Summing the Elements of an <code>RVec</code></a></h3>
<p><strong>EXERCISE</strong> Can you spot and fix the <em>off-by-one</em> error
in the code below which loops over the elements
of an <code>RVec</code> and sums them up? <sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup></p>
<pre><pre class="playground"><code class="language-rust  editable">fn sum_vec(vec: &amp;RVec&lt;i32&gt;) -&gt; i32 {
    let mut res = 0;
    let mut i = 0;
    while i &lt;= vec.len() {
        res += vec.get(i);
        i += 1;
    }
    res
}</code></pre></pre>
<!-- SLIDE -->
<h3 id="using-the-index-trait"><a class="header" href="#using-the-index-trait">Using the <code>Index</code> trait</a></h3>
<p>Its a bit of an eyesore to to use <code>get</code> and <code>get_mut</code> directly.</p>
<p>Instead lets implement the <code>Index</code> and <code>IndexMut</code>
traits for <code>RVec</code> which allows us to use the <code>[..]</code>
operator to access elements</p>
<pre><pre class="playground"><code class="language-rust  editable">impl&lt;T&gt; std::ops::Index&lt;usize&gt; for RVec&lt;T&gt; {
    type Output = T;
    #[spec(fn(&amp;RVec&lt;T&gt;[@n], i:usize{i &lt; n}) -&gt; &amp;T)]
    fn index(&amp;self, index: usize) -&gt; &amp;T {
        self.get(index)
    }
}

impl&lt;T&gt; std::ops::IndexMut&lt;usize&gt; for RVec&lt;T&gt; {
    #[spec(fn(&amp;mut RVec&lt;T&gt;[@n], i:usize{i &lt; n}) -&gt; &amp;mut T)]
    fn index_mut(&amp;mut self, index: usize) -&gt; &amp;mut T {
        self.get_mut(index)
    }
}</code></pre></pre>
<!-- SLIDE -->
<h3 id="summing-nicely"><a class="header" href="#summing-nicely">Summing Nicely</a></h3>
<p>Now the above <code>vec_sum</code> example looks a little nicer</p>
<pre><pre class="playground"><code class="language-rust  editable">fn sum_vec_fixed(vec: &amp;RVec&lt;i32&gt;) -&gt; i32 {
    let mut res = 0;
    let mut i = 0;
    while i &lt; vec.len() {
        res += vec[i];
        i += 1;
    }
    res
}</code></pre></pre>
<!-- SLIDE -->
<h2 id="memoization"><a class="header" href="#memoization">Memoization</a></h2>
<p>Lets put the whole API to work in this "memoized" version of the fibonacci
function which uses a vector to store the results of previous calls</p>
<pre><pre class="playground"><code class="language-rust  editable">pub fn fib(n: usize) -&gt; i32 {
    let mut r = RVec::new();
    let mut i = 0;
    while i &lt; n {
        if i == 0 {
            r.push(0);
        } else if i == 1 {
            r.push(1);
        } else {
            let a = r[i - 1];
            let b = r[i - 2];
            r.push(a + b);
        }
        i += 1;
    }
    r.pop()
}</code></pre></pre>
<p><strong>EXERCISE</strong> Flux is unhappy with the <code>pop</code> at the end of the function
which returns the <em>last</em> value as the result: it thinks the vector
<em>may be empty</em> and so the <code>pop</code> call may fail ... Can you spot and fix
the problem?</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[FLUX]: precondition might not hold
  --&gt; src/vectors.rs:40:5
   |
40 |     r.pop()
   |     ^^^^^^^
<span class="boring">}</span></code></pre></pre>
<!-- Indeed, we missed a "corner" case -- when `n` is `0` we skip the loop and
so the vector is empty! Once we add a test for that, flux is happy.

<img src="tutorial/../img/fib.gif" width="100%"> -->
<!-- SLIDE -->
<h2 id="binary-search"><a class="header" href="#binary-search">Binary Search</a></h2>
<p>As a last example, lets look at a simplified version of the
<a href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#2423-2425"><code>binary_search</code> method from <code>std::vec</code></a>, into which
we've snuck a tiny little bug</p>
<pre><pre class="playground"><code class="language-rust  editable">pub fn binary_search(vec: &amp;RVec&lt;i32&gt;, x: i32) -&gt; Result&lt;usize, usize&gt; {
    let mut size = vec.len();
    let mut left = 0;
    let mut right = size;
    while left &lt;= right {
        let mid = left + size / 2;
        let val = vec[mid];
        if val &lt; x {
            left = mid + 1;
        } else if x &lt; val {
            right = mid;
        } else {
            return Ok(mid);
        }
        size = right - left;
    }
    Err(left)
}</code></pre></pre>
<p>Flux complains in <em>two</em> places</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[FLUX]: precondition might not hold
   --&gt; src/vectors.rs:152:19
    |
152 |         let val = vec[mid];
    |                   ^^^^^^^^ call site
    |
    = note: a precondition cannot be proved at this call site
note: this is the condition that cannot be proved
   --&gt; src/rvec.rs:189:44
    |
189 |     #[spec(fn(&amp;RVec&lt;T&gt;[@n], usize{v : v &lt; n}) -&gt; &amp;T)]
    |                                       ^^^^^

error[FLUX]: arithmetic operation may overflow
   --&gt; src/vectors.rs:160:9
    |
160 |         size = right - left;
    |         ^^^^^^^^^^^^^^^^^^^
<span class="boring">}</span></code></pre></pre>
<ul>
<li>
<p>The vector access may be <em>unsafe</em> as <code>mid</code> could be out of bounds!</p>
</li>
<li>
<p>The <code>size</code> variable may <em>underflow</em> as <code>left</code> may exceed <code>right</code>!</p>
</li>
</ul>
<p><strong>EXERCISE</strong> Can you the spot off-by-one and figure out a fix?</p>
<h2 id="summary-4"><a class="header" href="#summary-4">Summary</a></h2>
<p>Well then. We just saw how Flux's index and constraint
mechanisms combine with Rust's ownership to let us write
a <em>refined vector API</em> that ensures the safety of all
accesses at compile time.</p>
<p>These mechanisms are <em>compositional</em> : we can use standard
type machinery to build up compound structures and APIs from
simple ones, as we will see when we use <code>RVec</code> to implment
<a href="tutorial/./10-case-study-sparse.html">sparse matrices</a> and a small
<a href="tutorial/./12-case-study-neural.html">neural network</a> library.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<p>Why not use an iterator? We'll get there in <a href="tutorial/./07-traits.html">due course</a>! <a href="#fr-1-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="const-generics"><a class="header" href="#const-generics">Const Generics</a></h1>
<p><a href="https://flux.goto.ucsd.edu/index.html#?demo=arrays.rs">Online demo</a></p>
<p>Rust has a built-in notion of <em>arrays</em> : collections of objects of
the same type <code>T</code> whose size is known at compile time. The fact that
the sizes are known allows them to be allocated contiguously in memory,
which makes for fast access and manipulation.</p>
<p>When I asked ChatGPT what arrays were useful for, it replied
with several nice examples, including low-level systems programming (e.g.
packets of data represented as <code>struct</code>s with array-valued fields), storing configuration data, or small sets of related values (e.g. RGB values for a pixel).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Pixel = [u8; 3]; // RGB values

let pix0: Pixel = [255,   0, 127];
let pix1: Pixel = [  0, 255, 127];
<span class="boring">}</span></code></pre></pre>
<h2 id="compile-time-safety"><a class="header" href="#compile-time-safety">Compile-time Safety...</a></h2>
<p>As the size of the array is known at compile time, Rust can make sure that
we don't <em>create</em> arrays of the wrong size, or <em>access</em> them out of bounds.</p>
<p>For example, <code>rustc</code> will grumble if you try to make a <code>Pixel</code> with 4 elements:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   |
52 | let pix2 : Pixel = [0,0,0,0];
   |            -----   ^^^^^^^^^ expected an array with a fixed size of 3 elements, found one with 4 elements
   |            |
   |            expected due to this
<span class="boring">}</span></code></pre></pre>
<p>Similarly, <code>rustc</code> will wag a finger if you try to access a <code>Pixel</code> at an invalid index.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   |
54 |  let blue0 = pix0[3];
   |              ^^^^^^^ index out of bounds: the length is 3 but the index is 3
   |
<span class="boring">}</span></code></pre></pre>
<h2 id="-run-time-panic"><a class="header" href="#-run-time-panic">... Run-time Panic!</a></h2>
<p>However, the plain type system works only upto a point. For example, consider the
following function to compute the average <code>color</code> value of a collection of <code>&amp;[Pixel]</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn average_color(pixels: &amp;[Pixel], i: usize) -&gt; u64 {
    let mut sum = 0;
    for p in pixels {
        sum += p[i] as u64;
    }
    sum / pixels.len() as u64
}
<span class="boring">}</span></code></pre></pre>
<p>Now, <code>rustc</code> will not complain about the above code, even though it may panic if
<code>color</code> is out of bounds (or of course, if the slice <code>pixels</code> is empty!).
For example, the following code</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let pixels = [ [255, 0, 0], [0, 255, 0], [0, 0, 255] ];
    let avg = average(&amp;pixels, 3);
    println!("Average: {}", avg);
}</code></pre></pre>
<p>panics at runtime:</p>
<pre><code>thread 'main' panicked ... index out of bounds: the len is 3 but the index is 3
</code></pre>
<h2 id="refined-compile-time-safety"><a class="header" href="#refined-compile-time-safety">Refined Compile-time Safety</a></h2>
<p>Fortunately, <code>flux</code> knows about the sizes of arrays and slices. At compile time,
<code>flux</code> warns about two possible errors in <code>average_color</code></p>
<img src="tutorial/../img/04-arrays-average-error.png" width="100%">
<ol>
<li>The index <code>i</code> may be out of bounds when accessing <code>p[i]</code> and</li>
<li>The division can panic as <code>pixels</code> may be empty (i.e. have length <code>0</code>).</li>
</ol>
<p>We can fix these errors by requiring that the input</p>
<ul>
<li><code>i</code> be a valid color index, i.e. <code>i &lt; 3</code> and</li>
<li><code>pixels</code> be non-empty, i.e. have size <code>n</code> where <code>n &gt; 0</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[spec(fn(pixels: &amp;[Pixel][@n], i:usize{i &lt; 3}) -&gt; u64 requires n &gt; 0)]
<span class="boring">}</span></code></pre></pre>
<img src="tutorial/../img/04-arrays-average-fix.gif" width="100%">
<h2 id="const-generics-1"><a class="header" href="#const-generics-1">Const Generics</a></h2>
<p>Rust also lets us write arrays that are <em>generic</em> over the size. For example,
suppose we want to take two input arrays <code>x</code> and <code>y</code> of the same size <code>N</code> and
compute their dot product. We can write</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn dot&lt;const N:usize&gt;(x: [f32;N], y: [f32;N]) -&gt; f32 {
    let mut sum = 0.0;
    for i in 0..N {
        sum += x[i] * y[i];
    }
    sum
}
<span class="boring">}</span></code></pre></pre>
<p>This is very convenient because <code>rustc</code> will prevent us from calling <code>dot</code> with
arrays of different sizes, for example we get a compile-time error</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   |
68 |     dot([1.0, 2.0], [3.0, 4.0, 5.0]);
   |     ---             ^^^^^^^^^^^^^^^ expected an array with a fixed size of 2 elements, found one with 3 elements
   |     |
   |     arguments to this function are incorrect
   |
<span class="boring">}</span></code></pre></pre>
<p>However, suppose we wanted to compute the <code>dot</code> product of just the first <code>k</code> elements</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn dot_k&lt;const N:usize&gt;(x: [f32;N], y: [f32;N], k: usize) -&gt; f32 {
    let mut sum = 0.0;
    for i in 0..k {
        sum += x[i] * y[i];
    }
    sum
}
<span class="boring">}</span></code></pre></pre>
<p>Now, unfortunately, <code>rustc</code> will not prevent us from calling <code>dot_k</code> with <code>k</code> set to a value that is too large!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>thread 'main' panicked at ... index out of bounds: the len is 2 but the index is 2
<span class="boring">}</span></code></pre></pre>
<p>Yikes.</p>
<h2 id="refined-const-generics"><a class="header" href="#refined-const-generics">Refined Const Generics</a></h2>
<p>Fortunately, <code>flux</code> understands const-generics as well!</p>
<p>First off, it warns us about the fact that the accesses with the index may be out of bounds.</p>
<img src="tutorial/../img/04-arrays-dotk-error.png" width="100%">
<p>We can fix it in two ways.</p>
<ul>
<li>The <strong>permissive</strong> approach is to accept any <code>k</code> but restrict the iteration to the valid elements</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn dot_k&lt;const N:usize&gt;(x: [f32;N], y: [f32;N], k: usize) -&gt; f32 {
    let mut sum = 0.0;
    let n = if k &lt; N { k } else { N };
    for i in 0..n {
        sum += x[i] * y[i];
    }
    sum
}
<span class="boring">}</span></code></pre></pre>
<img src="tutorial/../img/04-arrays-dotk-permissive.gif" width="100%">
<ul>
<li>The <strong>strict</strong> approach is to require that <code>k</code> be less than or equal to <code>N</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[spec(fn(x: [f32;N], y: [f32;N], k:usize{k &lt;= N}) -&gt; f32)]
fn dot_k&lt;const N:usize&gt;(x: [f32;N], y: [f32;N], k: usize) -&gt; f32 {
    let mut sum = 0.0;
    for i in 0..k {
        sum += x[i] * y[i];
    }
    sum
}
<span class="boring">}</span></code></pre></pre>
<img src="tutorial/../img/04-arrays-dotk-strict.gif" width="100%">
<p>Do you understand why</p>
<p>(1) Adding the type signature moved the error from the body of <code>dot_k</code> into the call-site inside <code>test</code>?
(2) Then editing <code>test</code> to call <code>dot_k</code> with <code>k=2</code> fixed the error?</p>
<h2 id="summary-5"><a class="header" href="#summary-5">Summary</a></h2>
<p>Rust's (sized) arrays are great, and <code>flux</code>'s refinements make them even better,
by ensuring indices are guaranteed to be within the arrays bounds. Const generics
let us write functions that are polymorphic over array sizes, and again, refinements
let us precisely track those sizes to prevent out-of-bounds errors!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extern-specifications"><a class="header" href="#extern-specifications">Extern Specifications</a></h1>
<pre><pre class="playground"><code class="language-rust  editable">#![feature(allocator_api)]
#![allow(unused)]
extern crate flux_rs;
use flux_rs::{attrs::*, extern_spec};
use std::alloc::{Allocator, Global};
use std::mem::swap;</code></pre></pre>
<pre><pre class="playground"><code class="language-rust  editable  hidden">#[spec(fn (bool[true]))]
fn assert(b: bool) {
    if !b {
        panic!("assertion failed");
    }
}</code></pre></pre>
<p>No man is an island.</p>
<p>Every substantial Rust code base will make use
of <em>external crates</em>. To <em>check</em> properties of
such code bases, Flux requires some way to reason
about the uses of the external crate's APIs.</p>
<p>Let's look at how Flux lets you write
<em>assumptions</em><sup class="footnote-reference" id="fr-assumption-1"><a href="#footnote-assumption">1</a></sup> about the behavior of those
libraries via <em>extern specifications</em> (abbreviated to
<em>extern-specs</em>) which can then let us check facts about
the uses of the external crate's APIs.</p>
<p>To this end, flux lets you write extern-specs for</p>
<ol>
<li>Functions,</li>
<li>Structs,</li>
<li>Enums,</li>
<li>Traits and their Impls.</li>
</ol>
<p>In this chapter, we'll look at the first three,
and then we'll see how the idea <a href="tutorial/./08-traits.html">extends to traits
and their implementations</a>.</p>
<h2 id="extern-specs-for-functions"><a class="header" href="#extern-specs-for-functions">Extern Specs for Functions</a></h2>
<p>As a first example, lets see how to write an extern spec for
the function <code>std::mem::swap</code>.</p>
<h3 id="using-extern-functions"><a class="header" href="#using-extern-functions">Using Extern Functions</a></h3>
<p>Lets write a little test that creates to references and swaps them</p>
<pre><pre class="playground"><code class="language-rust editable">pub fn test_swap() {
    let mut x = 5;
    let mut y = 10;
    std::mem::swap(&amp;mut x, &amp;mut y);
    assert(x == 10);
    assert(y == 5);
}</code></pre></pre>
<p>Now, if you push the <strong>play button</strong> you should see that Flux cannot prove
the two <code>assert</code>s. The little red squiggles indicate it does not know that
after the <code>swap</code> the values of <code>x</code> and <code>y</code> are swapped to <code>10</code> and <code>5</code>, as,
well, it has no idea about how <code>swap</code> behaves!</p>
<h3 id="writing-extern-specs"><a class="header" href="#writing-extern-specs">Writing Extern Specs</a></h3>
<p>We can fill this gap in flux's understanding by providing
an <strong>extern-spec</strong>  that gives flux a refined type
specification for <code>swap</code></p>
<pre><pre class="playground"><code class="language-rust editable">#[extern_spec]
// UNCOMMENT THIS LINE to verify `test_swap`
// #[spec(fn(x: &amp;mut T[@vx], y: &amp;mut T[@vy]) ensures x: T[vy], y: T[vx])]
fn swap&lt;T&gt;(a: &amp;mut T, b: &amp;mut T);</code></pre></pre>
<p><strong>The refined specification</strong> says that <code>swap</code> takes as input
two <em>mutable</em> references <code>x</code> and <code>y</code> that refer to values of
type <code>T</code> with respective indices <code>vx</code> and <code>vy</code>. Upon finishing,
the types referred to by <code>x</code> and <code>y</code> are "swapped".</p>
<p>Now, if you uncomment and push play, flux will verify <code>test_swap</code> as
it knows that at the call-site, <code>vx</code> and <code>vy</code> are respectively <code>5</code> and <code>10</code>.</p>
<h3 id="features-of-extern-spec-functions"><a class="header" href="#features-of-extern-spec-functions">Features of Extern Spec Functions</a></h3>
<p>Note two things about the <code>extern_spec</code> specification.</p>
<ol>
<li>First, up at the top, we had to import the <code>extern_spec</code> macro,
implemented in the <code>flux_rs</code> crate,</li>
<li>Second, importantly, we <em>do not write an implementation</em> for the function,
as that is going to be taken from <code>std::mem</code>. Instead, we're just telling
flux to use the (uncommented) type specification when checking clients.</li>
</ol>
<h3 id="getting-the-length-of-a-slice"><a class="header" href="#getting-the-length-of-a-slice">Getting the Length of a Slice</a></h3>
<p>Here is a function below that returns the <code>first</code> (well, <code>0</code>th)
element of a slice of <code>u32</code>s.</p>
<pre><pre class="playground"><code class="language-rust editable">fn first(slice: &amp;[u32]) -&gt; Option&lt;u32&gt; {
    let n = slice.len();
    if n &gt; 0 {
        Some(slice[0])
    } else {
        None
    }
}</code></pre></pre>
<p><strong>EXERCISE</strong> Unfortunately, flux does not know what <code>slice.len()</code> returns, and
so, cannot verify that the access <code>slice[0]</code> is safe! Can you help
it by <em>fixing</em> the <code>extern_spec</code> for the method shown below?
You might want to refresh your memory about the meaning of
<code>&amp;[T][@n]</code> by quickly skimming the previous chapter on the <a href="tutorial/./06-consts.html#refined-compile-time-safety">sizes of arrays
and slices</a>.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[extern_spec]
impl&lt;T&gt; [T] {
    #[spec(fn(&amp;[T][@n]) -&gt; usize)]
    fn len(v: &amp;[T]) -&gt; usize;
}</code></pre></pre>
<h2 id="extern-specs-for-enums-option"><a class="header" href="#extern-specs-for-enums-option">Extern Specs for Enums: <code>Option</code></a></h2>
<p>In the <a href="tutorial/./04-enums.html">chapter on enums</a> we saw how you can
refine <code>enum</code> types with extra indices that track extra information
about the underlying value. For example, we saw how to implement
a <a href="tutorial/./04-enums.html#a-refined-option">refined Option</a> that is indexed
by a boolean that tracks whether the value is <code>Some</code> (and hence, safe
to <code>unwrap</code>)or <code>None</code>.</p>
<p>The <code>extern_spec</code> mechanism lets us do the same thing, but directly on
<code>std::option::Option</code>. To do so we need only</p>
<ol>
<li>write extern-specs for the <strong>enum definition</strong> that add the indices
and connect them to the variant constructors,</li>
<li>write extern-specs for the <strong>method signatures</strong> that let us use the
indices to describe a refined API that is used to check client code.</li>
</ol>
<h3 id="extern-specs-for-the-type-definition"><a class="header" href="#extern-specs-for-the-type-definition">Extern Specs for the Type Definition</a></h3>
<p>First, lets add the <code>bool</code> index to the <code>Option</code> type definition.</p>
<pre><pre class="playground"><code class="language-rust editable">#[extern_spec]
#[refined_by(valid: bool)]
enum Option&lt;T&gt; {
    #[variant(Option&lt;T&gt;[{valid: false}])]
    None,
    #[variant((T) -&gt; Option&lt;T&gt;[{valid: true}])]
    Some(T),
}</code></pre></pre>
<p>As you might have noticed, this bit is <em>identical</em>
to the refined version of <code>Option</code> that we saw in
the <a href="tutorial/./04-enums.html#a-refined-option">chapter on enums</a>,
except for the <code>#[extern_spec]</code> topping.</p>
<h3 id="using-the-type-definition"><a class="header" href="#using-the-type-definition">Using the Type Definition</a></h3>
<p>Adding the above "retrofits" the <code>bool</code> index directly
into the <code>std::option::Option</code> type. So, for example
we can write</p>
<pre><pre class="playground"><code class="language-rust editable">#[spec(fn () -&gt; Option&lt;i32&gt;[{valid: true}])]
fn test_some() -&gt; Option&lt;i32&gt; {
    Some(42)
}

#[spec(fn () -&gt; Option&lt;i32&gt;[{valid: false}])]
fn test_none() -&gt; Option&lt;i32&gt; {
    None
}</code></pre></pre>
<p><strong>TIP:</strong> When there is a single field like <code>valid</code>
you can drop it, and just write <code>Option&lt;i32&gt;[true]</code>
or <code>Option&lt;i32&gt;[false]</code>.</p>
<h3 id="extern-specs-for-impl-methods"><a class="header" href="#extern-specs-for-impl-methods">Extern Specs for Impl Methods</a></h3>
<p>The extern specs become especially useful when we use them to refine
the methods that <code>impl</code>ement various key operations on <code>Option</code>s.</p>
<p>To do so, we can make an <code>extern_spec</code> <code>impl</code> for <code>Option</code>, much like
we did for slices, <a href="tutorial/07-externs.html#getting-the-length-of-a-slice">back here</a>.</p>
<pre><pre class="playground"><code class="language-rust editable">#[extern_spec]
impl&lt;T&gt; Option&lt;T&gt; {
    #[spec(fn(&amp;Option&lt;T&gt;[@b]) -&gt; bool[b])]
    const fn is_some(&amp;self) -&gt; bool;

    #[spec(fn(&amp;Option&lt;T&gt;[@b]) -&gt; bool[!b])]
    const fn is_none(&amp;self) -&gt; bool;

    #[spec(fn(Option&lt;T&gt;[true]) -&gt; T)]
    const fn unwrap(self) -&gt; T;
}</code></pre></pre>
<p>The definition looks rather like the actual one,
except that it wears the <code>#[extern_spec]</code> attribute
on top, and the methods have no definitions, as we
want to use those from the <code>extern</code> crate, in this case,
the standard library.</p>
<p>Notice that the spec for</p>
<ul>
<li><code>is_some</code> returns <code>true</code> if the input <code>Option</code> was indeed <code>valid</code>, i.e. was a <code>Some(..)</code>;</li>
<li><code>is_none</code> returns <code>true</code> if the input <code>Option</code> was <em>not</em> <code>valid</code>, i.e. was a <code>None</code>.</li>
</ul>
<h3 id="using-extern-method-specifications"><a class="header" href="#using-extern-method-specifications">Using Extern Method Specifications</a></h3>
<p>We can test these new specifications out in our client code.</p>
<pre><pre class="playground"><code class="language-rust editable">fn test_opt_specs(){
    let a = Some(42);
    assert(a.is_some());
    let b: Option&lt;i32&gt; = None;
    assert(b.is_none());
}</code></pre></pre>
<h3 id="safely-unwrapping"><a class="header" href="#safely-unwrapping">Safely Unwrapping</a></h3>
<p>Of course, we all know that we <em>shouldn't</em> directly use <code>unwrap</code>.
However, sometimes, its ok, if we somehow <em>know</em> that the value
is indeed a valid <code>Some(..)</code>. The refined type for <code>unwrap</code> keeps
us honest with a <strong>precondition</strong> that tells flux that it should
<strong>only</strong> be invoked when the underlying <code>Option</code> can be provably
<code>valid</code>.</p>
<pre><pre class="playground"><code class="language-rust editable">#[spec(fn (n:u32) -&gt; Option&lt;u8&gt;)]
fn into_u8(n: u32) -&gt; Option&lt;u8&gt; {
   if n &lt;= 255 {
       Some(n as u8)
   } else {
       None
   }
}

fn test_unwrap() -&gt; u8 {
    into_u8(42).unwrap()
}</code></pre></pre>
<p><strong>EXERCISE</strong> The function <code>test_unwrap</code> above
merrily <code>unwrap</code>s the result of the call <code>into_u8</code>.
Flux is unhappy and flags an error even though surely
the call will not panic! The trouble is that the "default"
<code>spec</code> for <code>into_u8</code> -- the Rust type -- says it can
return <em>any</em> <code>Option&lt;i32&gt;</code>, including those that might
well blow up <code>unwrap</code>. Can you fix the <code>spec</code> for <code>into_u8</code>
so that flux verifies <code>test_unwrap</code>?</p>
<h3 id="a-safe-division-function"><a class="header" href="#a-safe-division-function">A Safe Division Function</a></h3>
<p>Lets write a safe-division function, that checks if the divisor
is non-zero before doing the division.</p>
<pre><pre class="playground"><code class="language-rust editable">#[spec(fn (num: u32, denom: u32) -&gt; Option&lt;u32[num / denom]&gt;)]
pub fn safe_div(num: u32, denom: u32) -&gt; Option&lt;u32&gt; {
    if denom == 0 {
        None
    } else {
        Some(num / denom)
    }
}</code></pre></pre>
<p><strong>EXERCISE</strong> The client <code>test_safe_div</code> shown below is certainly it is safe to
divide by two! Alas, Flux thinks otherwise: it cannot determine that output of
<code>safe_div</code> may be safely <code>unwrap</code>ped. Can you figure out how to fix the specification
for <code>safe_div</code> so that the code below verifies?</p>
<pre><pre class="playground"><code class="language-rust editable">pub fn test_safe_div() {
    let res = safe_div(42, 2).unwrap();
    assert(res == 21);
}</code></pre></pre>
<h2 id="extern-specs-for-structs-vec"><a class="header" href="#extern-specs-for-structs-vec">Extern Specs for Structs: <code>Vec</code></a></h2>
<p>Previously, we saw how to define a <em>new</em> type <code>RVec&lt;T&gt;</code>
for <a href="tutorial/./05-vectors.html">refined vectors</a> and to write
an API that let us track the vector's size, and hence
check the safety of vector accesses at compile time.
Next, lets see how we can use <code>extern_spec</code> to implement
(most of) the refined API directly on structs like
<code>std::vec::Vec</code> which are defined in external crates.</p>
<h3 id="extern-specs-for-the-type-definition-1"><a class="header" href="#extern-specs-for-the-type-definition-1">Extern Specs for the Type Definition</a></h3>
<p>As with <code>enum</code>s we start by sprinkling refinement
indices on the <code>struct</code> definition. Since we want
to track sizes, lets write</p>
<pre><pre class="playground"><code class="language-rust editable">#[extern_spec]
#[refined_by(len: int)]
#[invariant(0 &lt;= len)]
struct Vec&lt;T, A: Allocator = Global&gt;;</code></pre></pre>
<h3 id="extern-invariants"><a class="header" href="#extern-invariants">Extern Invariants</a></h3>
<p>Note that we can additionally attach <strong>invariants</strong> to the <code>struct</code>
definition, which correspond to facts that are <em>always</em> true about
the indices, for example, that the <code>len</code> of a <code>Vec</code> is always non-negative.</p>
<h3 id="extern-structs-are-opaque"><a class="header" href="#extern-structs-are-opaque">Extern <code>struct</code>s are Opaque</a></h3>
<p>Unlike with <code>enum</code>, the <code>extern_spec</code> is oblivious
to the <em>internals</em> of the <code>struct</code>. That is flux
assumes that the fields are all "private", and so the
refinements must be tracked solely using the <em>methods</em>
used to construct and manipulate the <code>struct</code>.</p>
<p>The simplest of these is the one that births an <em>empty</em> <code>Vec</code></p>
<pre><pre class="playground"><code class="language-rust editable">#[extern_spec]
impl&lt;T&gt; Vec&lt;T&gt; {
    #[spec(fn() -&gt; Vec&lt;T&gt;[0])]
    fn new() -&gt; Vec&lt;T&gt;;
}</code></pre></pre>
<p>We can test this out by creating an empty vector</p>
<pre><pre class="playground"><code class="language-rust editable">#[spec(fn () -&gt; Vec&lt;i32&gt;[0])]
fn test_new() -&gt; Vec&lt;i32&gt; {
    Vec::new()
}</code></pre></pre>
<h3 id="extern-specs-for-impl-methods-1"><a class="header" href="#extern-specs-for-impl-methods-1">Extern Specs for Impl Methods</a></h3>
<p>Lets beef up our refined <code>Vec</code> API with a few more methods
like <code>push</code>, <code>pop</code>, <code>len</code> and so on.</p>
<p>We might be tempted to just bundle them together with <code>new</code>
in the <code>impl</code> above, but it is important to Flux that the
the <code>extern_spec</code> implementations <strong>mirror the original
implementations</strong> so that Flux can accurately match (i.e. "resolve")
the <code>extern_spec</code> method with the original method, and thus,
attach the specification to uses of the original method.</p>
<p>As it happens, <code>push</code> and <code>pop</code> are defined in a <em>separate</em>
<code>impl</code> block, parameterized by a generic <code>A: Allocator</code>, so
our <code>extern_spec</code> mirrors this block:</p>
<pre><pre class="playground"><code class="language-rust  editable">#[extern_spec]
impl&lt;T, A: Allocator&gt; Vec&lt;T, A&gt; {
    #[spec(fn(self: &amp;mut Vec&lt;T, A&gt;[@n], T)
           ensures self: Vec&lt;T, A&gt;[n+1])]
    fn push(&amp;mut self, value: T);

    #[spec(fn(self: &amp;mut Vec&lt;T, A&gt;[@n]) -&gt; Option&lt;T&gt;
           ensures self: Vec&lt;T, A&gt;[if n &gt; 0 { n-1 } else { 0 }])]
    fn pop(&amp;mut self) -&gt; Option&lt;T&gt;;

    #[spec(fn(self: &amp;Vec&lt;T, A&gt;[@n]) -&gt; usize[n])]
    fn len(&amp;self) -&gt; usize;

    #[spec(fn(self: &amp;Vec&lt;T, A&gt;) -&gt; bool)]
    fn is_empty(&amp;self) -&gt; bool;
}</code></pre></pre>
<h3 id="constructing-vectors"><a class="header" href="#constructing-vectors">Constructing Vectors</a></h3>
<p>Lets take the refined <code>vec</code> API out for a spin.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[spec(fn() -&gt; Vec&lt;i32&gt;[3])]
pub fn test_push() -&gt; Vec&lt;i32&gt; {
    let mut res = Vec::new();   // res: Vec&lt;i32&gt;[0]
    res.push(10);               // res: Vec&lt;i32&gt;[1]
    res.push(20);               // res: Vec&lt;i32&gt;[2]
    res.push(30);               // res: Vec&lt;i32&gt;[3]
    assert(res.len() == 3);
    res
}</code></pre></pre>
<p>Flux uses the refinements to type <code>res</code> as a 0-sized <code>Vec&lt;i32&gt;[0]</code>.
Each subsequent <code>push</code> <a href="tutorial/./02-ownership.html#borrowing-updatable-references">updates the reference's type</a>
by increasing the size by one.
Finally, the <code>len</code> returns the size at that point, <code>3</code>, thereby
proving the assert.</p>
<h3 id="testing-emptiness"><a class="header" href="#testing-emptiness">Testing Emptiness</a></h3>
<p><strong>EXERCISE</strong> Can you fix the spec for <code>is_empty</code> above so that the
two assertions below are verified?</p>
<pre><pre class="playground"><code class="language-rust  editable">fn test_is_empty() {
   let v0 = test_new();
   assert(v0.is_empty());

   let v1 = test_push();
   assert(!v1.is_empty());
}</code></pre></pre>
<h3 id="the-refined-vec-macro"><a class="header" href="#the-refined-vec-macro">The Refined <code>vec!</code> Macro</a></h3>
<p>The ubiquitous <code>vec!</code> macro internally allocates a slice
and then calls <code>into_vec</code> to create a <code>Vec</code>.</p>
<pre><pre class="playground"><code class="language-rust editable">#[extern_spec]
impl&lt;T&gt; [T] {
    #[spec(fn(self: Box&lt;[T], A&gt;) -&gt; Vec&lt;T, A&gt;)]
    fn into_vec&lt;A&gt;(self: Box&lt;[T], A&gt;) -&gt; Vec&lt;T, A&gt;
    where
        A: Allocator;
}</code></pre></pre>
<p><strong>EXERCISE</strong> Can you fix the <code>extern_spec</code> for <code>into_vec</code> so that
the code below verifies?</p>
<pre><pre class="playground"><code class="language-rust  editable">#[spec(fn() -&gt; Vec&lt;i32&gt;[3])]
pub fn test_push_macro() -&gt; Vec&lt;i32&gt; {
    let res = vec![10, 20, 30];
    assert(res.len() == 3);
    res
}</code></pre></pre>
<h3 id="pop-and-unwrap"><a class="header" href="#pop-and-unwrap">Pop-and-Unwrap</a></h3>
<p>Suppose we wanted to write a function that popped the last element
of a non-empty vector.</p>
<pre><pre class="playground"><code class="language-rust editable">#[spec(fn (vec: &amp;mut Vec&lt;T&gt;[@n]) -&gt; T
       requires 0 &lt; n
       ensures  vec: Vec&lt;T&gt;[n-1])]
fn pop_and_unwrap&lt;T&gt;(vec: &amp;mut Vec&lt;T&gt;) -&gt; T {
    vec.pop().unwrap()
}</code></pre></pre>
<p><strong>EXERCISE</strong> Flux chafes because the spec for <code>pop</code> is too <em>weak</em>:
above does not tell us <em>when</em> the returned value is safe to unwrap.
Can you go back and fix the spec for <code>fn pop</code> so that <code>pop_and_unwrap</code>
verifies?</p>
<h3 id="poppop"><a class="header" href="#poppop">PopPop!</a></h3>
<p><strong>EXERCISE</strong> Finally, as a parting exercise, can you work out
why flux rejects the <code>pop2</code> function below, and modify the spec
so that it is accepted?</p>
<pre><pre class="playground"><code class="language-rust editable">#[spec(fn (vec: &amp;mut Vec&lt;T&gt;[@n]) -&gt; (T, T)
       ensures vec: Vec&lt;T&gt;[n-2] )]
fn pop2&lt;T&gt;(vec: &amp;mut Vec&lt;T&gt;) -&gt; (T, T)  {
    let v1 = pop_and_unwrap(vec);
    let v2 = pop_and_unwrap(vec);
    (v1, v2)
}</code></pre></pre>
<h2 id="summary-6"><a class="header" href="#summary-6">Summary</a></h2>
<p>Previously, we saw how to attach refined specifications for
<a href="tutorial/./01-refinements.html">functions</a>, <a href="tutorial/03-structs.html">structs</a>
and <a href="tutorial/04-enums.html">enums</a>.</p>
<p>In this chapter, we saw that you can use the <code>extern_spec</code>
mechanism to do the same things for objects defined elsewhere,
e.g. in external crates being used by your code.</p>
<p>Next, we'll learn how to use <code>extern_spec</code> to refine <em>traits</em>
(and their implementations), which is key to checking idiomatic
Rust code.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-assumption">
<p>We say <em>assumption</em> because we're presuming that
the actual code for the library is not available to verify; if
it was, you could of course actually <em>guarantee</em> that the library
correctly implements those specifications. <a href="#fr-assumption-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="traits-and-associated-refinements"><a class="header" href="#traits-and-associated-refinements">Traits and Associated Refinements</a></h1>
<pre><pre class="playground"><code class="language-rust  editable">#![allow(unused)]
extern crate flux_rs;
extern crate flux_core;
extern crate flux_alloc;
use flux_rs::{attrs::*, extern_spec};
use std::ops::Range;</code></pre></pre>
<pre><pre class="playground"><code class="language-rust  editable  hidden">#[spec(fn (bool[true]))]
fn assert(b: bool) {
    if !b {
        panic!("assertion failed");
    }
}</code></pre></pre>
<p>One of Rust's most appealing features is its <strong>trait</strong> system which lets us decouple
<strong>descriptions</strong> of particular operations that a type should support, from their actual
<strong>implementations</strong>, to enable <em>generic</em> code that works across all implementations of
an interface.</p>
<p>Traits are ubiquitous in Rust code. For example,</p>
<ul>
<li>
<p>an <em>addition</em> <code>x + y</code> is internally represented as <code>x.add(y)</code>
where <code>x</code> and <code>y</code> can be values that implement the <code>Add</code> trait,
allowing for a uniform way to write <code>+</code> that works across
all compatible types;</p>
</li>
<li>
<p>an <em>indexing</em> operation <code>x[i]</code> is internally represented as <code>x.index(i)</code>
where <code>x</code> can be any value that implements the <code>Index</code> trait, and <code>i</code>
a compatible "key", which allows for a standard way to lookup
containers at a particular value;</p>
</li>
<li>
<p>an <em>iteration</em> <code>for x in e { ... }</code> becomes <code>while let Some(x) = e.next() { ... }</code>,
where the <code>e</code> can be any value that implements the <code>Iterator</code> trait,
allowing for an elegant and uniform way to iterate over different kinds
of ranges and collections.</p>
</li>
</ul>
<p>In this chapter, lets learn how traits pose some interesting
puzzles for formal verification, and how Flux resolves these
challenges with <strong>associated refinements</strong>.</p>
<h2 id="first-things-first"><a class="header" href="#first-things-first">First things First</a></h2>
<p>To limber up before we get to traits, lets
write a function to return (a reference to)
the first element of a slice.</p>
<pre><pre class="playground"><code class="language-rust  editable">fn get_first_slice&lt;A&gt;(container: &amp;[A]) -&gt; &amp;A
{
    &amp;container[0]
}</code></pre></pre>
<p>The method <code>get_first_slice</code> works just
fine if you call it on <em>non-empty</em> slices,
but will panic at run-time if you try it on
an empty one</p>
<pre><pre class="playground"><code class="language-rust  editable">fn test_first_slice() {
    let s0: &amp;[i32] = &amp;[10, 20, 30];
    let v0 = get_first_slice(s0);
    println!("get_first_slice {s0:?} ==&gt; {v0}");

    let s1: &amp;[char] = &amp;['a', 'b', 'c'];
    let v1 = get_first_slice(s1);
    println!("get_first_slice {s1:?} ==&gt; {v1}");

    let s2: &amp;[bool] = &amp;[];
    let v2 = get_first_slice(s2);
    println!("get_first_slice {s2:?} ==&gt; {v2}");
}</code></pre></pre>
<h3 id="catching-panics-at-compile-time"><a class="header" href="#catching-panics-at-compile-time">Catching Panics at Compile Time</a></h3>
<p>You might recall from <a href="tutorial/06-consts.html#refined-compile-time-safety">this previous chapter</a>
that Flux tracks the sizes of arrays and slices.</p>
<p>If you click the check button, you will see that flux
disapproves of <code>get_first_slice</code></p>
<pre><code>error[E0999]: assertion might fail: possible out of bounds access

   |
13 |    &amp;container[0];
   |    ^^^^^^^^^^^^
</code></pre>
<h3 id="specifying-non-empty-slices"><a class="header" href="#specifying-non-empty-slices">Specifying Non-Empty Slices</a></h3>
<p><strong>EXERCISE</strong> Can you go back and add a flux <code>spec</code> for <code>get_first_slice</code> that says that the function
should  <em>only</em> be called with <em>non-empty</em> slices? The spec should look something like the below, except
the <code>...</code> should be a constraint over <code>size</code>.</p>
<pre><code>#[spec(fn (container: &amp;[A]{size: ...}) -&gt; &amp;A)]
</code></pre>
<p>When you are done, you should see no warnings in <code>get_first_slice</code> but you will get an error in
<code>test_first_slice</code>, precisely at the location where we call it with an empty slice, which you
can fix by commenting out or removing the last call...</p>
<h2 id="a-trait-to-index-values"><a class="header" href="#a-trait-to-index-values">A Trait to <code>Index</code> Values</a></h2>
<p>Next, lets write our own little trait to index different kinds of containers<sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup>.</p>
<pre><pre class="playground"><code class="language-rust  editable">pub trait IndexV1&lt;Idx&gt; {
    type Output:?Sized;

    fn index(&amp;self, index: Idx) -&gt; &amp;Self::Output;
}</code></pre></pre>
<p>The above snippet defines a <code>trait</code> called <code>IndexV1</code> that is parameterized by <code>Idx</code>: the
type used as the actual index. To <em>implement</em> the trait, we must specify</p>
<ol>
<li>The <code>Self</code> type for the container itself (e.g. a slice, a vector, hash-map, a string, <em>etc.</em>),</li>
<li>The <code>Idx</code> type used as the index (e.g. a <code>usize</code> or <code>String</code> key, or <code>Range&lt;usize&gt;</code>, <em>etc</em>), and</li>
<li>The <code>Output</code>: an <em>associated type</em> that describes what the <code>index</code> method returns, and finally,</li>
<li>The <code>index</code> method itself, which takes a reference to <code>self</code> and an <code>index</code> of type <code>Idx</code>, and returns a reference to the <code>Output</code>.</li>
</ol>
<h3 id="a-generic-reusable-get_firstv1"><a class="header" href="#a-generic-reusable-get_firstv1">A Generic, Reusable <code>get_firstV1</code></a></h3>
<p>We can now write functions that work over <em>any</em> type that implements the <code>Index</code> trait.
For instance, we can generalize the <code>get_first_slice</code> method, which only worked on slices,
to the <code>get_firstV1</code> method will let use borrow the <code>0</code>th element of <em>any</em> <code>container</code> that
implements <code>Index&lt;usize&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust  editable">fn get_firstV1&lt;A, T&gt;(container: &amp;T) -&gt; &amp;A
where
    T: ?Sized + IndexV1&lt;usize, Output = A&gt;
{
    container.index(0)
}</code></pre></pre>
<h3 id="indexing-slices-with-usize"><a class="header" href="#indexing-slices-with-usize">Indexing Slices with <code>usize</code></a></h3>
<p>To use the <code>trait</code>, we must actually <em>implement</em> it for particular types of interest.</p>
<p>Lets implement a method to <code>index</code> a slice by a <code>usize</code> value:</p>
<pre><pre class="playground"><code class="language-rust  editable">#[trusted]
impl &lt;A&gt; IndexV1&lt;usize&gt; for [A] {

    type Output = A;

    fn index(&amp;self, index: usize) -&gt; &amp;Self::Output {
        &amp;self[index]
    }
}</code></pre></pre>
<p>The above code describes an implementation where the</p>
<ul>
<li><code>Self</code> type of the <em>container</em> is a slice <code>[A]</code>;</li>
<li><code>Idx</code> type of the <em>index</em> is <code>usize</code>;</li>
<li><code>Output</code> returned by <code>index()</code> is a (reference to) <code>A</code>; and</li>
<li><code>index()</code> is just a wrapper around the standard library's implementation.</li>
</ul>
<p>Lets ignore the <code>#[trusted]</code> for now: it just tells flux to accept this code
without protesting about <code>self[index]</code> triggering an out-of-bounds error.</p>
<h3 id="testing-get_firstv1"><a class="header" href="#testing-get_firstv1">Testing <code>get_firstV1</code></a></h3>
<p>Sweet! Now that we have a concrete implementation for <code>Index</code>
we should be able to <em>test</em> it</p>
<pre><pre class="playground"><code class="language-rust  editable">fn test_firstV1() {
    let s0: &amp;[i32] = &amp;[10, 20, 30];
    let v0 = get_firstV1(s0);
    println!("get_firstV1 {s0:?} ==&gt; {v0}");

    let s1: &amp;[char] = &amp;['a', 'b', 'c'];
    let v1 = get_firstV1(s1);
    println!("get_firstV1 {s1:?} ==&gt; {v1}");

    let s2: &amp;[bool] = &amp;[];
    let v2 = get_firstV1(s2);
    println!("get_firstV1 {s2:?} ==&gt; {v2}");
}</code></pre></pre>
<p>Click the run button. Huh?! No warnings??</p>
<p>Of course, the last one <em>will</em> panic.</p>
<p>But why didn't flux <em>warn</em> us about it, like it did with <code>test_first_slice</code>.</p>
<h3 id="yikes-get_firstv1-is-unsafe"><a class="header" href="#yikes-get_firstv1-is-unsafe">Yikes <code>get_firstV1</code> is unsafe!</a></h3>
<p>When we <em>directly</em> access a slice as in <code>get_first_slice</code>,
or <code>test_first_slice</code>, flux complains about the potential,
in this case, <em>certain</em>, out of bounds access.</p>
<p>But the <em>indirection</em> through <code>get_firstV1</code> (and <code>index</code>) has
has laundered the out of bounds access, tricking
flux into unsoundly missing the run-time error!</p>
<p>We're in a bit of a pickle.</p>
<p>The <code>Index</code> trait <em>giveth</em> the ability to write <em>generic</em>
code like <code>get_firstV1</code>, but apparently <em>taketh away</em> the
ability to <em>catch panics</em> at compile-time.</p>
<p>Surely, there is a way to use traits without giving up
on compile-time verification...</p>
<h3 id="the-challenge-how-to-specify-safe-indexing-generically"><a class="header" href="#the-challenge-how-to-specify-safe-indexing-generically">The Challenge: How to Specify <em>Safe</em> Indexing, Generically</a></h3>
<p>Clearly we <em>should not</em> call <code>get_firstV1</code> with empty slices.</p>
<p>The method <code>get_firstV1</code> wants to access the <code>0</code>-th element
of the container, and will crash at run-time if the <code>0</code>th element
does not exist, as is the case with an empty slice.</p>
<p>But the puzzle is this: how do we specify
<strong>"the <code>0</code>-th element exists"</strong> for <em>any</em>
generic <code>container</code> that implements <code>Index</code>?</p>
<h2 id="associated-refinements"><a class="header" href="#associated-refinements">Associated Refinements</a></h2>
<p>Flux's solution to this puzzle is to borrow a page from Rust's own playbook.</p>
<p>Lets revisit the definition of the <code>Index</code> trait:</p>
<pre><code class="language-rust ignore">pub trait IndexV1&lt;Idx&gt; {
    type Output:?Sized;
    fn index(&amp;self, index: Idx) -&gt; &amp;Self::Output;
}</code></pre>
<p>In the above, <code>Output</code> is an <strong>associated type</strong> for the <code>Index</code> trait that
specifies what the <code>index</code> method returns. For instance, in our implementation
of <code>Index&lt;usize&gt;</code> for slices <code>[A]</code>, the <code>Output</code> is <code>A</code>.
Inspired this idea, Flux extends traits with the ability to specify
<strong>associated refinements</strong> that can <em>describe</em> the values accepted
and returned by the trait's methods.</p>
<h3 id="valid-indexes"><a class="header" href="#valid-indexes">Valid Indexes</a></h3>
<p>Thus, we can extend the trait with an associated refinement
that specifies when an index is <code>valid</code> for a container.
Lets do so by defining the <code>Index</code> trait as:</p>
<pre><pre class="playground"><code class="language-rust  editable">#[assoc(fn valid(me: Self, index: Idx) -&gt; bool)]
pub trait Index&lt;Idx: ?Sized&gt; {
    type Output: ?Sized;

    #[spec(fn(&amp;Self[@me], idx: Idx{ Self::valid(me, idx) }) -&gt; &amp;Self::Output)]
    fn index(&amp;self, idx: Idx) -&gt; &amp;Self::Output;
}</code></pre></pre>
<p>There are <em>two</em> new things in our new version of <code>Index</code>.</p>
<p><strong>1. Declaration</strong>
First, the <code>assoc</code> attribute declares<sup class="footnote-reference" id="fr-2-1"><a href="#footnote-2">2</a></sup> the <em>associated refinement</em>:
a refinement level function named <code>valid</code>, that</p>
<ul>
<li><em>takes</em> as inputs, the <code>Self</code> type of the container and the <code>Idx</code> type of the index, and</li>
<li><em>returns</em> a <code>bool</code> which indicates if the <code>index</code> is valid for the container.</li>
</ul>
<p><strong>2. Use</strong>
Next, the <code>spec</code> attribute refines the <code>index</code> method to say that it should only be
passed an <code>idx</code> that is <em>valid</em> for the <code>me</code> container, where <code>valid</code> is the associated
refinement declared above. The notation <code>Self::valid(me, idx)</code> is a
way to refer to the <code>valid</code> associated refinement, similar to
how <code>Self::Output</code> is used to refer to the <code>Output</code> associated type.</p>
<h3 id="a-safe-and-generic-reusable-get_first"><a class="header" href="#a-safe-and-generic-reusable-get_first">A Safe (and Generic, Reusable) <code>get_first</code></a></h3>
<p>We can now write functions that work over <em>any</em> type that implements the <code>Index</code> trait,
but where flux will guarantee that <code>index</code> is safe to call. For example, lets revisit
the <code>get_first</code> method that returns the 0th element of a container.</p>
<pre><pre class="playground"><code class="language-rust  editable">// #[spec(fn (&amp;T{ container: T::valid(container, 0) }) -&gt; &amp;A)]
fn get_first&lt;A, T&gt;(container: &amp;T) -&gt; &amp;A
where T: ?Sized + Index&lt;usize, Output = A&gt;
{
    container.index(0)
}</code></pre></pre>
<p>Aha, now flux complains that the above is <em>unsafe</em> because we don't know that <code>container</code>
is <em>actually</em> <code>valid</code> for the index <code>0</code>. To make it safe, we must add (uncomment!) the
flux specification in the line above. This spec says that <code>get_first</code> can only be called
with a <code>container</code> that is <code>valid</code> for the index <code>0</code>.</p>
<h3 id="indexing-slices-with-usize-1"><a class="header" href="#indexing-slices-with-usize-1">Indexing Slices with <code>usize</code></a></h3>
<p>Lets now revisit that implementation of for slices using <code>usize</code> indexes.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[assoc(fn valid(size: int, index: int) -&gt; bool { index &lt; size })]
impl &lt;A&gt; Index&lt;usize&gt; for [A] {
    type Output = A;

    #[spec(fn(&amp;Self[@me], idx:usize{ Self::valid(me, idx) }) -&gt; &amp;Self::Output)]
    fn index(&amp;self, index: usize) -&gt; &amp;Self::Output {
        &amp;self[index]
    }
}</code></pre></pre>
<p>As with the trait definition, there are two new things in our implementation of <code>Index</code> for slices.</p>
<p><strong>1. Implementation</strong>
First, we provide a concrete implementation of the <em>associated refinement</em> <code>valid</code>.
Recall that in flux, slices <code>[A]</code> are <a href="tutorial/./06-consts.html#refined-compile-time-safety">represented by their size</a> at the refinement level.
Hence, the implementation of <code>valid</code> takes as parameters the <code>size</code>
of the slice and the <code>index</code>, and returns <code>true</code> exactly if
the <code>index</code> is less than the <code>size</code>.</p>
<p><strong>2. Use</strong>
As with the trait method, the actual implementation of the <code>index</code>
method has been refined to say that it should only be passed an
<code>idx</code> that is <em>valid</em> for <code>me</code> at the specified <code>idx</code>.<sup class="footnote-reference" id="fr-3-1"><a href="#footnote-3">3</a></sup></p>
<h3 id="testing-get_first"><a class="header" href="#testing-get_first">Testing <code>get_first</code></a></h3>
<p>Now, lets revisit our clients for <code>get_first</code> using the new <code>Index</code> trait.</p>
<pre><pre class="playground"><code class="language-rust  editable">fn test_first() {
    let s0: &amp;[i32] = &amp;[10, 20, 30];
    let v0 = get_first(s0);
    println!("get_first {s0:?} ==&gt; {v0}");

    let s1: &amp;[char] = &amp;['a', 'b', 'c'];
    let v1 = get_first(s1);
    println!("get_first {s1:?} ==&gt; {v1}");

    let s2: &amp;[bool] = &amp;[];
    let v2 = get_first(s2);
    println!("get_first {s2:?} ==&gt; {v2}");
}</code></pre></pre>
<p><em>Hooray!</em> Now, when you click the check button, flux will complain about the
last call to <code>get_first</code> because the slice <code>s2</code> is <em>not</em> <code>valid</code> for the index <code>0</code>!
To do so, flux <em>specialized</em> the specification of <code>get_first</code> (which required
<code>container</code> to be <code>valid</code> for <code>0</code>) with the actual <em>definition</em> of <code>valid</code> for
slices (which requires that <code>0 &lt; size</code>) and the actual <code>size</code> for <code>s2</code> (which is <code>0</code>).
As <code>0 &lt; 0</code> is false, flux rejects the code at compile time.</p>
<h2 id="indexing-strings-with-ranges"><a class="header" href="#indexing-strings-with-ranges">Indexing Strings with Ranges</a></h2>
<p>The whole point of the <code>Index</code> trait is be able to <code>index</code> <em>different kinds</em> of
containers. Lets see how to implement <code>Index</code> for <code>str</code> using <code>Range&lt;usize&gt;</code> indexes,
which return sub-slices of the string.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[assoc(
    fn valid(me: str, index: Range&lt;int&gt;) -&gt; bool {
        index.start &lt;= index.end &amp;&amp; index.end &lt;= str_len(me)
    }
)]
impl Index&lt;Range&lt;usize&gt;&gt; for str  {

    type Output = str;

    #[spec(fn(&amp;Self[@me], idx:Range&lt;usize&gt;{ Self::valid(me, idx) }) -&gt; &amp;Self::Output)]
    fn index(&amp;self, idx: Range&lt;usize&gt;) -&gt; &amp;Self::Output {
        &amp;self[idx.start..idx.end]
    }
}</code></pre></pre>
<p>The implementation above, implements <code>Index&lt;Range&lt;usize&gt;&gt;</code> for <code>str</code> by</p>
<ol>
<li>
<p><strong>Defining</strong> the associated refinement <code>valid</code> to say that a <code>Range</code> is valid for a string
if the <code>start</code> of the range is less than or equal to the <code>end</code>, and the <code>end</code> is
less than or equal to the length of the string (which we get using the built-in
<code>str_len</code> function);</p>
</li>
<li>
<p><strong>Refining</strong> the specification of the <code>index</code> method to say that it should only be
passed an <code>index</code> that is valid for the string <code>me</code>; and the given <code>idx</code>.</p>
</li>
</ol>
<p>Now when we run flux on clients of this implementation,
we can see that the first call is a valid sub-slice, but the
second is <em>not</em> and hence, is rejected by flux.</p>
<pre><pre class="playground"><code class="language-rust  editable">fn test_str() {
    let cat = "caterpillar";
    let sub = cat.index(0..6); // OK
    let sub = cat.index(0..19); // Error
}</code></pre></pre>
<p>Flux produces the error pinpointing the problem:</p>
<pre><code>error[E0999]: refinement type error
   |
89 |     let sub = cat.index(0..19); // Error
   |               ^^^^^^^^^^^^^^^^ a precondition cannot be proved
   |
note: this is the condition that cannot be proved
   |
74 |     index.start &lt;= index.end &amp;&amp; index.end &lt;= str_len(me)
   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<p><strong>EXERCISE</strong> Can you modify the code above so that the second call to <code>index</code>
is accepted by flux?</p>
<h2 id="indexing-vectors-with-usize"><a class="header" href="#indexing-vectors-with-usize">Indexing Vectors with <code>usize</code></a></h2>
<p><strong>EXERCISE</strong> Let's implement the <code>Index</code> trait for <code>Vec</code> using <code>usize</code> indexes.
The definition of <code>valid</code> is too permissive, can you modify it so that flux accepts
the below <code>impl</code>?</p>
<pre><pre class="playground"><code class="language-rust  editable">#[assoc(fn valid(me: Vec, index: int) -&gt; bool { true })]
impl &lt;A:Copy&gt; Index&lt;usize&gt; for Vec&lt;A&gt; {
    type Output = A;

    #[spec(fn(&amp;Self[@me], index:usize{ Self::valid(me, index) }) -&gt; &amp;Self::Output)]
    fn index(&amp;self, index: usize) -&gt; &amp;Self::Output {
        &amp;self[index]
    }
}</code></pre></pre>
<p><strong>EXERCISE</strong> Let's write a client that uses the <code>index</code> on <code>Vec</code>
to compute a dot-product for two <code>Vec&lt;f64&gt;</code>. Can you fix the <code>spec</code>
for <code>dot_vec</code> so flux accepts it?</p>
<pre><pre class="playground"><code class="language-rust  editable">#[spec(fn(xs: &amp;Vec&lt;f64&gt;, ys: &amp;Vec&lt;f64&gt;) -&gt; f64)]
fn dot_vec(xs: &amp;Vec&lt;f64&gt;, ys: &amp;Vec&lt;f64&gt;) -&gt; f64 {
    let mut res = 0.0;
    for i in 0..xs.len() {
        res += xs.index(i) * ys.index(i);
    }
    res
}</code></pre></pre>
<h2 id="indexing-vectors-with-ranges"><a class="header" href="#indexing-vectors-with-ranges">Indexing Vectors with Ranges</a></h2>
<p><strong>EXERCISE</strong> Finally, lets extract <em>sub-slices</em> from vectors using <code>Range&lt;usize&gt;</code> indexes.
Why does flux reject the below <code>impl</code>? Can you edit the code so flux accepts it?</p>
<pre><pre class="playground"><code class="language-rust  editable">#[assoc(
    fn valid(me: Vec, idx: Range&lt;int&gt;) -&gt; bool {
        true
    }
)]
impl &lt;A&gt; Index&lt;Range&lt;usize&gt;&gt; for Vec&lt;A&gt; {
    type Output = [A];

    #[spec(fn(&amp;Self[@me], idx: Range&lt;usize&gt;{ Self::valid(me, idx) }) -&gt; &amp;Self::Output)]
    fn index(&amp;self, idx: Range&lt;usize&gt;) -&gt; &amp;Self::Output {
        &amp;self[idx.start..idx.end]
    }
}</code></pre></pre>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>In this chapter, we saw how traits can be extended with <strong>associated refinements</strong>
which let us <em>declare</em> refinements on the inputs and outputs of trait methods
(e.g. <code>valid</code> indexes) that are then <em>implemented</em>  by each implementation of
the trait (e.g. the index is less than the slice size).</p>
<p>Associated refinements turn out to be an extremely useful mechanism, for example,
they let us specify properties of commonly used operations like
<a href="tutorial/spec-index">indexing</a> and <a href="tutorial/spec-iterator">iteration</a>, and more
advanced properties like the semantics of sql queries <sup class="footnote-reference" id="fr-4-1"><a href="#footnote-4">4</a></sup> and
the behavior of memory allocators <sup class="footnote-reference" id="fr-5-1"><a href="#footnote-5">5</a></sup>.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<p>The "real" ones in the standard library have a few more moving parts that would needlessly complicate our explanation of the interaction between traits and formal verification. <a href="#fr-1-1">↩</a></p>
</li>
<li id="footnote-2">
<p><code>valid</code> function is just a declaration: we do not specify an actual <em>body</em>
as those will be filled in by the implementors of the trait. We could specify a
<em>default</em> body for <code>valid</code> e.g. which always returns <code>true</code>, which can be
<em>over-ridden</em> i.e. redefined by implementations, but we must be careful
about what we choose as the default. <a href="#fr-2-1">↩</a></p>
</li>
<li id="footnote-3">
<p>By the way, it seems a little silly to <em>repeat</em> the spec for <code>index</code> doesn't it?
To be sound, Flux checks that the implementation needs to be a <a href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)">subtype of the trait method</a>.
We could for example, accept <em>more</em> inputs and produce <em>fewer</em> outputs.
But in this case, it is simply a version of the trait specification, specialized
to the particular <code>Self</code> and <code>Idx</code> types of the implementation. <a href="#fr-3-1">↩</a></p>
</li>
<li id="footnote-4">
<p>See section 6.2 of this <a href="https://ranjitjhala.github.io/static/popl25-generic-refinements.pdf">POPL 2025 paper</a> for more details. <a href="#fr-4-1">↩</a></p>
</li>
<li id="footnote-5">
<p>See this <a href="https://ranjitjhala.github.io/static/sosp25-ticktock.pdf">SOSP 2025 paper</a> for more details. <a href="#fr-5-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="simple-access-control"><a class="header" href="#simple-access-control">Simple Access Control</a></h1>
<p>Hopefully, by this point, you have a reasonable idea of the main tools
that Flux provides for refining types to capture correctness
requirements. In this, our first case study, lets see how to use those
tools to implement a very simple <em>role-based access control</em> (RBAC)
system, where Flux will check that only users with appropriate
permissions are allowed to access different resources. In doing so,
we’ll get some more practice with the tools we have already seen, and
learn about various other aspects of Flux, including how to</p>
<ol>
<li>
<p>Lift enum <em>variants</em> up into refinements,</p>
</li>
<li>
<p>Specifying <em>equality</em> using associated refinements,</p>
</li>
<li>
<p>Write <em>detached</em> specifications,</p>
</li>
<li>
<p>Define and use <em>refinement-level functions</em>.</p>
</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable  hidden">extern crate flux_core;
use flux_rs::{assert, attrs::*};</code></pre></pre>
<h2 id="reflection"><a class="header" href="#reflection">Reflection</a></h2>
<p>A bird flying high above our access-control system, or more plausibly,
an LLM attempting to summarize its code, would observe that it consists
of three main entities: <em>users</em> who want to access resources, <em>roles</em>
that are assigned to each user, and the <em>permissions</em> that may be
granted to each role.</p>
<p><strong>Roles</strong> Lets suppose that we want to track three kinds of users:
administrators, members and guests. We might represent these three roles
using a Rust <code>enum</code>:</p>
<pre><pre class="playground"><code class="language-rust  editable">#[reflect]
#[derive(Debug, Clone)]
pub enum Roles {
    Admin,
    Member,
    Guest,
}</code></pre></pre>
<p><strong>Reflection</strong> The key new bit in the definition of <code>Role</code> is the
<code>#[reflect]</code> attribute, which tells Flux that we intend to use variants
of this <code>enum</code> inside refinements. Why not just automatically <code>reflect</code>
all <code>enum</code>s? Currently, only a very restricted subset of <code>enum</code>s are
reflected: those whose variants take <em>no</em> parameters. Hence, Flux
requires us to explicitly mark such <code>enum</code>s with the <code>#[reflect]</code>
attribute. For example, we can now write a function that checks if a
given role is an <code>Admin</code> and returns <code>true</code> if so, and <code>false</code>
otherwise.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[spec(fn (&amp;Role[@r]) -&gt; bool[r == Role::Admin])]
pub fn is_admin(r: &amp;Role) -&gt; bool {
    match r {
        Role::Admin =&gt; true,
        _ =&gt; false,
    }
}</code></pre></pre>
<p><strong>EXERCISE:</strong> Complete the specification and implementation of
<code>is_guest</code> below. You cannot use <code>==</code> (yet) because, well, just try to
use it and see what happens!</p>
<pre><pre class="playground"><code class="language-rust  editable">fn is_guest(r: &amp;Role) -&gt; bool {
    true
}</code></pre></pre>
<p>When you are done, all the <code>assert</code> statements in the <code>test_role</code>
function should be verified by Flux.</p>
<pre><pre class="playground"><code class="language-rust  editable">fn test_role() {
  let admin = Role::Admin;
  let member = Role::Member;
  let guest = Role::Guest;
  assert(is_admin(&amp;admin) &amp;&amp; !is_admin(&amp;member) &amp;&amp; !is_admin(&amp;guest));
  assert(!is_guest(&amp;admin) &amp;&amp; !is_guest(&amp;member) &amp;&amp; is_guest(&amp;guest));
}</code></pre></pre>
<h2 id="defining-equality"><a class="header" href="#defining-equality">Defining Equality</a></h2>
<p>My love and appreciation of pattern-matching should not be questioned.
However, sometimes we just want an old-fashioned equality test, for
instance, to make <code>is_admin</code> and <code>is_guest</code> trivial one-liners instead
of all the ceremony of a function-call wrapped inside a <code>match</code>
statement. Despite my telling you not to use <code>==</code> above, I’m pretty
certain that you tried it anyway. Or perhaps you anticipated that you
<em>could not</em> use it because we have not yet implemented the <code>PartialEq</code>
trait for <code>Role</code> which is what Rust uses to implement <code>==</code> and <code>!=</code>
comparisons.</p>
<p><strong>A Refined PartialEq Trait</strong> The Flux standard library refines <code>std</code>‘s
<code>PartialEq</code> trait with two <em>associated refinements</em> (see
<a href="tutorial/ch09_traits">this chapter</a>.md) <code>is_eq</code> and <code>is_ne</code> that respectively specify when two
values of the type implementing <code>PartialEq</code> are equal or not. The
<em>methods</em> <code>eq</code> and <code>ne</code> return boolean values <code>v</code> such that the
predicate <code>is_eq(r1, r2, v)</code> and <code>is_ne(r1, r2, v)</code> hold. By default,
the two associated refinements are just <code>true</code>, meaning that the <code>bool</code>
result <code>v</code> is unconstrained: it can be either <code>true</code> or <code>false</code>
regardless of the inputs.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[assoc(
    fn is_eq(x: Self, y: Rhs, v: bool) -&gt; bool { true }
    fn is_ne(x: Self, y: Rhs, v: bool) -&gt; bool { true }
)]
trait PartialEq&lt;Rhs: PointeeSized = Self&gt;: PointeeSized {
    #[spec(fn(&amp;Self[@s], &amp;Rhs[@t]) -&gt; bool{v: Self::is_eq(s, t, v)})]
    fn eq(&amp;self, other: &amp;Rhs) -&gt; bool;

    #[spec(fn(&amp;Self[@s], &amp;Rhs[@t]) -&gt; bool{v: Self::is_ne(s, t, v)})]
    fn ne(&amp;self, other: &amp;Rhs) -&gt; bool;
}
<span class="boring">}</span></code></pre></pre>
<p><strong>A Refined PartialEq Implementation</strong> However, for particular
implementations of <code>PartialEq</code>, <em>e.g.</em> for <code>Role</code>, we can define the
associated refinements to capture exactly when two values are equal or
not.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[assoc(
    fn is_eq(x: Self, y: Rhs, res: bool) -&gt; bool { res &lt;=&gt; (r1 == r2) }
    fn is_ne(x: Self, y: Rhs, res: bool) -&gt; bool { true }
)]
impl PartialEq for Role {
    #[spec(fn(&amp;Self[@r1], &amp;Self[@r2]) -&gt; bool[r1 == r2]))]
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        match (self, other) {
            (Role::Admin, Role::Admin) =&gt; true,
            (Role::User, Role::User) =&gt; true,
            (Role::Guest, Role::Guest) =&gt; true,
            _ =&gt; false,
        }
    }
}</code></pre></pre>
<p>Now that we’ve <em>implemented</em> <code>PartialEq</code>, we can now write a simple
tests to check to see if Flux can understand when two <code>Role</code>s are equal
or not.</p>
<pre><pre class="playground"><code class="language-rust  editable">fn test_role_eq() {
  let admin = Role::Admin;
  let member = Role::Member;
  assert(admin == admin);
  assert(admin != member);
  assert(member == member);
}</code></pre></pre>
<p><strong>EXERCISE:</strong> Oh no! Why does Flux fail to verify that <code>admin != member</code>
in <code>test_role_eq</code>? Can you go back and figure out what bit of the above
to edit and fix, so that all the <code>assert</code> calls in <code>test_role_eq</code> are
verified by Flux.</p>
<p><strong>Permissions</strong> Next, lets define the different kinds of permissions
that users may have to access resources. Again, we can use an <code>enum</code>
with a <code>#[reflect]</code> attribute.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[reflect]
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub enum Permissions { Read, Write, Comment, Delete, Configure }</code></pre></pre>
<p>Its rather tiresome to have to write out the full <code>PartialEq</code>
implementation, especially since we can automatically <em>derive</em> it using
Rust’s <code>#[derive(PartialEq)]</code>. However, now we are in a bit of a pickle.
When we explicitly wrote out the <code>eq</code> and <code>ne</code> methods above, we could
write an output type <code>bool[r1 == r2]</code> or <code>bool[r1 != r2]</code> respectively.
But now, we need a way to <em>retroactively</em> give Flux a specification for
the <code>eq</code> and <code>ne</code> methods. <sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup></p>
<h2 id="detached-specifications"><a class="header" href="#detached-specifications">Detached Specifications</a></h2>
<p>Normally, Flux specifications are <em>attached</em> to the function or type or
trait using a Rust attribute like <code>#[spec(...)]</code> or <code>#[reflect]</code>.
However, for situations like this, where you <em>cannot</em> modify the
original source because <em>e.g.</em> it is generated by a <code>derive</code> macro, or
perhaps because you’d rather just put the specifications elsewhere for
stylistic reasons, Flux also lets you write specifications that are
<em>detached</em> from their home in the source code. <sup class="footnote-reference" id="fr-2-1"><a href="#footnote-2">2</a></sup></p>
<pre><pre class="playground"><code class="language-rust  editable">#[specs {
  impl std::cmp::PartialEq for Permissions {
    #[reft]
    fn is_eq(p1: Permissions, p2: Permissions, v:bool) -&gt; bool {
       v &lt;=&gt; (p1 == p2)
    }
    #[reft]
    fn is_ne(p1: Permissions, p2: Permissions, v:bool) -&gt; bool {
       v &lt;=&gt; (p1 != p2)
    }
    fn eq(&amp;Self[@r1], &amp;Self[@r2]) -&gt; bool[r1 == r2];
  }
}]
const _: () = (); // just need something to attach the attribute to</code></pre></pre>
<p>The above “detached specification” says that we are providing
specifications for the <code>PartialEq</code> implementation for <code>Permissions</code>.
Flux will check these specifications against the (in this case, derived)
code, and will then let you use <code>==</code> and <code>!=</code> on <code>Permissions</code> values.</p>
<pre><pre class="playground"><code class="language-rust  editable">fn test_eq_perms() {
    let read = Permissions::Read;
    let write = Permissions::Write;
    assert(read == read);
    assert(read != write);
}</code></pre></pre>
<h2 id="refinement-level-functions"><a class="header" href="#refinement-level-functions">Refinement Level Functions</a></h2>
<p>Now, that we’ve defined <code>Role</code>s and <code>Permission</code>s, we can define a
<code>User</code> struct that has their <code>id</code> and <code>role</code>, where we use a Flux index
to track the <code>role</code> of each <code>User</code>.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[refined_by(role: Role)]
pub struct User {
    pub name: String,
    #[field(Role[role])]
    pub role: Role,
}</code></pre></pre>
<p><strong>EXERCISE:</strong> Complete the <em>specification</em> and <em>implementation</em> of the
<code>new</code> method so that the code in <code>test_user</code> verifies.</p>
<pre><pre class="playground"><code class="language-rust  editable">impl User {
    // fill in the spec
    pub fn new(name: String, role: Role) -&gt; Self {
        User { name, role  }
    }
}

fn test_user() {
    let alice = User::new("Alice".to_string(), Role::Admin);
    let bob = User::new("Bob".to_string(), Role::Guest);
    assert(alice.is_admin());
    assert(bob.is_guest());
}</code></pre></pre>
<p><strong>Policies</strong> Lets <em>restrict</em> the set of <code>Permission</code>s that a <code>User</code> can
have based on their <code>Role</code>. For instance, suppose we want a policy where</p>
<ul>
<li>
<p><code>Admin</code>s can do everything (i.e., have all <code>Permission</code>s),</p>
</li>
<li>
<p><code>Member</code>s can <code>Read</code>, <code>Write</code> and <code>Comment</code>, but not <code>Delete</code> or
<code>Configure</code>,</p>
</li>
<li>
<p><code>Guest</code>s can only <code>Read</code>.</p>
</li>
</ul>
<p>We can stipulate this policy in a <em>refinement-level function</em>
<code>permitted</code> that returns <code>true</code> exactly when a given <code>Role</code> is allowed
to have a given <code>Permission</code>.</p>
<pre><pre class="playground"><code class="language-rust  editable">defs! {
    fn permitted(r: Role, p: Permissions) -&gt; bool {
        if r == Role::Admin {
            true
        } else if r == Role::Member {
            p != Permissions::Delete &amp;&amp; p != Permissions::Configure
        } else { // Guest
            p == Permissions::Read
        }
    }
}</code></pre></pre>
<p><strong>Enforcement</strong> And now, we can use <code>permitted</code> to specify that only
users with the appropriate <code>Role</code> are allowed to perform certain
actions.</p>
<pre><pre class="playground"><code class="language-rust  editable">impl User {
  #[spec(fn(&amp;Self[@u]) requires permitted(u.role, Permissions::Read))]
  fn read(&amp;self) { /* ... */ }
  #[spec(fn(&amp;Self[@u]) requires permitted(u.role, Permissions::Write))]
  fn write(&amp;self) { /* ... */ }
}</code></pre></pre>
<p>Flux will allow valid accesses,</p>
<pre><pre class="playground"><code class="language-rust  editable">fn test_access_ok() {
    let alice = User::new("Alice".to_string(), Role::Admin);
    alice.configure();
    alice.delete();
}</code></pre></pre>
<p>but will swiftly reject, at compile-time, accesses that violate the
policy:</p>
<pre><pre class="playground"><code class="language-rust  editable">fn test_access_bad() {
    let bob = User::new("Bob".to_string(), Role::Guest);
    bob.write();         // error!
    bob.delete();        // error!
    bob.configure();     // error!
}</code></pre></pre>
<h2 id="summary-7"><a class="header" href="#summary-7">Summary</a></h2>
<p>To recap, in this chapter we saw how to use</p>
<ul>
<li>
<p><em>Reflect</em> <code>enum</code>s, <em>e.g.</em> to refer to variants like <code>Role::User</code> in
refinements,</p>
</li>
<li>
<p><em>Detached</em> specifications for (derived) code <em>e.g.</em> <code>PartialEq</code>
implementations,</p>
</li>
<li>
<p><em>Refinement-level functions</em> to specify contracts, <em>e.g.</em> policies on
Roles,</p>
</li>
</ul>
<p>which together, let us implement a simple role-based access control
system where Flux verifies that <code>User</code>s only access resources compatible
with their <code>Role</code>. Next, in <a href="tutorial/ch12_sets,.html">this chapter</a> we will see how to extend
our system with <em>set-valued</em> refinements that will allow for more
expressive access control.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<p>From <a href="tutorial/ch08_externs.html">this chapter</a> you may recall the notion of <em>extern
specifications</em>; sadly we cannot quite use those because they are
for things defined outside the current crate. <a href="#fr-1-1">↩</a></p>
</li>
<li id="footnote-2">
<p>Yes indeed, the code below is a <em>lot</em> of boilerplate, that is best
generated by a macro, as we will see shortly, in <a href="tutorial/ch12_sets.html">this chapter</a>. <a href="#fr-2-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-access-control"><a class="header" href="#dynamic-access-control">Dynamic Access Control</a></h1>
<pre><pre class="playground"><code class="language-rust  editable  hidden">extern crate flux_core;
use flux_rs::{assert, attrs::*};
use std::hash::Hash;

defs!{
    fn set_emp&lt;T&gt;() -&gt; Set&lt;T&gt; {
        set_empty(0)
    }

    fn set_add&lt;T&gt;(x: T, s: Set&lt;T&gt;) -&gt; Set&lt;T&gt; {
        set_union(set_singleton(x), s)
    }

    fn set_del&lt;T&gt;(x:T, s: Set&lt;T&gt;) -&gt; Set&lt;T&gt; {
        set_difference(s, set_singleton(x))
    }

    fn set_is_disjoint&lt;T&gt;(s1: Set&lt;T&gt;, s2: Set&lt;T&gt;) -&gt; bool {
        set_intersection(s1, s2) == set_emp()
    }
}</code></pre></pre>
<p>Previously, in <a href="tutorial/ch11_equality,.html">this chapter</a> we saw how to write a simple
role-based access control system, where each <code>Role</code> has a <em>fixed</em> set of
<code>Permissions</code> associated with it, and each <code>User</code> can only access the
resources that their <code>Role</code> allows. Next, lets see how to generalize
that to build a <em>dynamic</em> access control mechanism, where permissions
can be <em>added</em> or <em>removed</em> from users at runtime, while still ensuring
that they can only access resources allowed by their <code>Role</code>. To do so we
will use <em>set-valued</em> refinements to track the set of permissions that
each user currently has.</p>
<h2 id="roles--permissions"><a class="header" href="#roles--permissions">Roles &amp; Permissions</a></h2>
<p>Lets begin by recalling the whole business of roles and permissions.</p>
<p><strong>Roles</strong> As before, we have three kinds of users: admins, members and
guests. This time, we will <em>derive</em> <code>PartialEq</code> and then use the
<code>flux_core::eq!</code> macro to generate the boilerplate detached
specifications needed to compare two <code>Role</code>s (described in
<a href="tutorial/ch11_equality.html#detached">this chapter</a>).</p>
<pre><pre class="playground"><code class="language-rust  editable">#[reflect]
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Role {
    Admin,
    Member,
    Guest,
}
flux_core::eq!(Role);
use Role::*;</code></pre></pre>
<p><strong>Permissions</strong> Next, lets define the different kinds of permissions
that users may have to access resources, using <code>#[reflect]</code> to let us
talk about <code>Permissions</code> in refinements, and the <code>eq!</code> macro to let us
compare them.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[reflect]
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub enum Permissions {
    Read,
    Write,
    Comment,
    Delete,
    Configure,
}
flux_core::eq!(Permissions);
use Permissions::*;</code></pre></pre>
<h2 id="set-valued-refinements"><a class="header" href="#set-valued-refinements">Set-Valued Refinements</a></h2>
<p>Instead of statically hardwiring a <code>User</code>‘s permissions to their <code>Role</code>,
our dynamic access control system will let us <em>add</em> or <em>remove</em>
permissions from a user at runtime. However, we will want to still
enforce important correctness requirements at compile time, and hence,
require a way to track the <em>set of permissions</em> a user has at any given
point.</p>
<p><strong>Refined Sets</strong> To do so, we can use a <em>refined Set</em> library provided
by the <code>flux-rs</code> crate, which like the refined-vectors (described in
<a href="tutorial/ch06_vectors">this chapter</a>.md) are just a wrapper around Rust’s standard <code>HashSet</code>
but where we track the actual <em>elements</em> in the set via a <em>set-valued</em>
refinement index <code>elems</code> whose sort is <code>Set&lt;T&gt;</code>, where <code>T</code> is the type
of elements in the set. That is, just like we were tracking the
<code>int</code>-valued vector <em>size</em> in <a href="tutorial/ch06_vectors,.html">this chapter</a> here we’re tracking the
<code>Set&lt;T&gt;</code>-valued <em>elems</em>.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[opaque]
#[refined_by(elems: Set&lt;T&gt;)]
#[derive(Debug)]
pub struct RSet&lt;T&gt; {
    pub inner: std::collections::HashSet&lt;T&gt;,
}</code></pre></pre>
<p><strong>Creating Sets</strong> The <code>RSet</code> API has a method to create an <code>new</code> set
(which is empty), and a method to add an element to a set, which
<em>updates</em> the set refinement to include the new <code>elem</code> element, using
the refinement level <code>set_add</code> operation.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[trusted]
impl&lt;T&gt; RSet&lt;T&gt; {
  #[spec(fn() -&gt; RSet&lt;T&gt;[set_emp()])]
  pub fn new() -&gt; RSet&lt;T&gt; {
    let inner = std::collections::HashSet::new();
    RSet { inner }
  }

  #[spec(fn(self: &amp;mut RSet&lt;T&gt;[@s], elem: T)
         ensures self: RSet&lt;T&gt;[set_add(elem, s)])]
  pub fn insert(self: &amp;mut Self, elem: T)
  where
    T: Eq + Hash,
  {
    self.inner.insert(elem);
  }
}</code></pre></pre>
<p><strong>Membership</strong> Next, lets write a <code>contains</code> method to test if an
element is in an <code>RSet</code>.</p>
<pre><pre class="playground"><code class="language-rust  editable">impl&lt;T&gt; RSet&lt;T&gt; {
  #[spec(fn(set: &amp;RSet&lt;T&gt;[@s], &amp;T[@elem]) -&gt; bool[set_is_in(elem, s.elems)])]
  pub fn contains(self: &amp;Self, elem: &amp;T) -&gt; bool
  where
    T: Eq + Hash,
  {
    self.inner.contains(elem)
  }
}</code></pre></pre>
<p>We can now check that are refinement-leve tracking is working as
expected:</p>
<pre><pre class="playground"><code class="language-rust  editable">fn test_set_add() {
  let read = Permissions::Read;
  let write = Permissions::Write;
  let mut s = RSet::new();
  s.insert(read);
  assert(s.contains(&amp;read) &amp;&amp; !s.contains(&amp;write));
  s.insert(write);
  assert(s.contains(&amp;read) &amp;&amp; s.contains(&amp;write));
}</code></pre></pre>
<p><strong>An <code>rset!</code> Macro</strong> Our API has enough mojo to implement a simple
<code>rset!</code> macro that will let us create <code>RSet</code>s with a more convenient
syntax:</p>
<pre><pre class="playground"><code class="language-rust  editable">#[macro_export]
macro_rules! rset {
    () =&gt; { RSet::new() };
    ($($e:expr),+$(,)?) =&gt; {{
        let mut res = RSet::new();
        $( res.insert($e); )*
        res
    }};
}</code></pre></pre>
<p>We can kick the tires on the macro,</p>
<pre><pre class="playground"><code class="language-rust  editable">fn test_rset_macro() {
  let read = Permissions::Read;
  let write = Permissions::Write;
  let s = rset![read, write];
  assert(s.contains(&amp;read) &amp;&amp; s.contains(&amp;write));
}</code></pre></pre>
<p><strong>Union &amp; Intersection</strong> Next, it will be convenient to have operations
that compute the <code>union</code> and <code>intersection</code>, of two sets. We can
implement these using the corresponding operations on Rust’s <code>HashSet</code>:</p>
<pre><pre class="playground"><code class="language-rust  editable">#[trusted]
impl&lt;T : Eq + Hash + Clone&gt; RSet&lt;T&gt; {
  #[spec(fn(&amp;RSet&lt;T&gt;[@self], &amp;RSet&lt;T&gt;[@other]) -&gt;
         RSet&lt;T&gt;[set_intersection(self, other)])]
  pub fn intersection(&amp;self, other: &amp;RSet&lt;T&gt;) -&gt; RSet&lt;T&gt; {
    let inner = self.inner.intersection(&amp;other.inner).cloned().collect();
    RSet { inner }
  }

  #[spec(fn(&amp;RSet&lt;T&gt;[@self], &amp;RSet&lt;T&gt;[@other]) -&gt;
            RSet&lt;T&gt;[set_union(self, other)])]
  pub fn union(&amp;self, other: &amp;RSet&lt;T&gt;) -&gt; RSet&lt;T&gt; {
    let inner = self.inner.union(&amp;other.inner).cloned().collect();
    RSet { inner }
  }
}</code></pre></pre>
<p>Notice that for each method <code>union</code>, <code>intersection</code>, the output type is
indexed by the corresponding refinement-level operation on the input
sets. Lets test these out.</p>
<p><strong>EXERCISE</strong>: Fix the conditions in the <code>assert</code>s below so they verify.
You may want to split them into <em>multiple</em> asserts to determine which
ones fail.</p>
<pre><pre class="playground"><code class="language-rust  editable">fn test_union_intersection() {
  let rd = Permissions::Read;
  let wr = Permissions::Write;
  let cm = Permissions::Comment;
  // make two sets
  let s1 = rset![rd, wr];
  let s2 = rset![wr, cm];
  // check union
  let su = s1.union(&amp;s2);
  assert(!su.contains(&amp;rd) &amp;&amp; !su.contains(&amp;wr) &amp;&amp; !su.contains(&amp;cm));
  // check intersection
  let si = s1.intersection(&amp;s2);
  assert(!si.contains(&amp;rd) &amp;&amp; !si.contains(&amp;wr) &amp;&amp; !si.contains(&amp;cm));
}</code></pre></pre>
<p><strong>Subset</strong> Finally, it will be useful to check if one set is a <em>subset</em>
of another, that is, that all the elements of one set are also present
in the other.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[trusted]
impl&lt;T: Eq + Hash&gt; RSet&lt;T&gt; {
  #[spec(fn(&amp;RSet&lt;T&gt;[@self], &amp;RSet&lt;T&gt;[@other]) -&gt;
         bool[set_subset(self, other)])]
  pub fn subset(&amp;self, other: &amp;RSet&lt;T&gt;) -&gt; bool {
    self.inner.is_subset(&amp;other.inner)
  }
}</code></pre></pre>
<p>We can now test some properties of <code>union</code>, <code>intersection</code> and <code>subset</code>,
for example, that the union of two sets <em>contains</em> both sets, and the
intersection <em>is contained in</em> both sets.</p>
<pre><pre class="playground"><code class="language-rust  editable">fn test_subset(s1: &amp;RSet&lt;Permissions&gt;, s2: &amp;RSet&lt;Permissions&gt;) {
  let su = s1.union(&amp;s2);
  assert(s1.subset(&amp;su) &amp;&amp; s2.subset(&amp;su));

  let si = s1.intersection(&amp;s2);
  assert(si.subset(&amp;s1) &amp;&amp; si.subset(&amp;s2));
}</code></pre></pre>
<p><strong>EXERCISE</strong>: Correct the implementation of the <code>equals</code> method so that
it verifies. Note that the <code>==</code> operator is legal for the <code>Set&lt;T&gt;</code> sort
<em>inside refinements</em> but it cannot be used in Rust <em>code</em> as we did not
define <code>PartialEq</code> for <code>RSet&lt;T&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust  editable">impl&lt;T: Eq + Hash&gt; RSet&lt;T&gt; {
  #[spec(fn(&amp;RSet&lt;T&gt;[@self], &amp;RSet&lt;T&gt;[@other]) -&gt; bool[self == other])]
  pub fn equals(&amp;self, other: &amp;RSet&lt;T&gt;) -&gt; bool {
    true // fix this
  }
}</code></pre></pre>
<h2 id="the-set-of-permissions-of-each-role"><a class="header" href="#the-set-of-permissions-of-each-role">The Set of Permissions of Each Role</a></h2>
<p>Lets use our refined <code>RSet</code> library to build a dynamic access control
system. As before, each <code>Role</code> has a fixed set of <code>Permissions</code>
associated with it. However, this time, we will specify these as a
refinement-level function (see
<a href="tutorial/ch11_equality.html#refinement-level-functions">this chapter</a>) that maps each <code>Role</code> to
the <em>maximal</em> set of <code>Permissions</code> for that role.</p>
<pre><pre class="playground"><code class="language-rust  editable">defs! {
    fn perms(r:Role) -&gt; Set&lt;Permissions&gt; {
        if r == Role::Admin {
          set_add(Permissions::Read,
          set_add(Permissions::Write,
          set_add(Permissions::Delete,
          set_add(Permissions::Configure, set_emp()))))
        } else if r == Role::Member {
          set_add(Permissions::Read,
          set_add(Permissions::Write,
          set_add(Permissions::Comment, set_emp())))
        } else { // Role::Guest
          set_add(Permissions::Read, set_emp())
        }
    }
}</code></pre></pre>
<p><strong>A Slow Implementation</strong> The above <code>permissions</code> is a
<em>refinement-level</em> function that Flux refinements can use to <em>specify</em>
access control requirements. Fill in the method below that <em>computes</em>
the set of <code>permissions</code> valid for a <code>Role</code>.</p>
<pre><pre class="playground"><code class="language-rust  editable">impl Role {
  #[spec(fn(&amp;Self[@r]) -&gt; RSet&lt;Permissions&gt;[perms(r)])]
  pub fn permissions(&amp;self) -&gt; RSet&lt;Permissions&gt; {
    match self {
      Admin =&gt; rset!{},     // fill these in!
      Member =&gt; rset!{},    // fill these in!
      Guest =&gt; rset!{},     // fill these in!
    }
  }
}</code></pre></pre>
<p>When you are done with the above, we can use it to implement a method
that <em>checks</em> if a given <code>Permission</code> is allowed for a <code>Role</code>.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[spec(fn(&amp;Self[@r], &amp;Permissions[@p]) -&gt; bool[set_is_in(p, perms(r))])]
pub fn check_permission_slow(&amp;self, p: &amp;Permissions) -&gt; bool {
    self.permissions().contains(p)
}</code></pre></pre>
<p><strong>A Fast Implementation</strong> The <code>check_permission_slow</code> method above is
correct, in that Flux proves that it returns <code>true</code> exactly if the given
permission is allowed for the role. However, it is inefficient since we
spin up a bunch of sets and membership queries to do the check.</p>
<p><strong>EXERCISE</strong>: Complete the below implementation of an efficient (<em>and</em>
correct) check using pattern-matching and equality comparisons.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[spec(fn(&amp;Self[@r], &amp;Permissions[@p]) -&gt; bool[set_is_in(p, perms(r))])]
pub fn check_permission(&amp;self, p: &amp;Permissions) -&gt; bool {
  let admin = Role::Admin;                // use this
  let guest = Role::Guest;                // use this
  let user = Role::Member;                // use this
  match p {
    Permissions::Read =&gt; true,            // fix this
    Permissions::Write =&gt; true,           // fix this
    Permissions::Comment =&gt; true,         // fix this
    Permissions::Delete =&gt; true,          // fix this
    Permissions::Configure =&gt; true,       // fix this
  }
}</code></pre></pre>
<h2 id="users-with-dynamic-permissions"><a class="header" href="#users-with-dynamic-permissions">Users with Dynamic Permissions</a></h2>
<p>The “dynamic” part of this access control system is that we want the
ability to <em>add</em> or <em>remove</em> permissions from a user at runtime, while
still ensuring that they can only access resources allowed by their
role. To do so, we will define a <code>User</code> struct that, in addition to a
<code>role</code>, will have two fields <code>allowed</code> and <code>denied</code> that will track the
set of permissions that have been <em>added</em> or <em>removed</em> from the user at
runtime.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[derive(Debug)]
struct User {
  name: String,
  role: Role,
  allow: RSet&lt;Permissions&gt;,
  deny: RSet&lt;Permissions&gt;,
}</code></pre></pre>
<p><strong>Allowed &amp; Denied Permissions</strong> The <code>allow</code> and <code>deny</code> fields
respectively track the set of permissions that <em>have been</em> granted and
<em>should never be</em> granted to the <code>User</code>. Of course, we want these fields
to always satisfy some important invariants.</p>
<ol>
<li>
<p>The <code>allow</code>ed permissions should always be a <em>subset</em> of the
permissions associated with the user’s <code>role</code>. That is, we can only
allow permissions that are valid for the user’s role;</p>
</li>
<li>
<p>The <code>allow</code>ed permissions should never contain any permission that
has already been <code>denied</code>; that is, the <code>allow</code>ed and <code>deny</code>ed sets
should always be <em>disjoint</em>.</p>
</li>
</ol>
<p><strong>Enforcing Invariants</strong></p>
<p>Lets use the detached specification mechanism — described in
<a href="tutorial/ch11_equality.html#detached">this chapter</a> — to enforce these invariants by <em>refining</em>
the struct to track the <code>role</code> and <code>allow</code> and <code>deny</code> sets as indices
and then specifying the requirements above as <code>#[invariant]</code>s on the
refined struct.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[specs {
 #[refined_by(role:Role, allow:Set&lt;Permissions&gt;, deny:Set&lt;Permissions&gt;)]
 #[invariant(set_subset(allow, perms(role)))]
 #[invariant(set_intersection(allow, deny) == set_emp())]
 struct User {
    name: String,
    role: Role[role],
    allowed: RSet&lt;Permissions&gt;[allow],
    denied: RSet&lt;Permissions&gt;[deny],
 }
}]
const _: () = ();</code></pre></pre>
<p>The two <code>#[invariant]</code>s correspond directly to our requirements. Lets
check that Flux will only allow constructing legal <code>User</code>s that satisfy
these invariants.</p>
<p><strong>EXERCISE</strong>: Can you fix the errors that Flux finds in <code>alice</code> and
<code>bob</code>?</p>
<pre><pre class="playground"><code class="language-rust  editable">fn test_user() {
    let alice = User {
        name: "Alice".to_string(),
        role: Guest,
        allow: rset!{ Read, Write },
        deny: rset!{ },
    };
    let bob = User {
        name: "Bob".to_string(),
        role: Admin,
        allow: rset!{ Read, Write, Delete },
        deny: rset!{ Write },
    };
}</code></pre></pre>
<h2 id="dynamically-changing-permissions"><a class="header" href="#dynamically-changing-permissions">Dynamically Changing Permissions</a></h2>
<p>Next, lets write methods to create new <code>User</code>s and check their
permissions:</p>
<pre><pre class="playground"><code class="language-rust  editable">impl User {
  #[spec(fn(name: String, role: Role) -&gt;
         Self[User{role:role, allow: set_emp(), deny: set_emp()}])]
  fn new(name: String, role: Role) -&gt; Self {
      Self {
          name,
          role,
          allow: RSet::new(),
          deny: RSet::new(),
      }
  }
}</code></pre></pre>
<p><strong>Allowing Permissions</strong> A newly created <code>User</code> only has a <code>role</code> but no
<code>allow</code>ed or <code>deny</code>ed <code>Permissions</code>, which ensures the invariants hold.
Lets write a method to <em>add</em> a <code>Permission</code> to the <code>allow</code>ed set of a
<code>User</code>. Note that we must take care to ensure that the given
<code>Permission</code> is valid for the user’s <code>role</code> (to satisfy the first
invariant) and that it is not already in the <code>deny</code>ed set (to satisfy
the second invariant). Thus, we make the method return <code>true</code> if the
permission was successfully added, and <code>false</code> otherwise.</p>
<pre><pre class="playground"><code class="language-rust  editable">impl User {
  #[spec(fn(me: &amp;mut Self[@u], &amp;Permissions[@p]) -&gt; bool[allowed(u, p)]
            ensures me: Self[User{allow: add(u, p), ..u }])]
  fn allow(&amp;mut self, p: &amp;Permissions) -&gt; bool {
    if self.role.check_permission(&amp;p) &amp;&amp; !self.deny.contains(&amp;p) {
      self.allow.insert(*p);
      true
    } else {
      false
    }
  }
}</code></pre></pre>
<p>In the type above, the refinement-level function <code>allowed</code> checks if a
permission <em>can be added</em> to the <code>allow</code>ed set, and the <code>add</code> function
returns the extended permissions:</p>
<pre><pre class="playground"><code class="language-rust  editable">defs! {
  fn allowed(u: User, p: Permissions) -&gt; bool {
    set_is_in(p, perms(u.role)) &amp;&amp; !set_is_in(p, u.deny)
  }
  fn add(u: User, p: Permissions) -&gt; Set&lt;Permissions&gt; {
    if allowed(u, p) {
      set_add(p, u.allow)
    } else {
      u.allow
    }
  }
}</code></pre></pre>
<p>Notice that the type for the <code>allow</code> uses a <em>strong reference</em> described
in <a href="tutorial/ch03_ownership.html#strongly-mutable-references,">this chapter</a> to <em>conditionally
change</em> the type of the <code>User</code> when we <em>add</em> permissions.</p>
<pre><pre class="playground"><code class="language-rust  editable">fn test_allow() {
  let read = Read;
  let write = Write;
  let mut guest = User::new("guest".to_string(), Role::Guest);
  assert(guest.allow(&amp;read));           // can allow read
  assert(guest.allow.contains(&amp;read));  // read is now allowed
  assert(!guest.allow(&amp;write));         // cannot allow write
  assert(!guest.allow.contains(&amp;read)); // write is not allowed
}</code></pre></pre>
<p><strong>Denying Permissions</strong> Next, lets write a similar method to <em>deny</em> a
permission, by adding it to the <code>deny</code>ed set, (as long as it is not
already in the <code>allow</code>ed set.</p>
<pre><pre class="playground"><code class="language-rust  editable">impl User {
  #[spec(fn(me: &amp;mut Self[@u], &amp;Permissions[@p]) -&gt; bool[deny(u, p)]
            ensures me: Self[User { deny: del(u, p), ..u }])]
  fn deny(&amp;mut self, p: &amp;Permissions) -&gt; bool {
    if !self.allow.contains(p) {
      self.deny.insert(*p); true
    } else {
      false
    }
  }
}</code></pre></pre>
<p><strong>EXERCISE</strong>: Correct the definitions of the <code>deny</code> and <code>del</code>
refinement-level functions so that the implementation of the <code>deny</code>
method above verifies.</p>
<pre><pre class="playground"><code class="language-rust  editable">defs! {
  fn deny(u: User, p: Permissions) -&gt; bool {
    true // fix this
  }
  fn del(u: User, p: Permissions) -&gt; Set&lt;Permissions&gt; {
    set_emp() // fix this
  }
}</code></pre></pre>
<h2 id="access-control"><a class="header" href="#access-control">Access Control</a></h2>
<p>Finally, we can use the <code>allow</code> set to control which <code>User</code>s are allowed
to perform certain actions. Unlike in our previous system
([ch]:11_equality), that used the <code>User</code>‘s <em>fixed</em> <code>Role</code>, we can now
use the <em>dynamic</em> <code>allow</code> set to make this determination.</p>
<pre><pre class="playground"><code class="language-rust  editable">impl User {
  #[spec(fn(&amp;Self[@u]) requires set_is_in(Read, u.allow)))]
  fn read(&amp;self) { /* ... */ }

  #[spec(fn(&amp;Self[@u]) requires set_is_in(Write, u.allow)))]
  fn write(&amp;self) { /* ... */ }

  #[spec(fn(&amp;Self[@u]) requires set_is_in(Comment, u.allow)))]
  fn comment(&amp;self) { /* ... */ }

  #[spec(fn(&amp;Self[@u]) requires set_is_in(Delete, u.allow)))]
  fn delete(&amp;self) { /* ... */ }

  #[spec(fn(&amp;Self[@u]) requires set_is_in(Configure, u.allow)))]
  fn configure(&amp;self) { /* ... */ }
}</code></pre></pre>
<p>Flux checks that <code>User</code>s have the appropriate permissions to call these
methods.</p>
<pre><pre class="playground"><code class="language-rust  editable">fn test_access_ok() {
  let configure = Permissions::Configure;
  let alice = User::new("Alice".to_string(), Role::Admin);
  aliceconfigure();        // type error!
  alice.allow(&amp;configure);  // add it to the allowed set
  alice.configure();        // ok!
}</code></pre></pre>
<h2 id="summary-8"><a class="header" href="#summary-8">Summary</a></h2>
<p>In this chapter, we saw how to build a dynamic access control system, by
indexing types with <em>set-valued</em> refinements that track users”
permissions, and strong references which <em>conditionally</em> change types
when we mutate references.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dependent-typestates"><a class="header" href="#dependent-typestates">Dependent Typestates</a></h1>
<pre><pre class="playground"><code class="language-rust  editable  hidden">use std::{
  mem::replace,
  sync::atomic::{AtomicBool, Ordering}, vec,
};

use flux_rs::{
    assert, alias, constant, defs, macros::detached_spec, extern_spec, invariant, opaque, refined_by, reflect, spec, specs, trusted,
    bitvec::BV32;
};</code></pre></pre>
<p>Our next case study shows how Flux’s refinements can be used to make the
<em>typestate</em> even more expressive by connecting typestates with run-time
values to avoiding the blowup that ensues from using (only) Rust’s types
<sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup> while still providing compile-time correctness guarantees. Lets
explore this idea by building a library to manipulate GPIO pins on
embedded hardware where each <em>port</em> comprises multiple <em>pins</em> each of
which can be set to be in <code>Input</code> or <code>Output</code> mode, and must be used
according to its current mode.</p>
<h2 id="bitvectors"><a class="header" href="#bitvectors">Bitvectors</a></h2>
<p>The pins” modes will be configured and accessed via <em>bitwise</em> operations
on dedicated hardware registers. Flux lets us precisely track the
results of bitwise operations — just like we can track arithmetic
operations ([ch]:02_refinements) or set operations ([ch]:12_sets) —
with a special <code>flux_rs::bitvec::BV32</code> type that represents 32-bit
bitvectors as an <em>opaque</em> (see <a href="tutorial/ch06_vectors">this chapter</a>.md) newtype wrapper around
<code>u32</code> indexed by a <code>bitvec&lt;32&gt;</code> that tracks the bits of the underlying
<code>u32</code> <sup class="footnote-reference" id="fr-2-1"><a href="#footnote-2">2</a></sup>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[refined_by(x: bitvec&lt;32&gt;)]        // bitvector-valued index
pub struct BV32(u32);
<span class="boring">}</span></code></pre></pre>
<h3 id="creating-and-operating-on-bitvectors"><a class="header" href="#creating-and-operating-on-bitvectors">Creating and Operating on Bitvectors</a></h3>
<p>The API for <code>BV32</code> has methods to convert from and to <code>u32</code> whose refine
contracts use the <em>logical functions</em> <code>bv_int_to_bv32</code> and
<code>bv_bv32_to_int</code> to convert between the <code>int</code> index (of the <code>u32</code>) and
its <code>bitvec&lt;32&gt;</code> representation (of the <code>BV32</code>).</p>
<pre><code class="language-rs">impl BV32 {
  #[spec(fn(value: u32) -&gt; BV32[bv_int_to_bv32(value)])]
  pub fn new(value: u32) -&gt; BV32 { BV32(value) }
}
</code></pre>
<pre><code class="language-rs">impl Into&lt;u32&gt; for BV32 {
  #[spec(fn(self:BV32) -&gt; u32[bv_bv32_to_int(self)])]
  pub fn into(self) -&gt; u32 { self.0 }
}
</code></pre>
<p><strong>Bitvector Operations</strong> The <code>flux_rs::bitvec</code> library implements the
various traits like <code>BitAnd</code>, <code>BitOr</code>, <code>Not</code>, <code>Shl</code>, <code>Shr</code>, <em>etc.</em> to
enable bitwise operations on <code>BV32</code> values. For example, the
<em>left-shift</em> (<code>&lt;&lt;</code>) operation is implemented as</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Shl&lt;u32&gt; for BV32 {
  #[spec(fn(self, rhs: u32) -&gt; BV32[self &lt;&lt; bv_int_to_bv32(rhs)])]
  fn shl(self, rhs: u32) -&gt; BV32 { BV32(self.0 &lt;&lt; rhs) }
}
<span class="boring">}</span></code></pre></pre>
<p>and the bitwise or (<code>|</code>) operation is implemented as</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl BitOr for BV32 {
  #[spec(fn(self, rhs: BV32) -&gt; BV32[self | rhs])]
  fn bitor(self, rhs: BV32) -&gt; BV32 { BV32(self.0 | rhs.0) }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>EXERCISE:</strong> Lets test our operators out: can you fix the code below so
the <code>assert</code> is verified by Flux?</p>
<pre><pre class="playground"><code class="language-rust  editable">#[spec(fn () -&gt; u32[10])]
fn test_shl_or() {
  let b1 = BV32::new(1);  // 0b0001
  let b5 = BV32::new(5);  // 0b0101
  let res = b5 &lt;&lt; b1;     // 0b1010
  let res = res | b1;     // 0b1011
  res.into()
}</code></pre></pre>
<h3 id="getting-and-setting-individual-bits"><a class="header" href="#getting-and-setting-individual-bits">Getting and Setting Individual Bits</a></h3>
<p>Next, lets use the bitwise operations to write functions that <em>get</em> or
<em>set</em> a bit at a particular position in a <code>BV32</code>.</p>
<p><strong>Valid Bit Positions</strong> Lets first write an alias for valid bit
positions (<code>0</code> to <code>31</code>)</p>
<pre><pre class="playground"><code class="language-rust  editable">#[alias(type Pin = u8{n: 0 &lt;= n &amp;&amp; n &lt; 32})]
type Pin = u8;</code></pre></pre>
<p>Note that while <code>rustc</code> will allow any <code>u8</code> value to be used as a <code>Pin</code>,
Flux will complain if we try to use a value outside the valid range.</p>
<p><strong>Getting the Value of a Pin</strong> We can now write a function that <em>gets</em>
the value of a <code>BV32</code> at a given position by returning <code>true</code> if the bit
is set to <code>1</code> and <code>false</code> otherwise.</p>
<pre><pre class="playground"><code class="language-rust  editable">fn get_pin(bv: BV32, pin: Pin) -&gt; bool {
    ((bv &gt;&gt; pin) &amp; 1) == b1
}</code></pre></pre>
<p><strong>Setting the Value of a Pin</strong> Similarly, we can write a function that
takes as input a <code>bool</code> and <em>sets</em> the bit at the given position to <code>1</code>
if the <code>bool</code> is <code>true</code> and to <code>0</code> otherwise.</p>
<pre><pre class="playground"><code class="language-rust  editable">fn set_pin(bv:BV32, pin:Pin, b:bool) -&gt; BV32 {
    if b {
        bv | (BV32::new(1) &lt;&lt; pin)
    } else {
        bv &amp; !(BV32::new(1) &lt;&lt; pin)
    }
}</code></pre></pre>
<p><strong>Refinement-Level Get/Set Functions</strong> To verify code that <em>uses</em>
<code>get_pin</code> and <code>set_pin</code>, we need to specify their behavior using Flux
contracts. The most direct way to do so is to write <em>refinement
functions</em> (see <a href="tutorial/ch04_structs.html#refinement-functions">this chapter</a>) like <code>get_pin</code>,
defined below</p>
<pre><pre class="playground"><code class="language-rust  editable">defs! {
    fn get_pin(bv: bitvec&lt;32&gt;, pin: int) -&gt; bool{
        let val = (bv &gt;&gt; bv_int_to_bv32(pin)) &amp; 1;
        val == 1
    }
}</code></pre></pre>
<p>and <code>set_pin</code> which is similarly defined as shown below</p>
<pre><pre class="playground"><code class="language-rust  editable">defs! {
    fn set_pin(bv: bitvec&lt;32&gt;, pin: int, val: bool) -&gt; bitvec&lt;32&gt; {
        let index_bits = bv_int_to_bv32(pin);
        if val {
            bv | (1 &lt;&lt; index_bits)
        } else {
            bv &amp; bv_not(1 &lt;&lt; index_bits)
        }
    }
}</code></pre></pre>
<p><strong>Syntax:</strong> While we have tried to make the syntax of the <em>refinement
function</em> <code>set_pin</code> shown above <em>look like</em> the implementation of the
Rust method of the same name, they are not the same thing. Indeed,
notice we wrote <code>bv_not</code> instead of <code>!</code> in the refinement function as
<code>!</code> is reserved for boolean negation inside refinement expressions.</p>
<p><strong>Connecting Rust Methods with Refinement Functions</strong> Once we have
defined the refinement functions, we can use them to specify the output
types of the corresponding Rust functions, using detached specifications
(see <a href="tutorial/ch11_equality.html#detached">this chapter</a>).</p>
<pre><pre class="playground"><code class="language-rust  editable">detached_spec! {
  fn get_pin(bv: BV32, pin: Pin) -&gt; bool[get_pin(bv, pin)];
  fn set_pin(bv: BV32, pin: Pin, b: bool) -&gt; BV32[set_pin(bv, pin, b)];
}</code></pre></pre>
<p>We can confirm that the specifications for the above are correctly
tracking the bits via the following test:</p>
<pre><pre class="playground"><code class="language-rust  editable">fn test_get_set_pin() {
  let b5 = BV32::new(5);            // 0b0101
  flux_rs::assert(get_pin(b5, 2));  // bit 2 is set
  let b5 = set_pin(b5, 2, false);   // 0b0001
  flux_rs::assert(!get_pin(b5, 2)); // bit 2 is cleared
}</code></pre></pre>
<h2 id="gpio-ports"><a class="header" href="#gpio-ports">GPIO Ports</a></h2>
<p>Lets tuck the newly learned information about bitvectors into our
pockets and now turn to the issue at hand: developing an API for
interacting with <em>General Purpose Input/Output</em> (GPIO) <em>ports</em> in
low-level embedded microcontrollers.</p>
<p><strong>Ports and Pins</strong> GPIO ports are the conduit through which
microcontrollers “talk” to the external world, <em>e.g.</em> to read sensors
that determine key-presses or light up output LEDs. GPIO ports, are
themselves collections of <em>pins</em> that can be configured individually as
either <code>Input</code> or <code>Output</code>, and which can then be read from or written
to accordingly. The developer must take care to use each pin according
to how it’s mode was configured, as otherwise the hardware may produce
invalid data or worse, may destroy the hardware by releasing its “magic
smoke” <sup class="footnote-reference" id="fr-3-1"><a href="#footnote-3">3</a></sup>!</p>
<p><strong>Registers</strong> In common hardware platforms like the STM32, ports are
controlled via dedicated <em>memory mapped port registers</em> which control
the modes and input and output values of <em>all</em> the pins in that port,
where the i<sup>th</sup> bit in the register corresponds to the
i<sup>th</sup> pin of the port. We can model such registers in Rust as</p>
<pre><pre class="playground"><code class="language-rust  editable">#[repr(C)]
struct Registers {
  modes: BV32, // Bit 0 = pin 0 mode, bit 1 = pin 1 mode, etc.
  output: u32, // Bit 0 = pin 0 output, bit 1 = pin 1 output, etc.
  input: u32,  // Bit 0 = pin 0 input, bit 1 = pin 1 input, etc.
}</code></pre></pre>
<p>and then the GPIO port itself is a wrapper around a pointer to such
registers</p>
<pre><pre class="playground"><code class="language-rust  editable">struct Gpio(*mut Registers);</code></pre></pre>
<h2 id="tracking-modes"><a class="header" href="#tracking-modes">Tracking Modes</a></h2>
<p>If you are well-caffeinated, you may have noticed that we used the
<code>BV32</code> type for the <code>modes</code> register in <code>Registers</code> struct above, as it
will let us index the <code>struct Registers</code> with a <code>bitvec&lt;32&gt;</code> that tracks
the modes of all 32 pins in the GPIO port.</p>
<pre><pre class="playground"><code class="language-rust  editable">detached_spec! {
  #[refined_by(modes: bitvec&lt;32&gt;)]
  struct Registers {
    modes: BV32[modes],
    output: u32,
    input: u32,
  }
}</code></pre></pre>
<p>Similarly, lets refine <code>struct Gpio</code> to track the <code>modes</code> of the
<code>Registers</code> that it <em>points to</em></p>
<pre><pre class="playground"><code class="language-rust  editable">#[refined_by(modes: bitvec&lt;32&gt;)]
  #[opaque] struct Gpio;
}</code></pre></pre>
<p><strong>Private Trusted API</strong> As the actual <code>Registers</code> must be accessed
directly via <code>unsafe</code> pointer dereferences, we mark the <code>struct</code> as
<code>opaque</code> (see <a href="tutorial/ch06_vectors">this chapter</a>.md) and write a small suite of <em>private</em>
<code>trusted</code> (<em>i.e.</em> unverified) methods for the <code>unsafe</code> dereferences,
that we will then use to to build a verified <em>public</em> API for port
access.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[trusted]
impl Gpio {
    #[spec(fn(&amp;Gpio[@modes]) -&gt; &amp;Registers[modes])]
    fn get_registers(&amp;self) -&gt; &amp;Registers {
        unsafe { &amp;*self.0 }
    }

    #[spec(fn(self: &amp;mut Gpio, m: BV32) ensures self: Gpio[m])]
    fn set_modes(&amp;mut self, m: BV32) {
        unsafe { (&amp;mut *self.0).modes = m}
    }

    #[spec(fn(self:&amp;mut Gpio[@m], output:u32) ensures self: Gpio[m])]
    fn set_output(&amp;mut self, output: u32) {
        unsafe { (&amp;mut *self.0).output = output }
    }
}</code></pre></pre>
<p>The <code>get_registers</code> dereferences the pointer stashed inside the <code>Gpio</code>
to return a <code>Registers</code> that has exactly the same <code>modes</code>. Dually, the
<code>set_modes</code> updates the <code>modes</code> of the underlying <code>Registers</code> with the
given value, updating the refinement of the <code>Gpio</code> accordingly. Finally,
the <code>set_output</code> updates the <code>output</code> register pointed to by the <code>Gpio</code>
but leaves the <code>modes</code> unchanged.</p>
<p><strong>Peripherals</strong> Finally, we can bundle multiple GPIO ports into a
<code>Peripherals</code> struct that represents all the hardware peripherals of a
microcontroller.</p>
<pre><pre class="playground"><code class="language-rust  editable">struct Peripherals { gpio_a: Gpio, gpio_b: Gpio, gpio_c: Gpio }</code></pre></pre>
<p>We can then provide safe singleton access to the peripherals via a
<code>take_peripherals</code> function that maps the actual addresses of the
hardware registers to <code>Gpio</code> instances.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[trusted]
fn take_peripherals() -&gt; Option&lt;Peripherals&gt; {
  static TAKEN: AtomicBool = AtomicBool::new(false);
  if TAKEN
     .compare_exchange(false, true, Ordering::SeqCst, Ordering::SeqCst)
     .is_ok()
  { Some(Peripherals {
        gpio_a: Gpio(0x4800_0000 as *mut Registers),
        gpio_b: Gpio(0x4800_0400 as *mut Registers),
        gpio_c: Gpio(0x4800_0800 as *mut Registers),
    })
  } else { None }
}</code></pre></pre>
<h2 id="using-modes"><a class="header" href="#using-modes">Using Modes</a></h2>
<p>Next, lets use the private methods to implement a public API for GPIO
access that <em>gets</em> and <em>sets</em> a pin’s modes, and ensures it is used
according to its mode. First, lets write an <code>enum</code> to represent the
modes of a <code>Pin</code></p>
<pre><pre class="playground"><code class="language-rust  editable">#[reflect] #[derive(PartialEq, Eq)]
enum Mode { Input, Output }
flux_core::eq!(Mode);</code></pre></pre>
<p>We <em>could</em> have just used <code>bool</code> but sadly, I kept mixing up whether
<code>true</code> meant <code>Input</code> or <code>Output</code>. An <code>enum</code> rather dispels the
confusion! However it will be quite convenient to convert between <code>Mode</code>
and <code>bool</code> with two helper functions</p>
<pre><pre class="playground"><code class="language-rust  editable">impl From&lt;bool&gt; for Mode {
    #[spec(fn (b: bool) -&gt; Mode[bool_to_mode(b)])]
    fn from(b: bool) -&gt; Self {
        if b { Mode::Output } else { Mode::Input }
    }
}
impl Into&lt;bool&gt; for Mode {
    #[spec(fn (mode: Mode) -&gt; bool[mode_to_bool(mode)])]
    fn into(self) -&gt; bool {
        match self {
            Mode::Output =&gt; true,
            Mode::Input =&gt; false,
        }
    }
}</code></pre></pre>
<p>whose specifications use the refinement functions</p>
<pre><pre class="playground"><code class="language-rust  editable">defs! {
  fn bool_to_mode(b:bool) -&gt; Mode {
    if b {
        Mode::Output
    } else {
        Mode::Input
    }
  }

  fn mode_to_bool(mode: Mode) -&gt; bool {
    mode == Mode::Output
  }
}</code></pre></pre>
<p><strong>Getting the Mode</strong> Lets use the private API and the bitvector helpers
to implement a public method to get a <code>Pin</code>‘s mode, using <code>get_pin</code>
defined earlier plus the <code>Mode</code>-<code>bool</code> conversion.</p>
<pre><pre class="playground"><code class="language-rust  editable">impl Gpio {
  #[spec(fn(&amp;Gpio[@modes], pin: Pin) -&gt; Mode[get_mode(modes, pin)])]
  pub fn get_mode(&amp;self, pin: Pin) -&gt; Mode {
    Mode::from(get_pin(self.get_registers().modes, pin))
  }
}</code></pre></pre>
<p>where the specification function <code>get_mode</code> is just</p>
<pre><pre class="playground"><code class="language-rust  editable">defs! {
    fn get_mode(bv: bitvec&lt;32&gt;, index: int) -&gt; Mode {
        bool_to_mode(get_pin(bv, index))
    }
}</code></pre></pre>
<p><strong>Setting the Mode</strong> Similarly, we can implement a public method to set
a <code>Pin</code>‘s mode using <code>set_pin</code> defined earlier plus the <code>Mode</code>-<code>bool</code>
conversion.</p>
<pre><pre class="playground"><code class="language-rust  editable">impl Gpio {
  // #[spec(EXERCISE)]
  pub fn set_mode(&amp;mut self, pin: Pin, mode: Mode) {
    let regs = self.get_registers();
    self.set_modes(set_pin(regs.modes, pin, mode.into()))
  }
}</code></pre></pre>
<p><strong>EXERCISE:</strong> Write the specification for <code>set_mode</code> so Flux verifies
<code>test_get_set</code>.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[spec(fn(gpio: &amp;mut Gpio[@modes]) ensures gpio: Gpio[modes])]
fn test_get_set(gpio: &amp;mut Gpio) {
    let orig = gpio.get_mode(3);              // save original mode
    gpio.set_mode(3, Mode::Output);           // set to output
    assert(gpio.get_mode(3) == Mode::Output); // verify mode
    gpio.set_mode(3, orig);                   // restore original mode
}</code></pre></pre>
<p><strong>Input and Output Pins</strong> We want the methods that read from and write
to a <code>Pin</code> to only be invoked on pins that are configured to be in
<code>Input</code> or <code>Output</code> mode respectively. First, lets write a type <em>alias</em>
for such pins (as always, paired with a matching Rust-level alias that
can be used in Rust signatures.)</p>
<pre><pre class="playground"><code class="language-rust  editable">#[alias(type In(m:bitvec&lt;32&gt;) = Pin{v:get_mode(m, v) == Mode::Input})]
type In = Pin;

#[alias(type Out(m:bitvec&lt;32&gt;) = Pin{v:get_mode(m, v) == Mode::Output})]
type Out = Pin;</code></pre></pre>
<p><strong>Dependent Aliases</strong>: Unlike the definition of <code>Pin</code> which is simply a
<code>u8</code> between <code>0</code> and <code>32</code>, the definitions of the aliases <code>In</code> and <code>Out</code>
<em>depend on</em> the <code>bitvec&lt;32&gt;</code> index <code>m</code>. This is essential as actual
<em>mode</em> is stored in the <code>modes</code> register and not the <code>Pin</code> itself. Flux
supports such <em>dependent aliases</em> with <em>alias parameters</em> like
<code>m: bitvec&lt;32&gt;</code> that can be used in the alias body, and which must then
be supplied wherever the aliases are used in Flux specifications.</p>
<p><strong>Reading &amp; Writing Pins</strong> Finally, lets use the alias to write <code>read</code>
and <code>write</code> methods that only accept <code>In</code> and <code>Out</code> pins, respectively</p>
<pre><pre class="playground"><code class="language-rust  editable">impl Gpio {
    #[spec(fn(&amp;Gpio[@modes], pin: In(modes)) -&gt; bool)]
    pub fn read(&amp;self, pin: In) -&gt; bool {
        let regs = self.get_registers();
        get_pin(regs.input.into(), pin)
    }

    #[spec(fn(self: &amp;mut Gpio[@modes], pin: Out(modes), value: bool))]
    pub fn write(&amp;mut self, pin: Out, value: bool) {
        let output = self.get_registers().output.into();
        let new_output = set_pin(output, pin, value).into();;
        self.set_output(new_output);
    }
}</code></pre></pre>
<p>Well then, we now have a complete API to determine and configure the
modes of each pin, and read and write them according to their enabled
modes, such that that Flux can statically ensure that the “magic smoke”
stays inside!</p>
<h2 id="clients"><a class="header" href="#clients">Clients</a></h2>
<p>Lets test our API out with some example client code.</p>
<p><strong>Reading and Writing Pins</strong> Here’s an example that illustrates how we
can use our GPIO API to configure and access different pins on different
ports. First, we get mutable access to the GPIO ports via the
<code>take_peripherals</code> function. Next, we configure some pins as <code>Output</code>
and others as <code>Input</code>. Flux will use the specification for <code>set_mode</code> to
track each of the pins” modes separately (in the <code>modes</code> index for
<code>gpio_a</code> and <code>gpio_b</code>). Consequently, Flux will allow us to <code>read</code> from
the <code>Input</code> pins, and <code>write</code> to the <code>Input</code> pins. However, Flux will
prevent you from trying to <code>read</code> from or <code>write</code> to an <code>Output</code> or
<code>Input</code> pin, respectively, as you can see by uncommenting the lines at
the bottom of the function.</p>
<pre><pre class="playground"><code class="language-rust  editable">fn test_read_write() {
    // Get mutable access to GPIOA
    let mut peripherals = take_peripherals().expect("taken!");
    let gpio_a = &amp;mut peripherals.gpio_a;
    let gpio_b = &amp;mut peripherals.gpio_b;

    // Different pins, different states
    gpio_a.set_mode(0, Mode::Output); // PA0 : Out
    gpio_a.set_mode(1, Mode::Output); // PA1 : Out
    gpio_a.set_mode(5, Mode::Input);  // PA5 : In
    gpio_b.set_mode(0, Mode::Input);  // PB3 = In

    // Valid accesses
    gpio_a.write(0, true);
    gpio_a.write(1, true);
    let button_state = gpio_a.read(5);
    let timer_state = gpio_b.read(0);

    // Invalid accesses caught at compile-time
    // gpio_a.read(0);         // ERROR! Can't read from Out pin
    // gpio_a.write(5, true);  // ERROR! Can't write to In pin
}</code></pre></pre>
<p><strong>Reading Multiple Pins</strong> Your turn! Consider the function below that
takes as input <em>sequence</em> of Pins, and returns as output a vector of the
<code>bool</code> obtained from reading the sequence of <code>Pins</code>.</p>
<p><strong>EXERCISE:</strong> Write a <code>spec</code> that lets Flux verify <code>read_pins</code>.</p>
<pre><pre class="playground"><code class="language-rust  editable">fn read_pins(gpio: &amp;Gpio, pins: &amp;[Pin]) -&gt; Vec&lt;bool&gt; {
    let mut res = vec![];
    for pin in pins {
        res.push(gpio.read(*pin));
    }
    res
}</code></pre></pre>
<p><strong>Writing Multiple Pins</strong> And here is a similar function that
additionally takes as input a sequence of <code>bool</code> values to write to the
corresponding sequence of <code>Pins</code>.</p>
<p><strong>EXERCISE:</strong> Write a <code>spec</code> that lets Flux verify <code>write_pins</code>.</p>
<pre><pre class="playground"><code class="language-rust  editable">fn write_pins(gpio: &amp;mut Gpio, pins: &amp;[Pin], vals: &amp;[bool]) {
    for i in 0..pins.len() {
        gpio.write(pins[i], vals[i]);
    }
}</code></pre></pre>
<p><strong>Dynamic Mode Configuration</strong> Lets look at an example where we might
want to “force” a <code>Pin</code> to <code>Output</code> mode, optionally returning its value
if it was (previously) in <code>Input</code> mode. Flux will not let us read from a
pin until we have established that the current mode (obtained by
<code>get_mode</code>) is, in fact, <code>Input</code>. At that point, we can read the pin,
and then set it to <code>Output</code> mode.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[spec(fn(gpio: &amp;mut Gpio, pin:Pin) -&gt; Option&lt;bool&gt; ensures gpio: Gpio)]
fn detect_and_set(gpio: &amp;mut Gpio, pin: Pin) -&gt; Option&lt;bool&gt; {
    // gpio.read(pin); // ERROR can't read, don't know state!
    if let Mode::Input = gpio.get_mode(pin) {
        let val = gpio.read(pin);
        gpio.set_mode(pin, Mode::Output);
        return Some(val);
    }
    None
}</code></pre></pre>
<p><strong>Blinking a Status LED</strong> One often wants an embedded device to blink,
<em>e.g.</em> to let us know its alive and kicking. The usual maneuver is to
toggle a dedicated status LED pin inside the main loop of the
application.</p>
<p><strong>EXERCISE:</strong> Fix the spec so Flux verifies <code>blink_status_led</code>.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[spec(fn(gpio: &amp;mut { Gpio[@modes] | true}))]
fn blink_status_led(gpio: &amp;mut Gpio) {
    static mut LED_STATE: bool = true;
    let value = unsafe { LED_STATE = !LED_STATE; LED_STATE };
    gpio.write(13, value); // HINT: When is this ok to call?
}</code></pre></pre>
<p><strong>EXERCISE:</strong> Here’s the main “loop” of an embedded application that
blinks the status LED to indicate the system is alive. Can you find out
why Flux rejects the call to <code>blink_status_led</code>, and remedy mattes so
that <code>app</code> is accepted?</p>
<pre><pre class="playground"><code class="language-rust  editable">fn app() {
    let mut peripherals = take_peripherals().expect("taken!");
    let gpio_c = &amp;mut peripherals.gpio_c;
    // blink_status_led(gpio_c); // ERROR! not yet Output
    detect_and_set(gpio_c, 13); // ensure pin 13 is Output
    loop {
        // let result = process_data(read_sensors());
        // update_outputs(result);
        blink_status_led(gpio_c); // indicate system is alive
    }
}</code></pre></pre>
<h2 id="summary-9"><a class="header" href="#summary-9">Summary</a></h2>
<p>In this chapter, we learned about Flux’s support for <em>bitvector</em> valued
refinements via the <code>BV</code> type, and how to use bitvectors to track the
modes of GPIO pins, to write a verified GPIO library that ensures pins
are used per their configuration.</p>
<p>Existing embedded Rust libraries track pin modes in Rust’s using
<code>PhantomData</code> and the typestate pattern <sup class="footnote-reference" id="fr-4-1"><a href="#footnote-4">4</a></sup>. While this approach has
the advantage of working out of the box with plain <code>rustc</code>, it has two
drawbacks. First, we get a explosion in the number of types, and the
attendant duplication of methods. Second, and perhaps more
importantantly, we end up tracking the state of the <code>Pin</code> at the
type-level, when we really want to track state of the <code>modes</code> register
to avoid any shenanigans that might arise <em>concurrently</em> accessing
different pins of the same port. (The classic typestate approach would
end up having to create 2<sup>32</sup> different types to track all mode
configurations of a single port!)</p>
<p>In contrast, Flux’s refinements allow us to compactly track the entire
vector of modes via logical refinements while still providing
compile-time guarantees that each pin is used according to its
configured mode.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<p>See <a href="https://www.ecorax.net/macro-bunker-1/">https://www.ecorax.net/macro-bunker-1/</a> <a href="#fr-1-1">↩</a></p>
</li>
<li id="footnote-2">
<p>Flux also supports <code>BV8</code>, <code>BV16</code> and <code>BV64</code> types for 8-, 16- and
64-bit bitvectors, but lets focus on <code>BV32</code> for simplicity <a href="#fr-2-1">↩</a></p>
</li>
<li id="footnote-3">
<p><a href="https://en.wikipedia.org/wiki/Magic_smoke">https://en.wikipedia.org/wiki/Magic_smoke</a> <a href="#fr-3-1">↩</a></p>
</li>
<li id="footnote-4">
<p><a href="https://docs.rust-embedded.org/book/static-guarantees/state-machines.html">https://docs.rust-embedded.org/book/static-guarantees/state-machines.html</a> <a href="#fr-4-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="neural-networks"><a class="header" href="#neural-networks">Neural Networks</a></h1>
<pre><pre class="playground"><code class="language-rust  editable  hidden">use crate::rvec::{self, AsRVec as _, RVec, rvec};
use flux_rs::assert;
use flux_rs::attrs::*;
use rand::{Rng, rngs::ThreadRng};</code></pre></pre>
<p>Next, lets look at a case study that ties together many of the different
features of Flux that we have seen in the previous chapters: lets build
a small neural network library. This chapter is heavily inspired by this
blog post <sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup> and Michael Nielsen’s book on neural networks <sup class="footnote-reference" id="fr-2-1"><a href="#footnote-2">2</a></sup>.</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td></td><td></td></tr>
<tr><td><img src="tutorial/../img/neural-layer-1.png" style="width:85.0%" /></td><td><img src="tutorial/../img/neural-layer-2.png" style="width:55.0%" /></td></tr>
</tbody></table>
</div>
<p>A Neural Network Layer with 3 inputs and 4 outputs.</p>
<p><span id="fig:neural-layer"></span></p>
<h2 id="layers"><a class="header" href="#layers">Layers</a></h2>
<p>Per wikipedia, a neural network <sup class="footnote-reference" id="fr-3-1"><a href="#footnote-3">3</a></sup> “consists of connected units or
nodes called artificial <strong>neurons</strong> … Each artificial neuron receives
<strong>signals</strong> from connected neurons, then processes them and sends a
signal to other connected neurons… The <strong>output</strong> of each neuron is
computed by some non-linear <strong>(activation) function</strong> of the totality of
its <strong>inputs</strong>… The strength of the signal at each connection is
determined by a <strong>weight</strong>… Typically neurons are aggregated into
<strong>layers</strong>…”</p>
<p>Figure [fig]:neural-layer illustrates, on the left, a single neural
network layer with 3 <em>inputs</em> and 4 <em>outputs</em>. Each output neuron
receives a <em>signal</em> from each of the 3 input neurons, as shown by the
edges from the inputs to the outputs. Furthermore, as shown on the
right, each edge has a <em>weight</em>. For example, the <code>i</code><sup>th</sup>
output neuron has distinct weights <code>weight[i][0]</code> and <code>weight[i][1]</code> and
<code>weight[i][2]</code> for each of its input neurons.</p>
<p><strong>Representing Layers</strong> We can represent a layer as a <code>struct</code> with
fields for the number of inputs, outputs, weights, and biases.</p>
<pre><pre class="playground"><code class="language-rust  editable">struct Layer {
    num_inputs: usize,
    num_outputs: usize,
    weight: RVec&lt;RVec&lt;f64&gt;&gt;,
    bias: RVec&lt;f64&gt;,
    outputs: RVec&lt;f64&gt;,
}</code></pre></pre>
<p>Of course, the plain Rust definition says little about the <code>Layer</code>‘s
<em>dimensions</em>. That is it does not tell us that <code>weight</code> is a 2D vector
that stores for each of the <code>num_outputs</code>, a vector of size
<code>num_inputs</code>, and that <code>bias</code> and <code>outputs</code> are vectors of length
<code>num_outputs</code>. No matter! We <em>refine</em> the <code>Layer</code> struct with a detached
<sup class="footnote-reference" id="fr-4-1"><a href="#footnote-4">4</a></sup> specification that makes these relationships explicit.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[specs {
    #[refined_by(i: int, o: int)]
    struct Layer {
        num_inputs: usize[i],
        num_outputs: usize[o],
        weight: RVec&lt;RVec&lt;f64&gt;[i]&gt;[o],
        bias: RVec&lt;f64&gt;[o],
        outputs: RVec&lt;f64&gt;[o],
    }
}]
const _: () = ();</code></pre></pre>
<p>Lets step through the detached specification.</p>
<ul>
<li>
<p>First, we declare that the <code>Layer</code> struct is <em>refined by</em> two <code>int</code>
indexes <code>i</code> and <code>o</code>, which will represent the input and output
dimension of the <code>Layer</code>;</p>
</li>
<li>
<p>Next, we refine the <code>num_inputs</code> field as <code>usize[i]</code> and <code>num_outputs</code>
field to be of type <code>usize[o]</code>, meaning that its value is equal to the
index <code>i</code> and <code>o</code> respectively, and hence, that those fields represent
the run-time values of their respective dimensions.</p>
</li>
<li>
<p>Next, we refine the <code>weight</code> field to be a refined vector <sup class="footnote-reference" id="fr-5-1"><a href="#footnote-5">5</a></sup> of
vectors <code>RVec&lt;RVec&lt;f64&gt;[i]&gt;[o]</code> indicating that for each of the <code>o</code>
outputs, we have a vector of <code>i</code> weights, one for each input;</p>
</li>
<li>
<p>Finally, we refine the <code>bias</code> and <code>outputs</code> fields to be vectors of
length <code>o</code>, indicating a single bias and output value for each output
neuron.</p>
</li>
</ul>
<p><strong>Why Detach?</strong> We could just as easily have written the above as a
regular attached specification, using attributes on the fields of the
<code>Layer</code> struct. We chose to use the detached style here purely for
illustration, and because I personally think its somewhat easier on the
eye.</p>
<h2 id="creating-layers"><a class="header" href="#creating-layers">Creating Layers</a></h2>
<p>Next, lets write a constructor for <code>Layer</code>s.</p>
<p><strong>Initializing a Vector</strong> Since we have to build nested vectors, it will
be convenient to write a helper function that uses a closure to build a
vector of some given size.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[spec(fn(n: usize, f:F) -&gt; RVec&lt;A&gt;[n]
       where F: FnMut(usize) -&gt; A)]
fn init&lt;F, A&gt;(n: usize, mut f: F) -&gt; RVec&lt;A&gt;
where
    F: FnMut(usize) -&gt; A,
{
    let mut res = RVec::new();
    for i in 0..n {
        res.push(f(i));
    }
    res
}</code></pre></pre>
<p><strong>EXERCISE:</strong> The function below takes as input a reference to a <code>RVec</code>
and uses <code>init</code> to compute the <code>mirror</code> image of the input, <em>i.e.</em>, an
<code>RVec</code> where the elements are reversed. Can you fix the specification of
<code>init</code> so it is accepted?</p>
<pre><pre class="playground"><code class="language-rust  editable">#[spec(fn(vec: &amp;RVec&lt;T&gt;[@n]) -&gt; RVec&lt;T&gt;[n])]
fn mirror&lt;T: Clone&gt;(vec: &amp;RVec&lt;T&gt;) -&gt; RVec&lt;T&gt; {
    let n = vec.len();
    init(n, |i| vec[n-i-1].clone())
}</code></pre></pre>
<p><strong>Layer Constructor</strong> Our <code>Layer</code> constructor will use <code>init</code> to create
a randomly generated starting matrix of weights and biases that will
then get adjusted during training. Hooray for closures: we can call
<code>init</code> with an outer closure that creates each <em>output row</em> of the
weight matrix, and an inner closure that creates the <em>input</em> weights for
that row.</p>
<pre><pre class="playground"><code class="language-rust  editable">impl Layer {
  #[spec(fn(i: usize, o: usize) -&gt; Layer[i, o])]
  fn new(i: usize, o: usize) -&gt; Layer {
    let mut rng = rand::thread_rng();
    Layer {
      num_inputs: i,
      num_outputs: o,
      weight: init(i, |_| init(o, |_| rng.gen_range(-1.0..1.0))),
      bias: init(o, |_| rng.gen_range(-1.0..1.0)),
      outputs: init(o, |_| 0.0),
    }
  }
}</code></pre></pre>
<p><strong>EXERCISE:</strong> Looks like the auto-complete snuck in a bug in definition
of <code>new</code> above, which, thankfully, Flux has flagged! Can you spot and
fix the problem?</p>
<h2 id="layer-propagation"><a class="header" href="#layer-propagation">Layer Propagation</a></h2>
<p>A neural layer (and ultimately, network) is, of course, ultimately a
representation of a <em>function</em> that maps inputs to outputs, for example,
to map inputs corresponding to the pixels of an image to outputs
corresponding to the labels of objects in the image. Thus, each neural
layer must implement two key functions:</p>
<ul>
<li>
<p><code>forward</code> which <em>evaluates</em> the function by computing the values of
the outputs given the current values of the inputs, weights, and
biases; and</p>
</li>
<li>
<p><code>backward</code> which <em>propagates</em> the error (or loss) between the
evaluated output backwards by computing the gradients of the weights
and biases with respect to the loss, and then “trains” the network by
adjusting the weights and biases to minimize the loss.</p>
</li>
</ul>
<p>Next, let’s look at how we might <em>implement</em> these function using our
<code>Layer</code> datatype. We will not look at the mathematics of these functions
in any detail, to learn more, I heartily recommend chapters 2 and 3 of
Nielsen’s book <sup class="footnote-reference" id="fr-6-1"><a href="#footnote-6">6</a></sup>.</p>
<h3 id="forward-evaluation"><a class="header" href="#forward-evaluation">Forward Evaluation</a></h3>
<p>In brief, the goal of the <code>forward</code> function is to compute the value of
each output neuron <code>outputs[i]</code> as the <em>weighted sum</em> of its input
neurons <code>inputs[i]</code>, and return <code>1</code> if that sum plus its <code>bias[i]</code> — a
threshold — is above zero, and <code>0</code> otherwise.</p>
<pre><code class="language-math">\mathbf{\text{outputs}}\lbrack i\rbrack ≔ \begin{cases}
1\text{ if  }\mathbf{\text{weights}}\lbrack i\rbrack \cdot \mathbf{\text{inputs}} + \mathbf{\text{bias}}\lbrack i\rbrack &gt; 0 \\
0\text{ otherwise }
\end{cases}
</code></pre>
<p>The discrete “step” function above discontinuously leaps from <code>0</code> to <code>1</code>
at the threshold, which gets in the way of computing gradients during
backpropagation. So instead we <em>smooth</em> it out using a <em>sigmoid</em>
(logistic) function</p>
<pre><code class="language-math">\sigma(x) ≔ \frac{1}{1 + \exp( - x)}
</code></pre>
<p>which transitions gradually from <code>0</code> to <code>1</code> as shown below:</p>
<figure>
<p><img src="tutorial/../img/sigmoid.png" style="width:61.0%" /></p>
<figcaption><p>Sigmoid vs. Step Function</p></figcaption>
</figure>
<p><span id="fig:sigmoid-step"></span></p>
<p>Thus, when we put the weighted-sum and sigmoid together, we get the
following formula for computing the i<sup>th</sup> output neuron:</p>
<pre><code class="language-math">\mathbf{\text{outputs}}\lbrack i\rbrack ≔ \sigma(\mathbf{\text{weights}}\lbrack i\rbrack \cdot \mathbf{\text{inputs}} + \mathbf{\text{bias}}\lbrack i\rbrack)
</code></pre>
<p><span id="eq:neural-output"></span></p>
<p><strong>EXERCISE:</strong> Below is the implementation of a function that computes
the <code>dot_product</code> of two vectors. Can you figure out why Flux is
complaining and fix the code so it verifies?</p>
<pre><pre class="playground"><code class="language-rust  editable">fn dot_product2(a: &amp;RVec&lt;f64&gt;, b: &amp;RVec&lt;f64&gt;) -&gt; f64 {
    (0..a.len()).map(|i| (a[i] * b[i])).sum()
}</code></pre></pre>
<p>We can now use the implementation of <code>dot_product</code> to transcribe the
equation above math into our Rust implementation of <code>forward</code></p>
<pre><pre class="playground"><code class="language-rust  editable">impl Layer {
  #[spec(fn(&amp;mut Layer[@l], &amp;RVec&lt;f64&gt;) )]
  fn forward(&amp;mut self, input: &amp;RVec&lt;f64&gt;) {
    (0..self.num_outputs).for_each(|i| {
      let weighted_input = dot_product(&amp;self.weight[i], input);
      self.outputs[i] = sigmoid(weighted_input + self.bias[i])
    })
  }
}</code></pre></pre>
<p><strong>EXERCISE:</strong> Flux is unhappy about the implementation of <code>forward</code>. Can
you figure out why and add the type specification that lets Flux verify
the code?</p>
<h3 id="backward-propagation"><a class="header" href="#backward-propagation">Backward Propagation</a></h3>
<p>Next, lets implement the <code>backward</code> propagation function that takes as
input the inputs given to the <code>Layer</code> and the <em>error</em> produced by a
given Layer (roughly, the difference between the expected output and the
actual output of that layer), and learning <code>rate</code> <em>hyper-parameter</em> that
controls the step size for gradient descent, to</p>
<ol>
<li>
<p><em>Update</em> the weights and biases of the layer to reduce the error,
and</p>
</li>
<li>
<p><em>Propagate</em> the appropriate amount of error to the previous layer.</p>
</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">impl Layer {
  fn backward(&amp;mut self, inputs: &amp;RVec&lt;f64&gt;, err: &amp;RVec&lt;f64&gt;, rate:f64)
     -&gt; RVec&lt;f64&gt; {
    let mut input_err = rvec![0.0; inputs.len()];
    for i in 0..self.num_outputs {
        for j in 0..self.num_inputs {
            input_err[j] += self.weight[i][j] * err[i];
            self.weight[i][j] -= rate * err[i] * inputs[j];
        }
        self.bias[i] -= rate * err[i];
    }
    input_err
  }
}</code></pre></pre>
<p>The code works as follows.</p>
<ol>
<li>
<p>First, we initialize the <code>input_err</code> vector that corresponds to the
<code>err</code> propagated backwards (to the previous layer);</p>
</li>
<li>
<p>Next, we loop over each output neuron <code>i</code>, and iterate over each of
its inputs <code>j</code> to <em>accumulate</em> that input’s weighted contribution to
the <code>err</code>, and <em>update</em> <code>weight[i][j]</code> (and similarly, <code>bias[i]</code>)
with the gradient <code>err[i] * inputs[j]</code> multiplied by the <code>rate</code>
which ensures we subsequently reduce the error;</p>
</li>
</ol>
<p><strong>EXERCISE:</strong> Looks like we forgot to write down the appropriate
dimensions for the input <code>Layer</code> and the various input and output
vectors, which makes Flux report errors all over the place. Can you fill
them in so the code verifies?</p>
<h2 id="composing-layers-into-networks"><a class="header" href="#composing-layers-into-networks">Composing Layers into Networks</a></h2>
<p>A neural <em>network</em> is the composition of multiple <em>layers</em>.
[fig]:neural-network shows a network that maps 3-inputs to 4-outputs,
with three <em>hidden</em> levels in between which respectively 4, 2, and 3
neurons. Put another way, we might say that the network in the figure
composes <em>four</em> <code>Layer</code>s shown in blue, green, yellow and orange
respectively. In this case, the <code>Layer</code>s match up nicely, with the
outputs of each precisely matching the inputs of the next layer. Next,
lets see how Flux can help ensure that we only ever construct networks
where the layers snap together perfectly.</p>
<figure>
<p><img src="tutorial/../img/neural-network.png" style="width:100.0%" /></p>
<figcaption><p>A 3-input, 4-output neural network with three hidden
levels.</p></figcaption>
</figure>
<p><span id="fig:neural-network"></span></p>
<p>The key idea is to think of <em>building up</em> the network from the right to
the left, starting with the final output layer, and working our way
backwards.</p>
<ul>
<li>
<p>The <em>last</em> orange <code>Layer[3, 4]</code> corresponds to a <code>Network</code> that maps 3
inputs to 4 outputs (lets call that a <code>Network[3, 4]</code>);</p>
</li>
<li>
<p>Next, we add the yellow <code>Layer[2, 3]</code> that composes with the
<code>Network[3, 4]</code> to give us a <code>Network[2, 4]</code>;</p>
</li>
<li>
<p>Next, we slap on the green <code>Layer[4, 2]</code> which connects with the
<code>Network[2, 3]</code> to give a <code>Network[4, 4]</code>;</p>
</li>
<li>
<p>Finally, we top it off with the blue <code>Layer[3, 4]</code> that connects with
the <code>Network[4, 4]</code> to give us the final <code>Network[3, 4]</code>.</p>
</li>
</ul>
<p><strong>Refined <code>Network</code>s</strong> Lets codify the above intuition by defining a
recursive <code>Network</code> that is <em>refined by</em> the number of input and output
neurons.</p>
<pre><pre class="playground"><code class="language-rust  editable">enum Network {
   #[variant((Layer[@i, @o]) -&gt; Network[i, o])]
   Last(Layer),

   #[variant((Layer[@i, @h], Box&lt;Network[h, @o]&gt;) -&gt; Network[i, o])]
   Next(Layer, Box&lt;Network&gt;),
}</code></pre></pre>
<p>Lets consider the two variants of the <code>Network</code> enum.</p>
<ul>
<li>
<p>The <code>Last</code> variant takes as input a <code>Layer[i, o]</code> to construct a
<code>Network[i, o]</code>, just like the orange <code>Layer[3, 4]</code> yields a
<code>Network[3, 4]</code>;</p>
</li>
<li>
<p>The <code>Next</code> variant takes as input a <code>Layer[i, h]</code> which maps <code>i</code>
<em>inputs</em> to <code>h</code> <em>hidden</em> neurons, and a <code>Network[h, o]</code> which maps
those <code>h</code> hidden neurons to <code>o</code> <em>outputs</em>, to construct a
<code>Network[i, o]</code> that maps <code>i</code> inputs to <code>o</code> outputs!</p>
</li>
</ul>
<p>The network in [fig]:neural-network can thus be represented as</p>
<pre><pre class="playground"><code class="language-rust  editable">#[spec(fn() -&gt; Network[3, 4])]
fn example_network() -&gt; Network {
  let blue = Layer::new(3, 4);
  let green = Layer::new(4, 2);
  let yellow = Layer::new(2, 3);
  let orange = Layer::new(3, 4);
  network![blue, green, yellow, orange]
}</code></pre></pre>
<p>where the <code>network!</code> macro recursively applies <code>Next</code> and <code>Last</code> to
build the <code>Network</code>.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[macro_export]
macro_rules! network {
    ($last:expr) =&gt; {
        Network::Last($last)
    };
    ($first:expr, $($rest:expr),+) =&gt; {
        Network::Next($first, Box::new(network!($($rest),+)))
    };
}</code></pre></pre>
<p><strong>EXERCISE:</strong> Complete the specification and implementation of a
function <code>Network::new</code> that takes as input the number of <code>inputs</code>, a
slice of <code>hiddens</code>, and the number of <code>outputs</code> and returns a <code>Network</code>
that maps the <code>inputs</code> to <code>outputs</code> after passing through the specified
hidden layers.</p>
<pre><pre class="playground"><code class="language-rust  editable">impl Network {
  fn new(inputs: usize, hiddens: &amp;[usize], outputs: usize) -&gt; Network {
    if hidden_sizes.is_empty() {
      Network::Last(Layer::new(input_size, output_size))
    } else {
      todo!()
    }
  }
}</code></pre></pre>
<p>When done, the following should create a <code>Network</code> like that in
[fig]:neural-network.</p>
<pre><pre class="playground"><code class="language-rust  editable">#[spec(fn() -&gt; Network[3, 4])]
fn test_network() -&gt; Network { Network::new(3, &amp;[4, 2, 3], 4) }</code></pre></pre>
<h2 id="network-propagation"><a class="header" href="#network-propagation">Network Propagation</a></h2>
<p>Finally, lets implement the <code>forward</code> and <code>backward</code> functions so that
they work over the entire <code>Network</code>, thereby allowing us to do both
training and inference.</p>
<h3 id="forward-evaluation-1"><a class="header" href="#forward-evaluation-1">Forward Evaluation</a></h3>
<p><strong>EXERCISE:</strong> The <code>forward</code> evaluation recurses on the <code>Network</code>,
calling <code>forward</code> on each <code>Layer</code> and passing the outputs to the <code>next</code>
part of the <code>Network</code>, returning the output of the <code>Last</code> layer. Fill in
the specification for <code>forward</code> so it verifies.</p>
<pre><pre class="playground"><code class="language-rust  editable">fn forward(&amp;mut self, input: &amp;RVec&lt;f64&gt;) -&gt; RVec&lt;f64&gt; {
  match self {
    Network::Next(layer, next) =&gt; {
      layer.forward(input); next.forward(&amp;layer.outputs)
    }
    Network::Last(layer) =&gt; {
      layer.forward(input); layer.outputs.clone()
    }
  }
}</code></pre></pre>
<h3 id="back-propagation"><a class="header" href="#back-propagation">Back Propagation</a></h3>
<p>The <em>back-propagation</em> function assumes we have already done a <code>forward</code>
pass, and have the outputs stored in each <code>Layer</code>‘s <code>outputs</code> field. It
then takes as input the <code>target</code> or expected output, computes the
<code>err</code>or at the last layer, and then propagates that error backwards
through the network, updating the weights and biases as it goes using
the gradients computed at each layer via its <code>backward</code> function.</p>
<pre><pre class="playground"><code class="language-rust  editable">fn backward(&amp;mut self, inputs:&amp;RVec&lt;f64&gt;, target:&amp;RVec&lt;f64&gt;, rate:f64)
   -&gt; RVec&lt;f64&gt; {
  match self {
    Network::Last(layer) =&gt; {
      let err = (0..layer.num_outputs)
                  .map(|i| layer.outputs[i] - target[i])
                  .collect();
      layer.backward(inputs, &amp;err, rate)
    }
    Network::Next(layer, next) =&gt; {
      todo!("exercise: fill this in")
    }
  }
}</code></pre></pre>
<p><strong>EXERCISE:</strong> Complete the specification and implementation of
<code>backward</code> above so that it recursively propagates the error all the way
to the first layer, by calling <code>backward</code> on each of the intermediate
layers.</p>
<h2 id="summary-10"><a class="header" href="#summary-10">Summary</a></h2>
<p>To recap, in this chapter, we saw how to build a small neural network
library from scratch in Rust, using Flux’s refinement types to track the
dimensions of each network <code>Layer</code> and to ensure that they are composed
correctly into a <code>Network</code>. Note that doing so requires checking a
“linking” property: that the outputs of one layer match the inputs of
the next layer, and that this happens for an unbounded number of layers.
Its rather convenient that one can neatly tuck this invariant inside the
<code>enum</code> definition of <code>Network</code>, in a way that the type checker can then
verify automatically at compile time!</p>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<p><a href="https://byteblog.medium.com/building-a-simple-neural-network-from-scratch-in-rust-3a7b12ed30a9">https://byteblog.medium.com/building-a-simple-neural-network-from-scratch-in-rust-3a7b12ed30a9</a> <a href="#fr-1-1">↩</a></p>
</li>
<li id="footnote-2">
<p><a href="http://neuralnetworksanddeeplearning.com/chap1.html">http://neuralnetworksanddeeplearning.com/chap1.html</a> <a href="#fr-2-1">↩</a></p>
</li>
<li id="footnote-3">
<p><a href="https://en.wikipedia.org/wiki/Neural_network_(machine_learning)">https://en.wikipedia.org/wiki/Neural_network_(machine_learning)</a> <a href="#fr-3-1">↩</a></p>
</li>
<li id="footnote-4">
<p>As described in <a href="tutorial/ch11_equality.html#detached">this chapter</a> <a href="#fr-4-1">↩</a></p>
</li>
<li id="footnote-5">
<p>As described in <a href="tutorial/ch06_vectors.html">this chapter</a> <a href="#fr-5-1">↩</a></p>
</li>
<li id="footnote-6">
<p><a href="http://neuralnetworksanddeeplearning.com/">http://neuralnetworksanddeeplearning.com/</a> <a href="#fr-6-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="flux-specifications-1"><a class="header" href="#flux-specifications-1">Flux Specifications</a></h1>
<p>One day, this will be an actual user's guide, but for now,
it is a WIP guide to writing specifications in <code>flux</code>, as
illustrated by examples from the regression tests.</p>
<h2 id="refinement-types"><a class="header" href="#refinement-types">Refinement Types</a></h2>
<ul>
<li>
<p><strong>Indexed Type</strong>: An indexed type <code>B[r]</code> is composed of a base Rust type <code>B</code> and a refinement index <code>r</code>. The meaning of the index depends on the type. Some examples are</p>
<ul>
<li><code>i32[n]</code>: denotes the (singleton) set of <code>i32</code> values equal to <code>n</code>.</li>
<li><code>List&lt;T&gt;[n]</code>: values of type <code>List&lt;T&gt;</code> of length <code>n</code>.</li>
</ul>
</li>
<li>
<p><strong>Refinement parameter</strong>: Function signatures can be parametric on refinement variables. Refinement parameters are declared using the <code>@n</code> syntax. For example, the following signature:</p>
<p><code>fn(i32[@n]) -&gt; i32[n + 1]</code></p>
<p>binds <code>n</code> over the entire scope of the function to specify that it takes an <code>i32</code> equal to <code>n</code> and returns an <code>i32</code> equal to <code>n + 1</code>. This is analogous to languages like Haskell where a lower case letter can be used to quantify over a type, e.g., the type <code>a -&gt; a</code> in Haskell is polymorphic on the type <code>a</code> which is bound for the scope of the entire function type.</p>
</li>
<li>
<p><strong>Existential Type</strong>: An existential type <code>B{v: r(v)}</code> is composed of a base type <code>B</code>, a refinement variable <code>v</code> and a refinement predicate <code>r</code> on <code>v</code>. Intuitively, a Rust value <code>x</code> has type <code>B{v: r(v)}</code> if there exists a refinement value <code>a</code> such that <code>r(a)</code> holds and <code>x</code> has type <code>B[a]</code>.</p>
<ul>
<li><code>i32{v: v &gt; 0}</code>: set of positive <code>i32</code> values.</li>
<li><code>List&lt;T&gt;{v: v &gt; 0}</code>: set of non-empty lists.</li>
</ul>
</li>
<li>
<p><strong>Constraint Type</strong>: A constraint type has the form <code>{T | r}</code> where <code>T</code> is any type (not just a base type). Intuitively, a value has type <code>{T | r}</code> if it has type <code>T</code> and also <code>r</code> holds. They can be used to constraint a refinement parameter. For example, the following signature constraint the refinement parameter <code>n</code> to be less than <code>10</code>.</p>
<p><code>fn({i32[@n] | n &lt; 10}) -&gt; i32[n + 1]</code></p>
<p>Constraint types serve a similar role as existentials as they can also be used to constraint some
refinement value with a predicate, but an existential type can only be used to constraint refinement
variable that it bound locally, in contrast constraint types can be used to constraint a "non-local" parameter. This can be seen in the example above where the parameter <code>n</code> cannot be bound locally
because it has to be used in the return type.</p>
</li>
</ul>
<h2 id="argument-syntax"><a class="header" href="#argument-syntax">Argument Syntax</a></h2>
<p>The <code>@n</code> syntax used to declare refinements parameters can be hard to read sometimes. Flux also supports a syntax that let you bind refinement parameters using colons similar to the syntax used to declare arguments in a function. We call this <em>argument syntax</em>. This syntax desugars to one of the refinements forms discussed above. For example, the following signature</p>
<p><code>fn(x: i32, y: i32) -&gt; i32[x + y]</code></p>
<p>desugars to</p>
<p><code>fn(i32[@x], i32[@y]) -&gt; i32[x + y]</code></p>
<p>It is also possible to attach some constraint to the parameters when using argument syntax. For example,
to specify that <code>y</code> must be greater than <code>x</code> using argument syntax we can write:</p>
<p><code>fn(x: i32, y: i32{x &gt; y}) -&gt; i32[x + y]</code></p>
<p>This will desugar to:</p>
<p><code>fn(i32[@x], {i32[@y] | x &gt; y}) -&gt; i32[x + y]</code></p>
<h2 id="grammar-of-refinements"><a class="header" href="#grammar-of-refinements">Grammar of Refinements</a></h2>
<p>The grammar of refinements (expressions that can appear as an index or constraint) is as follows:</p>
<pre><code class="language-text">r ::= n                     // numbers 1,2,3...
    | x                     // identifiers x,y,z...
    | x.f                   // index-field access
    | r + r                 // addition
    | r - r                 // subtraction
    | n * e                 // multiplication by constant
    | if r { r } else { r } // if-then-else
    | f(r...)               // function application
    | true | false          // booleans
    | r == r                // equality
    | r != r                // not equal
    | r &lt; r                 // less than
    | r &lt;= r                // less than or equal
    | r &gt; r                 // greater than
    | r &gt;= r                // greater than or equal
    | r || r                // disjunction
    | r &amp;&amp; r                // conjunction
    | r =&gt; r                // implication
    | !r                    // negation
</code></pre>
<h2 id="index-refinements"><a class="header" href="#index-refinements">Index Refinements</a></h2>
<p>Of the form <code>i32[e]</code> (<code>i32</code> equal to <code>e</code>) values.</p>
<pre><code class="language-rust noplayground noplayground">#[flux::sig(fn(bool[true]))]
pub fn assert(_b: bool) {}

pub fn test00() {
    let x = 1;
    let y = 2;
    assert(x + 1 == y);
}

#[flux::sig(fn five() -&gt; usize[5])]
pub fn five() -&gt; usize {
    let x = 2;
    let y = 3;
    x + y
}

#[flux::sig(fn(n:usize) -&gt; usize[n+1])]
pub fn incr(n: usize) -&gt; usize {
    n + 1
}

pub fn test01() {
    let a = five();
    let b = incr(a);
    assert(b == 6);
}</code></pre>
<p><strong>NOTE:</strong> We use the <code>sig(..)</code> annotation to specify the refinement type of a function;
you can optionally also add the <em>name</em> of the function as shown for <code>fn five</code>.</p>
<h2 id="existential-refinements"><a class="header" href="#existential-refinements">Existential Refinements</a></h2>
<p>Of the form <code>i32{v: 0 &lt;= v}</code> (non-negative <code>i32</code>) values.</p>
<pre><code class="language-rust noplayground noplayground">#[flux::spec(fn(x:i32) -&gt; i32{v: v &gt; x})]
pub fn inc(x: i32) -&gt; i32 {
    x + 1
}

#[flux::spec(fn(x:i32) -&gt; i32{v: v &lt; x})]
pub fn dec(x: i32) -&gt; i32 {
    x - 1
}</code></pre>
<h2 id="combining-index-and-existential-refinements"><a class="header" href="#combining-index-and-existential-refinements">Combining Index and Existential Refinements</a></h2>
<pre><code class="language-rust noplayground noplayground">#[flux::sig(fn(k: i32{0 &lt;= k}) -&gt; i32[0])]
pub fn test(mut k: i32) -&gt; i32 {
    while toss() &amp;&amp; k &lt; i32::MAX - 1 {
        k += 1;
    }
    while k &gt; 0 {
        k -= 1;
    }
    k
}</code></pre>
<h2 id="mutable-references"><a class="header" href="#mutable-references">Mutable References</a></h2>
<pre><code class="language-rust noplayground noplayground">#[flux::sig(fn(x: &amp;mut i32{v: 0 &lt;= v}))]
pub fn test4(x: &amp;mut i32) {
    *x += 1;
}</code></pre>
<pre><code class="language-rust noplayground noplayground">#[flux::sig(fn(x: &amp;mut i32{v: 0 &lt;= v}))]
pub fn test4(x: &amp;mut i32) {
    *x -= 1; //~ ERROR assignment might be unsafe
}</code></pre>
<h2 id="strong-references"><a class="header" href="#strong-references">Strong References</a></h2>
<p>Like <code>&amp;mut T</code> but which allow <em>strong updates</em> via <code>ensures</code> clauses</p>
<pre><code class="language-rust noplayground noplayground">#[flux::sig(fn(x: &amp;strg i32[@n]) ensures x: i32[n+1])]
pub fn inc(x: &amp;mut i32) {
    *x += 1;
}

#[flux::sig(fn() -&gt; i32[1])]
pub fn test_inc() -&gt; i32 {
    let mut x = 0;
    inc(&amp;mut x);
    x
}</code></pre>
<h2 id="mixing-mutable-and-strong-references"><a class="header" href="#mixing-mutable-and-strong-references">Mixing Mutable and Strong References</a></h2>
<pre><code class="language-rust noplayground">#[flux::sig(fn (x: &amp;strg i32[@n]) ensures x: i32[n+1])]
pub fn incr(x: &amp;mut i32) {
    *x += 1;
}

#[flux::sig(fn (x: &amp;mut i32{v: 0&lt;=v}))]
pub fn client_safe(z: &amp;mut i32) {
    incr(z);
}</code></pre>
<h2 id="refined-arrays"><a class="header" href="#refined-arrays">Refined Arrays</a></h2>
<p><code>flux</code> supports <em>refined arrays</em> of the form <code>[i32{v: 0 &lt;= v}; 20]</code>
denoting arrays of size <code>20</code> of non-negative <code>i32</code> values.</p>
<pre><code class="language-rust noplayground">#[flux::sig(fn() -&gt; [i32{v : v &gt;= 0}; 2])]
pub fn array00() -&gt; [i32; 2] {
    [0, 1]
}

pub fn read_u16() -&gt; u16 {
    let bytes: [u8; 2] = [10, 20];
    u16::from_le_bytes(bytes)
}

#[flux::sig(fn() -&gt; i32{v : v &gt; 10})]
pub fn write() -&gt; i32 {
    let bytes: [i32; 2] = [10, 20];
    bytes[0] + bytes[1]
}</code></pre>
<h2 id="refined-vectors-rvec"><a class="header" href="#refined-vectors-rvec">Refined Vectors <code>rvec</code></a></h2>
<p><code>RVec</code> specification</p>
<pre><code class="language-rust noplayground">#![allow(dead_code)]

pub mod rslice;

#[macro_export]
macro_rules! rvec {
    () =&gt; { RVec::new() };
    ($($e:expr),+$(,)?) =&gt; {{
        let mut res = RVec::new();
        $( res.push($e); )*
        res
    }};
    ($elem:expr; $n:expr) =&gt; {{
        RVec::from_elem_n($elem, $n)
    }}
}

#[flux::opaque]
#[flux::refined_by(len: int)]
#[flux::invariant(0 &lt;= len)]
pub struct RVec&lt;T&gt; {
    inner: Vec&lt;T&gt;,
}

impl&lt;T&gt; RVec&lt;T&gt; {
    #[flux::trusted]
    #[flux::sig(fn() -&gt; RVec&lt;T&gt;[0])]
    pub fn new() -&gt; Self {
        Self { inner: Vec::new() }
    }

    #[flux::trusted]
    #[flux::sig(fn(self: &amp;strg RVec&lt;T&gt;[@n], T) ensures self: RVec&lt;T&gt;[n+1])]
    pub fn push(&amp;mut self, item: T) {
        self.inner.push(item);
    }

    #[flux::trusted]
    #[flux::sig(fn(&amp;RVec&lt;T&gt;[@n]) -&gt; usize[n])]
    pub fn len(&amp;self) -&gt; usize {
        self.inner.len()
    }

    #[flux::trusted]
    #[flux::sig(fn(&amp;RVec&lt;T&gt;[@n]) -&gt; bool[n == 0])]
    pub fn is_empty(&amp;self) -&gt; bool {
        self.inner.is_empty()
    }

    #[flux::trusted]
    #[flux::sig(fn(&amp;RVec&lt;T&gt;[@n], i: usize{i &lt; n}) -&gt; &amp;T)]
    pub fn get(&amp;self, i: usize) -&gt; &amp;T {
        &amp;self.inner[i]
    }

    #[flux::trusted]
    #[flux::sig(fn(&amp;mut RVec&lt;T&gt;[@n], i: usize{i &lt; n}) -&gt; &amp;mut T)]
    pub fn get_mut(&amp;mut self, i: usize) -&gt; &amp;mut T {
        &amp;mut self.inner[i]
    }

    #[flux::trusted]
    #[flux::sig(fn(self: &amp;strg RVec&lt;T&gt;[@n]) -&gt; T
    		requires n &gt; 0
            ensures self: RVec&lt;T&gt;[n-1])]
    pub fn pop(&amp;mut self) -&gt; T {
        self.inner.pop().unwrap()
    }

    #[flux::trusted]
    #[flux::sig(fn(&amp;mut RVec&lt;T&gt;[@n], a: usize{a &lt; n}, b: usize{b &lt; n}))]
    pub fn swap(&amp;mut self, a: usize, b: usize) {
        self.inner.swap(a, b);
    }

    #[flux::trusted]
    #[flux::sig(fn(&amp;mut RVec&lt;T&gt;[@n]) -&gt; &amp;mut [T][n])]
    pub fn as_mut_slice(&amp;mut self) -&gt; &amp;mut [T] {
        self.inner.as_mut_slice()
    }

    #[flux::trusted]
    #[flux::sig(fn(arr:_) -&gt; RVec&lt;T&gt;[N])]
    pub fn from_array&lt;const N: usize&gt;(arr: [T; N]) -&gt; Self {
        Self { inner: Vec::from(arr) }
    }

    #[flux::trusted]
    #[flux::sig(fn(xs:&amp;[T][@n]) -&gt; RVec&lt;T&gt;[n])]
    pub fn from_slice(xs: &amp;[T]) -&gt; Self
    where
        T: Clone,
    {
        Self { inner: Vec::from(xs) }
    }

    #[flux::trusted]
    #[flux::sig(fn(T, n: usize) -&gt; RVec&lt;T&gt;[n])]
    pub fn from_elem_n(elem: T, n: usize) -&gt; Self
    where
        T: Copy,
    {
        let mut vec = Self::new();
        let mut i = 0;
        while i &lt; n {
            vec.push(elem);
            i += 1;
        }
        vec
    }

    #[flux::trusted]
    #[flux::sig(fn(&amp;RVec&lt;T&gt;[@n]) -&gt; RVec&lt;T&gt;[n])]
    pub fn clone(&amp;self) -&gt; Self
    where
        T: Clone,
    {
        Self { inner: self.inner.clone() }
    }

    #[flux::trusted]
    #[flux::sig(fn(self: &amp;strg RVec&lt;T&gt;[@n], other: &amp;[T][@m]) ensures self: RVec&lt;T&gt;[n + m])]
    pub fn extend_from_slice(&amp;mut self, other: &amp;[T])
    where
        T: Clone,
    {
        self.inner.extend_from_slice(other)
    }

    #[flux::trusted]
    #[flux::sig(fn (&amp;RVec&lt;T&gt;[@n], F) -&gt; RVec&lt;U&gt;[n])]
    pub fn map&lt;U, F&gt;(&amp;self, f: F) -&gt; RVec&lt;U&gt;
    where
        F: Fn(&amp;T) -&gt; U,
    {
        RVec { inner: self.inner.iter().map(f).collect() }
    }

    #[flux::trusted]
    pub fn fold&lt;B, F&gt;(&amp;self, init: B, f: F) -&gt; B
    where
        F: FnMut(B, &amp;T) -&gt; B,
    {
        self.inner.iter().fold(init, f)
    }
}

#[flux::opaque]
pub struct RVecIter&lt;T&gt; {
    vec: RVec&lt;T&gt;,
    curr: usize,
}

impl&lt;T&gt; IntoIterator for RVec&lt;T&gt; {
    type Item = T;
    type IntoIter = RVecIter&lt;T&gt;;

    // TODO: cannot get variant of opaque struct
    #[flux::trusted]
    #[flux::sig(fn(RVec&lt;T&gt;) -&gt; RVecIter&lt;T&gt;)]
    fn into_iter(self) -&gt; RVecIter&lt;T&gt; {
        RVecIter { vec: self, curr: 0 }
    }
}

impl&lt;T&gt; Iterator for RVecIter&lt;T&gt; {
    type Item = T;

    // TODO: cannot get variant of opaque struct
    #[flux::trusted]
    #[flux::sig(fn(&amp;mut RVecIter&lt;T&gt;) -&gt; Option&lt;T&gt;)]
    fn next(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.vec.inner.pop()
    }
}

impl&lt;T&gt; std::ops::Index&lt;usize&gt; for RVec&lt;T&gt; {
    type Output = T;

    #[flux::trusted_impl]
    #[flux::sig(fn(&amp;RVec&lt;T&gt;[@n], usize{v : v &lt; n}) -&gt; &amp;T)]
    fn index(&amp;self, index: usize) -&gt; &amp;T {
        self.get(index)
    }
}

impl&lt;T&gt; std::ops::IndexMut&lt;usize&gt; for RVec&lt;T&gt; {
    #[flux::trusted_impl]
    #[flux::sig(fn(&amp;mut RVec&lt;T&gt;[@n], usize{v : v &lt; n}) -&gt; &amp;mut T)]
    fn index_mut(&amp;mut self, index: usize) -&gt; &amp;mut T {
        self.get_mut(index)
    }
}</code></pre>
<p><code>RVec</code> clients</p>
<pre><code class="language-rust noplayground">#[path = "../../lib/rvec.rs"]
mod rvec;
use rvec::RVec;

#[flux::sig(fn() -&gt; RVec&lt;i32&gt;[0])]
pub fn test0() -&gt; RVec&lt;i32&gt; {
    let mv = rvec![];
    mv
}

#[flux::sig(fn() -&gt; RVec&lt;i32&gt;[5])]
pub fn test1() -&gt; RVec&lt;i32&gt; {
    rvec![ 12; 5 ]
}

#[flux::sig(fn(n:usize) -&gt; RVec&lt;i32&gt;[n])]
pub fn test2(n: usize) -&gt; RVec&lt;i32&gt; {
    rvec![ 12; n ]
}

pub fn test3() -&gt; usize {
    let v = rvec![0, 1];
    let r = v[0];
    let r = r + v[1];
    r
}</code></pre>
<p><strong>Binary Search</strong></p>
<pre><code class="language-rust noplayground">#![allow(unused_attributes)]

#[path = "../../lib/rvec.rs"]
pub mod rvec;
use rvec::RVec;

// CREDIT: https://shane-o.dev/blog/binary-search-rust

#[flux::sig(fn(i32, &amp;RVec&lt;i32&gt;) -&gt; usize)]
pub fn binary_search(k: i32, items: &amp;RVec&lt;i32&gt;) -&gt; usize {
    let size = items.len();
    if size &lt;= 0 {
        return size;
    }

    let mut low: usize = 0;
    let mut high: usize = size - 1;

    while low &lt;= high {
        // SAFE   let middle = (high + low) / 2;
        // UNSAFE let middle = high + ((high - low) / 2);
        let middle = low + ((high - low) / 2);
        let current = items[middle];
        if current == k {
            return middle;
        }
        if current &gt; k {
            if middle == 0 {
                return size;
            }
            high = middle - 1
        }
        if current &lt; k {
            low = middle + 1
        }
    }
    size
}</code></pre>
<p><strong>Heapsort</strong></p>
<pre><code class="language-rust noplayground">#[path = "../../lib/rvec.rs"]
mod rvec;
use rvec::RVec;

#[flux::sig(fn(&amp;mut RVec&lt;i32&gt;[@n]) -&gt; i32)]
pub fn heap_sort(vec: &amp;mut RVec&lt;i32&gt;) -&gt; i32 {
    let len = vec.len();

    if len &lt;= 0 {
        return 0;
    }

    let mut start = len / 2;
    while start &gt; 0 {
        start -= 1;
        shift_down(vec, start, len - 1);
    }

    let mut end = len;
    while end &gt; 1 {
        end -= 1;
        vec.swap(0, end);
        shift_down(vec, 0, end - 1);
    }
    0
}

#[flux::sig(fn(&amp;mut RVec&lt;i32&gt;[@len], usize{v : v &lt; len}, usize{v : v &lt; len}) -&gt; i32)]
pub fn shift_down(vec: &amp;mut RVec&lt;i32&gt;, start: usize, end: usize) -&gt; i32 {
    let mut root = start;
    loop {
        let mut child = root * 2 + 1;
        if child &gt; end {
            break;
        } else {
            if child + 1 &lt;= end {
                let a = vec[child];
                let b = vec[child + 1];
                if a &lt; b {
                    child += 1;
                }
            }
            let a = vec[root];
            let b = vec[child];
            if a &lt; b {
                vec.swap(root, child);
                root = child;
            } else {
                break;
            }
        }
    }
    0
}</code></pre>
<h2 id="refined-slices"><a class="header" href="#refined-slices">Refined Slices</a></h2>
<pre><code class="language-rust noplayground">#[flux::sig(fn(&amp;[i32{v : v &gt; 0}]) -&gt; &amp;[i32{v : v &gt;= 0}])]
fn first_half(slice: &amp;[i32]) -&gt; &amp;[i32] {
    let mid = slice.len() / 2;
    let (fst, snd) = slice.split_at(mid);
    fst
}

#[flux::sig(fn(&amp;[i32{v : v &gt; 0}]) -&gt; Option&lt;&amp;i32{v : v &gt;= 0}&gt;)]
fn first(slice: &amp;[i32]) -&gt; Option&lt;&amp;i32&gt; {
    slice.first()
}

#[flux::sig(fn(&amp;mut [i32{v : v &gt; 0}]))]
fn inc_fst(slice: &amp;mut [i32]) {
    if let Some(x) = slice.first_mut() {
        *x += 1;
    }
}</code></pre>
<pre><code class="language-rust noplayground">#[path = "../../lib/rvec.rs"]
mod rvec;
use rvec::{RVec, rslice::RSlice};

#[flux::sig(fn(&amp;mut RVec&lt;T&gt;[10]))]
fn test00&lt;T&gt;(vec: &amp;mut RVec&lt;T&gt;) {
    let mut s = RSlice::from_vec(vec);
    let s1 = s.subslice(0, 3);
    let s2 = s.subslice(4, 5);
}

#[flux::trusted]
#[flux::sig(fn(x: &amp;[T][@n]) -&gt; usize[n])]
fn len&lt;T&gt;(x: &amp;[T]) -&gt; usize {
    x.len()
}

#[flux::sig(fn(&amp;mut [i32][@n], &amp;[i32][n]))]
fn add(x: &amp;mut [i32], y: &amp;[i32]) {
    let mut i = 0;
    while i &lt; len(x) {
        x[i] += y[i];
        i += 1;
    }
}

#[flux::sig(fn(&amp;mut {RVec&lt;i32&gt;[@n] | n % 2 == 0 &amp;&amp; n &gt; 0}))]
fn test01(vec: &amp;mut RVec&lt;i32&gt;) {
    let n = vec.len();
    let mut s = RSlice::from_vec(vec);
    let mut s1 = s.subslice(0, n / 2 - 1);
    let s2 = s.subslice(n / 2, n - 1);
    add(s1.as_mut_slice(), s2.as_slice())
}</code></pre>
<h2 id="refined-vec"><a class="header" href="#refined-vec">Refined <code>Vec</code></a></h2>
<p>This uses <code>extern_spec</code> which is <a href="guide/specifications.html#extern-specs">described below</a>.</p>
<p><strong>Standalone</strong></p>
<pre><code class="language-rust noplayground">#![feature(allocator_api)]

extern crate flux_alloc;
extern crate flux_core;

use flux_rs::{assert, attrs::*};

#[spec(fn() -&gt; Vec&lt;i32&gt;[3])]
pub fn test_vec_macro() -&gt; Vec&lt;i32&gt; {
    vec![10, 20, 30]
}

#[spec(fn() -&gt; Vec&lt;i32&gt;[4])]
pub fn test_push_macro() -&gt; Vec&lt;i32&gt; {
    let res = vec![10, 20, 30, 40];
    assert(res.len() == 4);
    res
}

#[spec(fn() -&gt; Vec&lt;i32&gt;[2])]
pub fn test_push() -&gt; Vec&lt;i32&gt; {
    let mut res = Vec::new();
    res.push(10);
    res.push(20);
    res.push(30);
    let val = res.pop().unwrap();
    assert(val &gt;= 10);
    res
}

#[spec(fn() -&gt; usize[2])]
pub fn test_len() -&gt; usize {
    let res = test_push();
    res.len()
}

pub fn test_is_empty() {
    let res = test_push();
    assert(!res.is_empty())
}

// TODO: https://github.com/flux-rs/flux/issues/578
// #[spec(fn (Vec&lt;i32{v:10 &lt;= v}&gt;))]
// pub fn test3(xs: Vec&lt;i32&gt;) {
//     for x in &amp;xs {
//         assert(0 &lt;= *x)
//     }
// }

#[spec(fn (vec: &amp;mut Vec&lt;T&gt;[@n]) -&gt; Option&lt;(T, T)&gt;
       requires n &gt; 2
       ensures vec: Vec&lt;T&gt;[n-2])]
pub fn pop2&lt;T&gt;(vec: &amp;mut Vec&lt;T&gt;) -&gt; Option&lt;(T, T)&gt; {
    let v1 = vec.pop().unwrap();
    let v2 = vec.pop().unwrap();
    Some((v1, v2))
}</code></pre>
<p><strong>Associated Refinements</strong> for indexing</p>
<pre><code class="language-rust noplayground">use std::{
    alloc::{Allocator, Global},
    ops::{Index, IndexMut},
    slice::SliceIndex,
};

use flux_attrs::*;

//---------------------------------------------------------------------------------------
#[extern_spec]
#[refined_by(len: int)]
#[invariant(0 &lt;= len)]
struct Vec&lt;T, A: Allocator = Global&gt;;

//---------------------------------------------------------------------------------------

#[extern_spec]
impl&lt;T&gt; Vec&lt;T&gt; {
    #[flux::sig(fn() -&gt; Vec&lt;T&gt;[0])]
    fn new() -&gt; Vec&lt;T&gt;;
}

#[extern_spec]
impl&lt;T, A: Allocator&gt; Vec&lt;T, A&gt; {
    #[spec(fn(self: &amp;mut Vec&lt;T, A&gt;[@n], T) ensures self: Vec&lt;T, A&gt;[n+1])]
    fn push(v: &amp;mut Vec&lt;T, A&gt;, value: T);

    #[spec(fn(&amp;Vec&lt;T, A&gt;[@n]) -&gt; usize[n])]
    fn len(v: &amp;Vec&lt;T, A&gt;) -&gt; usize;

    #[spec(fn(self: &amp;mut Vec&lt;T, A&gt;[@n]) -&gt; Option&lt;T&gt;[n &gt; 0] ensures self: Vec&lt;T, A&gt;[if n &gt; 0 { n-1 } else { 0 }])]
    fn pop(&amp;mut self) -&gt; Option&lt;T&gt;;

    #[spec(fn(self: &amp;Vec&lt;T, A&gt;[@n]) -&gt; bool[n == 0])]
    fn is_empty(&amp;self) -&gt; bool;
}

//---------------------------------------------------------------------------------------

#[extern_spec]
impl&lt;T, I: SliceIndex&lt;[T]&gt;, A: Allocator&gt; Index&lt;I&gt; for Vec&lt;T, A&gt; {
    #[spec(fn(&amp;Vec&lt;T, A&gt;[@len], {I[@idx] | &lt;I as SliceIndex&lt;[T]&gt;&gt;::in_bounds(idx, len)}) -&gt; _)]
    fn index(z: &amp;Vec&lt;T, A&gt;, index: I) -&gt; &amp;&lt;I as SliceIndex&lt;[T]&gt;&gt;::Output;
}

#[extern_spec]
impl&lt;T, I: SliceIndex&lt;[T]&gt;, A: Allocator&gt; IndexMut&lt;I&gt; for Vec&lt;T, A&gt; {
    #[spec(fn(&amp;mut Vec&lt;T,A&gt;[@len], {I[@idx] | &lt;I as SliceIndex&lt;[T]&gt;&gt;::in_bounds(idx, len)}) -&gt; _)]
    fn index_mut(z: &amp;mut Vec&lt;T, A&gt;, index: I) -&gt; &amp;mut &lt;I as SliceIndex&lt;[T]&gt;&gt;::Output;
}

//---------------------------------------------------------------------------------------
#[extern_spec]
impl&lt;'a, T, A: Allocator&gt; IntoIterator for &amp;'a Vec&lt;T, A&gt; {
    #[spec(fn (&amp;Vec&lt;T, A&gt;[@n]) -&gt; &lt;&amp;Vec&lt;T, A&gt; as IntoIterator&gt;::IntoIter[0,n])]
    fn into_iter(v: &amp;'a Vec&lt;T, A&gt;) -&gt; &lt;&amp;'a Vec&lt;T, A&gt; as IntoIterator&gt;::IntoIter;
}

#[extern_spec]
#[assoc(fn with_size(self: Self, n:int) -&gt; bool { self.len == n })]
impl&lt;T&gt; FromIterator&lt;T&gt; for Vec&lt;T&gt; {}</code></pre>
<pre><code class="language-rust noplayground">#![feature(allocator_api)]

use std::ops::Index;

extern crate flux_alloc;
extern crate flux_core;

// ---------------------------------------------------------------------------------------

pub fn test_get0(xs: &amp;Vec&lt;i32&gt;) -&gt; &amp;i32 {
    &lt;Vec&lt;i32&gt; as Index&lt;usize&gt;&gt;::index(xs, 10) //~ ERROR refinement type
}

pub fn test_get1(xs: &amp;Vec&lt;i32&gt;) -&gt; i32 {
    xs[10] //~ ERROR refinement type
}

#[flux::sig(fn (&amp;Vec&lt;i32&gt;[100]) -&gt; &amp;i32)]
pub fn test_get2(xs: &amp;Vec&lt;i32&gt;) -&gt; &amp;i32 {
    &lt;Vec&lt;i32&gt; as Index&lt;usize&gt;&gt;::index(xs, 99)
}

#[flux::sig(fn (&amp;Vec&lt;i32&gt;[100]) -&gt; i32)]
pub fn test_get3(xs: &amp;Vec&lt;i32&gt;) -&gt; i32 {
    xs[99]
}

pub fn test_set0(xs: &amp;mut Vec&lt;i32&gt;) {
    xs[10] = 100; //~ ERROR refinement type
}

#[flux::sig(fn (&amp;mut Vec&lt;i32&gt;[100]))]
pub fn test_set1(xs: &amp;mut Vec&lt;i32&gt;) {
    xs[99] = 100;
}

pub fn test1() {
    let mut xs = Vec::&lt;i32&gt;::new();
    xs.push(10);
    xs.push(20);
    xs.push(30);

    xs[0] = 100;
    xs[1] = 100;
    xs[2] = 100;
    xs[10] = 100; //~ ERROR refinement type
}

pub fn test2(xs: Vec&lt;i32&gt;, i: usize) {
    if i &lt; xs.len() {
        let _ = xs[i];
        let _ = xs[i + 1]; //~ ERROR refinement type
    }
}</code></pre>
<h2 id="named-function-signatures"><a class="header" href="#named-function-signatures">Named Function Signatures</a></h2>
<p>You can also write <em>named</em> function signatures using the <code>spec</code>
annotation (instead of the anonymous <code>sig</code> annotation).</p>
<h2 id="requires-clauses"><a class="header" href="#requires-clauses">Requires Clauses</a></h2>
<p>Used to specify preconditions in a single spot, if needed.</p>
<pre><code class="language-rust noplayground">#[path = "../../lib/rvec.rs"]
mod rvec;
use rvec::RVec;

#[flux::sig(
    fn(&amp;mut RVec&lt;i32&gt;[@n], b:bool) -&gt; i32[0]
    requires 2 &lt;= n
)]
pub fn test1(vec: &amp;mut RVec&lt;i32&gt;, b: bool) -&gt; i32 {
    let r;
    if b {
        r = &amp;mut vec[0];
    } else {
        r = &amp;mut vec[1];
    }
    *r = 12;
    0
}</code></pre>
<h2 id="refining-structs-1"><a class="header" href="#refining-structs-1">Refining Structs</a></h2>
<pre><code class="language-rust noplayground">#![flux::defs {
    qualifier Sub2(x: int, a: int, b:int) { x == a - b }
}]
#[path = "../../lib/rvec.rs"]
pub mod rvec;

use rvec::RVec;

#[flux::refined_by(x: int, y:int)]
pub struct Pair {
    #[flux::field(i32[x])]
    pub x: i32,
    #[flux::field(i32[y])]
    pub y: i32,
}

#[flux::sig(fn(a: i32) -&gt; RVec&lt;Pair{v : v.x + v.y &lt;= a }&gt;)]
pub fn mk_pairs_with_bound(a: i32) -&gt; RVec&lt;Pair&gt; {
    let mut i = 0;
    let mut res = RVec::new();
    while i &lt; a {
        let p = Pair { x: i, y: a - i };
        res.push(p);
        i += 1;
    }
    res
}</code></pre>
<pre><code class="language-rust noplayground">#![flux::defs {
    fn is_btwn(v:int, lo:int, hi: int) -&gt; bool { lo &lt;= v &amp;&amp; v &lt;= hi }
    fn ok_day(d:int) -&gt; bool { is_btwn(d, 1, 31) }
    fn is_month30(m:int) -&gt; bool { m == 4 || m == 6 || m == 9 || m == 11 }
    fn ok_month(d:int, m:int) -&gt; bool { is_btwn(m, 1, 12) &amp;&amp; (is_month30(m) =&gt; d &lt;= 30) }
    fn is_leap_year(y:int) -&gt; bool { y % 400 == 0 || (y % 4 == 0 &amp;&amp; (y % 100) &gt; 0) }
    fn is_feb_day(d:int, y:int) -&gt; bool { d &lt;= 29 &amp;&amp; ( d == 29 =&gt; is_leap_year(y) ) }
    fn ok_year(d:int, m:int, y:int) -&gt; bool { 1 &lt;= y &amp;&amp; (m == 2 =&gt; is_feb_day(d, y)) }
}]

// https://github.com/chrisdone/sandbox/blob/master/liquid-haskell-dates.hs

#[allow(dead_code)]
#[flux::refined_by(d:int, m:int, y:int)]
pub struct Date {
    #[flux::field({ usize[d] | ok_day(d) })]
    day: usize,
    #[flux::field({ usize[m] | ok_month(d, m)})]
    month: usize,
    #[flux::field({ usize[y] | ok_year(d, m, y)})]
    year: usize,
}

pub fn test() {
    let _ok_date = Date { day: 9, month: 8, year: 1977 };
}

// TODO: Tedious to duplicate the definitions if you want to use them in rust code.
// Maybe some macro magic can unify?

#[flux::sig(fn(m:usize) -&gt; bool[is_month30(m)])]
fn is_month30(m: usize) -&gt; bool {
    m == 4 || m == 6 || m == 9 || m == 11
}

#[flux::sig(fn(y:usize) -&gt; bool[is_leap_year(y)])]
fn is_leap_year(y: usize) -&gt; bool {
    y % 400 == 0 || (y % 4 == 0 &amp;&amp; y % 100 != 0)
}

#[flux::sig(fn(d:usize, y:usize) -&gt; bool[is_feb_day(d, y)])]
fn is_feb_day(d: usize, y: usize) -&gt; bool {
    d &lt;= 29 &amp;&amp; (d != 29 || is_leap_year(y))
}

pub fn mk_date(day: usize, month: usize, year: usize) -&gt; Option&lt;Date&gt; {
    if 1 &lt;= year &amp;&amp; 1 &lt;= month &amp;&amp; month &lt;= 12 &amp;&amp; 1 &lt;= day &amp;&amp; day &lt;= 31 {
        if !is_month30(month) || day &lt;= 30 {
            if month != 2 || is_feb_day(day, year) {
                return Some(Date { day, month, year });
            }
        }
    }
    return None;
}</code></pre>
<h3 id="invariants-on-structs"><a class="header" href="#invariants-on-structs">Invariants on Structs</a></h3>
<pre><code class="language-rust noplayground">#[flux::refined_by(a: int, b: int)]
#[flux::invariant(a &gt; 0)]
#[flux::invariant(b &gt; 0)]
pub struct S {
    #[flux::field({i32[a] | a &gt; 0})]
    fst: i32,
    #[flux::field({i32[b] | b &gt;= a})]
    snd: i32,
}</code></pre>
<p>with <code>const</code> generics</p>
<pre><code class="language-rust noplayground">// Test that const generics in invariants are properly instantiated

use flux_rs::attrs::*;

#[invariant(N &gt; 0)]
struct S&lt;const N: usize&gt; {}

#[sig(fn(_) -&gt; usize{v : v &gt; 0})]
fn foo&lt;const M: usize&gt;(x: S&lt;M&gt;) -&gt; usize {
    M
}</code></pre>
<h3 id="opaque-structs"><a class="header" href="#opaque-structs">Opaque Structs</a></h3>
<p>Flux offers an attribute <code>opaque</code> which can be used on structs. A module defining an opaque struct should define a trusted API, and clients of the API should not access struct fields directly. This is particularly useful in cases where users need to define a type indexed by a different type than the structs fields. For example, <code>RMap</code> (see below) defines a refined HashMap, indexed by a <code>Map</code> - a primitive sort defined by flux.</p>
<pre><code class="language-rust noplayground">use flux_rs::*;

#[opaque]
#[refined_by(vals: Map&lt;K, V&gt;)]
pub struct RMap&lt;K, V&gt; {
    inner: std::collections::HashMap&lt;K, V&gt;,
}</code></pre>
<p><strong>Note that opaque structs <strong>can not</strong> have refined fields.</strong></p>
<p>Now, we can define <code>get</code> for our refined map as follows:</p>
<pre><code class="language-rust noplayground">impl&lt;K, V&gt; RMap&lt;K, V&gt; {

    #[flux_rs::trusted]
    #[flux_rs::sig(fn(&amp;RMap&lt;K, V&gt;[@m], &amp;K[@k]) -&gt; Option&lt;&amp;V[map_select(m.vals, k)]&gt;)]
    pub fn get(&amp;self, k: &amp;K) -&gt; Option&lt;&amp;V&gt;
    where
        K: Eq + Hash,
    {
        self.inner.get(k)
    }

}</code></pre>
<p>Note that if we do not mark these methods as <code>trusted</code>, we will get an error that looks like...</p>
<pre><code class="language-text">error[E0999]: cannot access fields of opaque struct `RMap`.
  --&gt; ../opaque.rs:22:9
   |
22 |         self.inner.get(k)
   |         ^^^^^^^^^^
-Ztrack-diagnostics: created at crates/flux-refineck/src/lib.rs:111:14
   |
help: if you'd like to use fields of `RMap`, try annotating this method with `#[flux::trusted]`
  --&gt; ../opaque.rs:18:5
   |
18 | /     pub fn get(&amp;self, k: &amp;K) -&gt; Option&lt;&amp;V&gt;
19 | |     where
20 | |         K: Eq + std::hash::Hash,
   | |________________________________^
   = note: fields of opaque structs can only be accessed inside trusted code
</code></pre>
<p>Here is an example of how to use the <code>opaque</code> attribute:</p>
<pre><code class="language-rust noplayground">#[flux::opaque]
#[flux::refined_by(a: int, b: int)]
#[flux::invariant(a &lt;= b)]
pub struct Range {
    a: i32,
    b: i32,
}

impl Range {
    #[flux::trusted]
    #[flux::sig(fn(a: i32, b: i32{b &gt;= a}) -&gt; Range[a, b])]
    pub fn new(a: i32, b: i32) -&gt; Range {
        Range { a, b }
    }

    #[flux::trusted]
    #[flux::sig(fn(&amp;Range[@r]) -&gt; i32[r.a])]
    pub fn fst(&amp;self) -&gt; i32 {
        self.a
    }

    #[flux::trusted]
    #[flux::sig(fn(&amp;Range[@r]) -&gt; i32[r.b])]
    pub fn snd(&amp;self) -&gt; i32 {
        self.b
    }
}

#[flux::sig(fn(Range) -&gt; bool[true])]
fn test(r: Range) -&gt; bool {
    r.snd() - r.fst() &gt;= 0
}</code></pre>
<h2 id="refining-enums-1"><a class="header" href="#refining-enums-1">Refining Enums</a></h2>
<pre><code class="language-rust noplayground">#[flux::refined_by(b:bool)]
pub enum Opt&lt;T&gt; {
    #[flux::variant(Opt&lt;T&gt;[false])]
    None,
    #[flux::variant({T} -&gt; Opt&lt;T&gt;[true])]
    Some(T),
}

#[flux::sig(fn(Opt&lt;T&gt;[@b]) -&gt; bool[b])]
pub fn is_some&lt;T&gt;(x: Opt&lt;T&gt;) -&gt; bool {
    match x {
        Opt::None =&gt; false,
        Opt::Some(_) =&gt; true,
    }
}

#[flux::sig(fn(Opt&lt;T&gt;[@b]) -&gt; bool[b])]
pub fn is_some_flip&lt;T&gt;(x: Opt&lt;T&gt;) -&gt; bool {
    match x {
        Opt::Some(_) =&gt; true,
        Opt::None =&gt; false,
    }
}

#[flux::sig(fn(i32{v:false}) -&gt; T)]
pub fn never&lt;T&gt;(_x: i32) -&gt; T {
    loop {}
}

#[flux::sig(fn(Opt&lt;T&gt;[true]) -&gt; T)]
pub fn unwrap&lt;T&gt;(x: Opt&lt;T&gt;) -&gt; T {
    match x {
        Opt::Some(v) =&gt; v,
        Opt::None =&gt; never(0),
    }
}</code></pre>
<pre><code class="language-rust noplayground">#[flux::refined_by(n: int)]
#[flux::invariant(n &gt; 0)]
pub enum Pos {
    #[flux::variant({Box&lt;Pos[@n]&gt;} -&gt; Pos[2*n])]
    XO(Box&lt;Pos&gt;),
    #[flux::variant({Box&lt;Pos[@n]&gt;} -&gt; Pos[2*n + 1])]
    XI(Box&lt;Pos&gt;),
    #[flux::variant(Pos[1])]
    XH,
}

impl Pos {
    #[flux::spec(fn(&amp;Pos[@n]) -&gt; i32[n])]
    pub fn to_i32(&amp;self) -&gt; i32 {
        match self {
            Pos::XH =&gt; 1,
            Pos::XI(rest) =&gt; 2 * rest.to_i32() + 1,
            Pos::XO(rest) =&gt; 2 * rest.to_i32(),
        }
    }

    #[flux::sig(fn(&amp;Pos[@n]) -&gt; bool[n == 1])]
    pub fn is_one(&amp;self) -&gt; bool {
        match self {
            Pos::XH =&gt; true,
            Pos::XI(_) =&gt; false,
            Pos::XO(_) =&gt; false,
        }
    }
}</code></pre>
<pre><code class="language-rust noplayground">#[flux::sig(fn(i32{v: false}) -&gt; T)]
pub fn never&lt;T&gt;(_: i32) -&gt; T {
    loop {}
}

#[flux::refined_by(n:int)]
#[flux::invariant(n &gt;= 0)]
pub enum List {
    #[flux::variant(List[0])]
    Nil,
    #[flux::variant((i32, Box&lt;List[@n]&gt;) -&gt; List[n+1])]
    Cons(i32, Box&lt;List&gt;),
}

#[flux::sig(fn(&amp;List[@n]) -&gt; bool[n == 0])]
pub fn empty(l: &amp;List) -&gt; bool {
    match l {
        List::Nil =&gt; true,
        List::Cons(_, _) =&gt; false,
    }
}

#[flux::sig(fn(&amp;List[@n]) -&gt; i32[n])]
pub fn len(l: &amp;List) -&gt; i32 {
    match l {
        List::Nil =&gt; 0,
        List::Cons(_, tl) =&gt; 1 + len(tl),
    }
}

#[flux::sig(fn({&amp;List[@n] | 0 &lt; n}) -&gt; i32)]
pub fn head(l: &amp;List) -&gt; i32 {
    match l {
        List::Nil =&gt; never(0),
        List::Cons(h, _) =&gt; *h,
    }
}

#[flux::sig(fn({&amp;List[@n] | 0 &lt; n}) -&gt; &amp;List)]
pub fn tail(l: &amp;List) -&gt; &amp;List {
    match l {
        List::Nil =&gt; never(0),
        List::Cons(_, t) =&gt; t,
    }
}

#[flux::sig(fn(i32, n: usize) -&gt; List[n])]
pub fn clone(val: i32, n: usize) -&gt; List {
    if n == 0 {
        List::Nil
    } else {
        List::Cons(val, Box::new(clone(val, n - 1)))
    }
}

#[flux::sig(fn(List[@n1], List[@n2]) -&gt; List[n1+n2])]
pub fn append(l1: List, l2: List) -&gt; List {
    match l1 {
        List::Nil =&gt; l2,
        List::Cons(h1, t1) =&gt; List::Cons(h1, Box::new(append(*t1, l2))),
    }
}

#[flux::sig(fn(l1: &amp;strg List[@n1], List[@n2]) ensures l1: List[n1+n2])]
pub fn mappend(l1: &amp;mut List, l2: List) {
    match l1 {
        List::Nil =&gt; *l1 = l2,
        List::Cons(_, t1) =&gt; mappend(&amp;mut *t1, l2),
    }
}

#[flux::sig(fn(&amp;List[@n], k:usize{k &lt; n} ) -&gt; i32)]
pub fn get_nth(l: &amp;List, k: usize) -&gt; i32 {
    match l {
        List::Cons(h, tl) =&gt; {
            if k == 0 {
                *h
            } else {
                get_nth(tl, k - 1)
            }
        }
        List::Nil =&gt; never(0),
    }
}</code></pre>
<h3 id="invariants-on-enums"><a class="header" href="#invariants-on-enums">Invariants on Enums</a></h3>
<pre><code class="language-rust noplayground">#[flux::refined_by(n: int)]
#[flux::invariant(n &gt;= 0)]
pub enum E {
    #[flux::variant({{i32[@n] | n &gt; 0}} -&gt; E[n])]
    Pos(i32),
    #[flux::variant({i32[0]} -&gt; E[0])]
    Zero(i32),
}

#[flux::sig(fn(E[@n], i32[n]) -&gt; i32{v: v &gt; 0})]
pub fn is_zero(_: E, x: i32) -&gt; i32 {
    x + 1
}</code></pre>
<h3 id="reflecting-enums"><a class="header" href="#reflecting-enums">Reflecting Enums</a></h3>
<pre><code class="language-rust noplayground">use flux_rs::attrs::*;

#[reflect]
pub enum State {
    On,
    Off,
}

#[spec(fn () -&gt; State[State::On])]
pub fn test00() -&gt; State {
    State::On
}

#[spec(fn () -&gt; State[State::Off])]
pub fn test01() -&gt; State {
    State::Off
}

#[spec(fn () -&gt; State[State::Off])]
pub fn test02() -&gt; State {
    State::On //~ ERROR refinement type
}

#[spec(fn (State[State::On]) -&gt; usize[1])]
pub fn test03(s: State) -&gt; usize {
    match s {
        State::On =&gt; 1,
        State::Off =&gt; 0,
    }
}

#[spec(fn (State[@squig], zig: usize, tag: Day) -&gt; usize[tag])]
pub fn test04(s: State, _zig: usize, tag: Day) -&gt; usize {
    match s {
        State::On =&gt; 1,  //~ ERROR refinement type
        State::Off =&gt; 0, //~ ERROR refinement type
    }
}

#[refined_by(day: int)]
pub enum Day {
    #[flux::variant(Day[0])]
    Mon,
    #[flux::variant(Day[1])]
    Tue,
    #[flux::variant(Day[2])]
    Wed,
}

#[spec(fn (s:State, zig: usize, tag: Day) -&gt; usize[tag])]
pub fn test05(s: State, _zig: usize, _tag: Day) -&gt; usize {
    match s {
        State::On =&gt; 1,  //~ ERROR refinement type
        State::Off =&gt; 0, //~ ERROR refinement type
    }
}</code></pre>
<h2 id="field-syntax-for-indices"><a class="header" href="#field-syntax-for-indices">Field Syntax for Indices</a></h2>
<h3 id="structs"><a class="header" href="#structs">Structs</a></h3>
<pre><code class="language-rust noplayground">#[flux::refined_by(x: int, y: int)]
pub struct X {
    #[flux::field(u32[x])]
    x: u32,
    #[flux::field(u32[y])]
    y: u32,
}

#[flux::sig(fn (x: X[@old_x]) -&gt; X[X { y: 2, x: 1 }])]
fn f(mut x: X) -&gt; X {
    x.x = 1;
    x.y = 2;
    x
}</code></pre>
<h3 id="enums"><a class="header" href="#enums">Enums</a></h3>
<pre><code class="language-rust noplayground">#[flux::refined_by(x: int, y: int)]
pub enum E {
    #[flux::variant(E[0, 1])]
    Variant1,
    #[flux::variant(E[1, 2])]
    Variant2,
    #[flux::variant(E[2, 3])]
    Variant3,
}

#[flux::sig(fn (e: E[@old_enum]) -&gt; E[E { x: 1, y: 2 }])]
fn f(e: E) -&gt; E {
    E::Variant2
}</code></pre>
<h3 id="updates"><a class="header" href="#updates">Updates</a></h3>
<pre><code class="language-rust noplayground">#[flux::refined_by(x: int, y: int)]
pub struct S {
    #[flux::field(u32[x])]
    x: u32,
    #[flux::field(u32[y])]
    y: u32,
}

impl S {
    #[flux::sig(fn (self: &amp;strg S[@old_x]) ensures self: S[S { x: 1, ..old_x }])]
    pub fn update(&amp;mut self) {
        self.x = 1;
    }
}</code></pre>
<pre><code class="language-rust noplayground">#![flux::defs {
    fn some_computation(s: S) -&gt; S { s }
}]

#[flux::refined_by(x: int, y: int)]
pub struct S {
    #[flux::field(u32[x])]
    x: u32,
    #[flux::field(u32[y])]
    y: u32,
}

impl S {
    #[flux::sig(fn (self: &amp;strg S[@old_x]) ensures self: S[S { x: 1, ..some_computation(old_x) }])]
    pub fn update(&amp;mut self) {
        self.x = 1;
    }

    #[flux::sig(fn (self: &amp;strg S[@old_x]) ensures self: S[S { x: 1, ..S { x: 2, ..old_x } }])]
    pub fn update2(&amp;mut self) {
        self.x = 1;
    }
}</code></pre>
<pre><code class="language-rust noplayground">use flux_rs::*;

#[refined_by(start: T, end: T)]
pub struct Range&lt;T&gt; {
    #[flux::field(T[start])]
    pub start: T,
    #[flux::field(T[end])]
    pub end: T,
}

#[sig(fn(r: Range&lt;T&gt;[@old]) -&gt; Range&lt;T&gt;[ Range { ..old } ])]
pub fn foo&lt;T&gt;(r: Range&lt;T&gt;) -&gt; Range&lt;T&gt; {
    r
}

#[sig(fn(r: Range&lt;i32&gt;{v: v == Range { start: 0, end: 0 } }))]
pub fn foo2(_r: Range&lt;i32&gt;) {}

#[sig(fn(r: Range&lt;i32&gt;[Range { start: 0, end: 0 } ]))]
pub fn foo3(_r: Range&lt;i32&gt;) {}</code></pre>
<pre><code class="language-rust noplayground">#![flux::defs {
    fn some_computation(s: S) -&gt; S { s }
}]

#[flux::refined_by(x: int, y: int)]
pub struct S {
    #[flux::field(u32[x])]
    x: u32,
    #[flux::field(u32[y])]
    y: u32,
}

impl S {
    #[flux::sig(fn (self: &amp;strg S[@old_x]) ensures self: S[{ x: 1, ..some_computation(old_x) }])]
    pub fn update(&amp;mut self) {
        self.x = 1;
    }

    #[flux::sig(fn (self: &amp;strg S[@old_x]) ensures self: S[{ x: 1, ..S { x: 2, ..old_x } }])]
    pub fn update2(&amp;mut self) {
        self.x = 1;
    }
}</code></pre>
<h2 id="const"><a class="header" href="#const">Const</a></h2>
<p>You can use <code>int</code>-ish <code>const</code> in refinements e.g.</p>
<pre><code class="language-rust noplayground">pub struct Cow {}

impl Cow {
    const GRASS: usize = 12;

    #[flux_rs::sig(fn () -&gt; usize[12])]
    pub fn test() -&gt; usize {
        Self::GRASS
    }
}</code></pre>
<pre><code class="language-rust noplayground">#[repr(u32)]
pub enum SyscallReturnVariant {
    Failure = 0,
}

#[flux_rs::sig(fn() -&gt; u32[0])]
pub fn test() -&gt; u32 {
    SyscallReturnVariant::Failure as u32
}</code></pre>
<pre><code class="language-rust noplayground">pub struct Cow {}

const GRASS: usize = 12;
impl Cow {
    #[flux_rs::sig(fn () -&gt; usize[12])]
    fn test() -&gt; usize {
        GRASS
    }
}</code></pre>
<h2 id="requires-with-forall"><a class="header" href="#requires-with-forall">Requires with <code>forall</code></a></h2>
<p>We allow a <code>forall</code> on the requires clauses, e.g.</p>
<pre><code class="language-rust noplayground">#[flux::sig(fn(bool[true]))]
fn assert(_: bool) {}
#[flux::sig(
    fn(x: i32)
    requires forall y. y &gt;= 0 =&gt; y &gt; x
)]
fn requires_negative(x: i32) {
    assert(x + 1 == 1 + x); // make sure there's something to check to avoid optimizing the entire constraint away
}

fn test2() {
    requires_negative(-1);
}</code></pre>
<h2 id="refined-associated-types"><a class="header" href="#refined-associated-types">Refined Associated Types</a></h2>
<pre><code class="language-rust noplayground">use flux_rs::*;

#[sig(fn(bool[true]))]
fn assert(_: bool) {}

trait MyTrait {
    type Assoc;

    #[sig(fn(Self::Assoc[@x]) -&gt; Self::Assoc[x])]
    fn f0(x: Self::Assoc) -&gt; Self::Assoc;

    #[sig(fn(x: Self::Assoc) -&gt; Self::Assoc{ v: v == x })]
    fn f1(x: Self::Assoc) -&gt; Self::Assoc;
}

impl MyTrait for () {
    type Assoc = i32;

    #[sig(fn(x: i32) -&gt; i32[x])]
    fn f0(x: i32) -&gt; i32 {
        x
    }

    #[sig(fn(x: i32) -&gt; i32[x])]
    fn f1(x: i32) -&gt; i32 {
        x
    }
}

fn test00() {
    let x = &lt;() as MyTrait&gt;::f0(0);
    assert(x == 0);
}

fn test01() {
    let x = &lt;() as MyTrait&gt;::f1(0);
    assert(x == 0);
}</code></pre>
<h2 id="ignored-and-trusted-code"><a class="header" href="#ignored-and-trusted-code">Ignored and trusted code</a></h2>
<p>Flux offers two attributes for controlling which parts of your code it analyzes: <code>#[flux_rs::ignore]</code> and <code>#[flux_rs::trusted]</code>.</p>
<ul>
<li><code>#[flux_rs::ignore]</code>: This attribute is applicable to any item, and it instructs Flux to completely skip some code. Flux won't even look at it.</li>
<li><code>#[flux_rs::trusted]</code>: This attribute affects whether Flux checks the body of a function. If a function is marked as trusted, Flux won't verify its body against its signature. However, it will still be able to reason about its signature when used elsewhere.</li>
</ul>
<p>The above means that an <em>ignored</em> function can only be called from ignored or trusted code, while a <em>trusted</em> function can also be called from analyzed code.</p>
<p>Both attributes apply recursively. For instance, if a module is marked as <code>#[flux_rs::ignore]</code>, all its nested elements will also be ignored. This transitive behavior can be disabled by marking an item with <code>#[flux_rs::ignore(no)]</code><sup class="footnote-reference" id="fr-ignore-shorthand-1"><a href="#footnote-ignore-shorthand">1</a></sup>, which will include all nested elements for analysis. Similarly,
the action of <code>#[flux_rs::trusted]</code> can be reverted using <code>#[flux_rs::trusted(no)]</code>.</p>
<p>Consider the following example:</p>
<pre><code class="language-rust noplayground">#[flux_rs::ignore]
mod A {

   #[flux_rs::ignore(no)]
   mod B {
      mod C {
         fn f1() {}
      }
   }

   mod D {
      fn f2() {}
   }

   fn f3() {}
}</code></pre>
<p>In this scenario, functions <code>f2</code> and <code>f3</code> will be ignored, while <code>f1</code> will be analyzed.</p>
<p>A typical pattern when retroactively adding Flux annotations to existing code is to ignore an entire crate (using the inner attribute <code>#![flux_rs::ignore]</code> at the top of the crate) and then selectively include specific sections for analysis.</p>
<p>Here is an example</p>
<pre><code class="language-rust noplayground">#![flux::ignore] // default to ignore for the entire crate

#[flux::ignore(no)] // include this module
mod included {
    #[flux::sig(fn(bool[true]))]
    pub fn assert(_: bool) {}

    pub fn test1() {
        // we are indeed checking this code
        assert(20 &lt; 10); //~ ERROR refinement type error
    }

    pub fn test2() {
        // we cannot use an ignored function in included code
        crate::ignored_fun(); //~ERROR use of ignored function
    }
}

// bad refinement, but no error since we are ignoring this function
#[flux::sig(fn(i32, i32))]
pub fn malformed(_: i32) {}

// an ignored function that cannot be used in included code
pub fn ignored_fun() {}</code></pre>
<h2 id="pragma-should_fail"><a class="header" href="#pragma-should_fail">Pragma: <code>should_fail</code></a></h2>
<p>Used to tell <code>flux</code> to <em>expect</em> a failure when checking a function.</p>
<pre><code class="language-rust noplayground">// This function has an error
// but it's marked as should_fail so that ok.
// flux would yell if instead it verified!

#[flux::should_fail]
#[flux::sig(fn(x: i32) -&gt; i32[x + 1])]
fn test00(x: i32) -&gt; i32 {
    x + 2
}</code></pre>
<h2 id="const-generics-2"><a class="header" href="#const-generics-2">Const Generics</a></h2>
<p><code>flux</code> lets you use Rust's const-generics inside refinements.</p>
<p><strong>Refining Array Lengths</strong></p>
<pre><code class="language-rust noplayground">// https://github.com/flux-rs/flux/issues/625

const BUFLEN: usize = 100;

pub struct Blob {
    data: [i32; BUFLEN],
}

pub fn test(buf: &amp;[i32; BUFLEN]) -&gt; i32 {
    let x0 = buf[0];
    let x1 = buf[10];
    let x2 = buf[BUFLEN - 1];
    let xbad = buf[BUFLEN]; //~ ERROR assertion might fail
    x0 + x1 + x2 + xbad
}

pub fn test_blob(blob: Blob) -&gt; i32 {
    let x0 = blob.data[0];
    let x1 = blob.data[10];
    let x2 = blob.data[BUFLEN - 1];
    let xbad = blob.data[BUFLEN]; //~ ERROR assertion might fail
    x0 + x1 + x2 + xbad
}</code></pre>
<p><strong>Refining Struct Fields</strong></p>
<pre><code class="language-rust noplayground">#[flux::invariant(N &gt; 0)]
pub struct MPU&lt;const N: usize&gt; {
    #[flux::field({ i32 | N &gt; 0 })]
    field: i32,
}

pub fn foo&lt;const N: usize&gt;(x: usize, _mpu: MPU&lt;N&gt;) {
    let _x = x % N;
}

#[flux::invariant(N &gt; 0)]
pub struct MPUGOOD&lt;const N: usize&gt; {
    field: i32,
}

pub fn bar&lt;const N: usize&gt;(x: usize, _mpu: MPUGOOD&lt;N&gt;) {
    let _x = x % N;
}

pub fn baz&lt;const N: usize&gt;() -&gt; i32 {
    if N &gt; 0 {
        let mpu = MPUGOOD::&lt;N&gt; { field: 12 };
        mpu.field
    } else {
        0
    }
}</code></pre>
<p><strong>Refining Function Signatures</strong></p>
<pre><code class="language-rust noplayground">#[path = "../../lib/rvec.rs"]
mod rvec;
use rvec::RVec;

/// A statically sized matrix represented with a linear vector
struct Matrix&lt;const N: usize, const M: usize&gt; {
    #[flux::field(RVec&lt;i32&gt;[N * M])]
    inner: RVec&lt;i32&gt;,
}

impl&lt;const N: usize, const M: usize&gt; Matrix&lt;N, M&gt; {
    fn new() -&gt; Matrix&lt;N, M&gt; {
        Matrix { inner: RVec::from_elem_n(0, N * M) }
    }

    #[flux::sig(fn(&amp;mut Self, i: usize{ i &lt; N }, j: usize{ j &lt; M }, v: i32))]
    fn set(&amp;mut self, i: usize, j: usize, v: i32) {
        self.inner[i * M + j] = v
    }

    #[flux::sig(fn(&amp;Self, i: usize{ i &lt; N }, j: usize{ j &lt; M }) -&gt; i32)]
    fn get(&amp;self, i: usize, j: usize) -&gt; i32 {
        self.inner[i * M + j]
    }
}</code></pre>
<h2 id="type-aliases"><a class="header" href="#type-aliases">Type Aliases</a></h2>
<p>You can define refined <strong>type aliases</strong> for Rust types.</p>
<p><strong>Note</strong></p>
<ol>
<li>They are connected to an underlying Rust type,</li>
<li>They may also be parameterized by refinements, e.g. <code>Lb</code></li>
<li>There are two different kinds of parametrizations
<ul>
<li><em>early</em> (<code>Nat</code>) and</li>
<li><em>late</em> (<code>Lb</code>).</li>
</ul>
</li>
</ol>
<pre><code class="language-rust noplayground">#[flux::alias(type Nat[n: int] = {i32[n] | 0 &lt;= n})]
type Nat = i32;

#[flux::alias(type Lb(n: int)[v: int] = {i32[v] | n &lt;= v})]
type Lb = i32;

#[flux::sig(fn(x: Nat) -&gt; Nat)]
pub fn test1(x: Nat) -&gt; Nat {
    x + 1
}

#[flux::sig(fn(x: Lb(10)) -&gt; Lb(10))]
pub fn test2(x: Lb) -&gt; Lb {
    x + 1
}</code></pre>
<h2 id="spec-function-definitions"><a class="header" href="#spec-function-definitions">Spec Function Definitions</a></h2>
<p>You can define <strong>spec functions</strong> that abstract complicated refinements into refinement-level
functions, which can then be used in refinements.</p>
<h3 id="plain-expressions"><a class="header" href="#plain-expressions">Plain Expressions</a></h3>
<pre><code class="language-rust noplayground">#![flux::defs {
    fn is_btwn(v:int, lo:int, hi: int) -&gt; bool { lo &lt;= v &amp;&amp; v &lt;= hi }
    fn ok_day(d:int) -&gt; bool { is_btwn(d, 1, 31) }
    fn is_month30(m:int) -&gt; bool { m == 4 || m == 6 || m == 9 || m == 11 }
    fn ok_month(d:int, m:int) -&gt; bool { is_btwn(m, 1, 12) &amp;&amp; (is_month30(m) =&gt; d &lt;= 30) }
    fn is_leap_year(y:int) -&gt; bool { y % 400 == 0 || (y % 4 == 0 &amp;&amp; (y % 100) &gt; 0) }
    fn is_feb_day(d:int, y:int) -&gt; bool { d &lt;= 29 &amp;&amp; ( d == 29 =&gt; is_leap_year(y) ) }
    fn ok_year(d:int, m:int, y:int) -&gt; bool { 1 &lt;= y &amp;&amp; (m == 2 =&gt; is_feb_day(d, y)) }
}]

// https://github.com/chrisdone/sandbox/blob/master/liquid-haskell-dates.hs

#[allow(dead_code)]
#[flux::refined_by(d:int, m:int, y:int)]
pub struct Date {
    #[flux::field({ usize[d] | ok_day(d) })]
    day: usize,
    #[flux::field({ usize[m] | ok_month(d, m)})]
    month: usize,
    #[flux::field({ usize[y] | ok_year(d, m, y)})]
    year: usize,
}

pub fn test() {
    let _ok_date = Date { day: 9, month: 8, year: 1977 };
}

// TODO: Tedious to duplicate the definitions if you want to use them in rust code.
// Maybe some macro magic can unify?

#[flux::sig(fn(m:usize) -&gt; bool[is_month30(m)])]
fn is_month30(m: usize) -&gt; bool {
    m == 4 || m == 6 || m == 9 || m == 11
}

#[flux::sig(fn(y:usize) -&gt; bool[is_leap_year(y)])]
fn is_leap_year(y: usize) -&gt; bool {
    y % 400 == 0 || (y % 4 == 0 &amp;&amp; y % 100 != 0)
}

#[flux::sig(fn(d:usize, y:usize) -&gt; bool[is_feb_day(d, y)])]
fn is_feb_day(d: usize, y: usize) -&gt; bool {
    d &lt;= 29 &amp;&amp; (d != 29 || is_leap_year(y))
}

pub fn mk_date(day: usize, month: usize, year: usize) -&gt; Option&lt;Date&gt; {
    if 1 &lt;= year &amp;&amp; 1 &lt;= month &amp;&amp; month &lt;= 12 &amp;&amp; 1 &lt;= day &amp;&amp; day &lt;= 31 {
        if !is_month30(month) || day &lt;= 30 {
            if month != 2 || is_feb_day(day, year) {
                return Some(Date { day, month, year });
            }
        }
    }
    return None;
}</code></pre>
<h3 id="let-binders"><a class="header" href="#let-binders"><code>let</code> binders</a></h3>
<pre><code class="language-rust noplayground">use flux_rs::attrs::*;

defs! {
    fn times2(x: int) -&gt; int {
        x * 2
    }

    fn test(x: int) -&gt; int {
        let y = times2(x);
        let z = times2(y);
        z * z * y
    }
}

#[sig(fn() -&gt; i32[test(10)])]
fn test() -&gt; i32 {
    32000
}</code></pre>
<h3 id="bounded-quantification"><a class="header" href="#bounded-quantification">Bounded Quantification</a></h3>
<pre><code class="language-rust noplayground">#![flux::defs {
    fn magic(xing:int, yonk:int) -&gt; bool;

    fn magic_all(noob:int) -&gt; bool {
        forall i in 0 .. 4 {
            magic(i, noob)
        }
    }

    fn magic_ex(n:int) -&gt; bool {
        exists i in 0 .. 4 {
            i == n
        }
    }
}]

#[flux::trusted]
#[flux::sig(fn(x:i32, y:i32) ensures magic(x, y))]
pub fn do_magic(_x: i32, _y: i32) {}

// forall tests ----------------------------------------------------------------

#[flux::sig(fn({i32[@n] | magic_all(n)}) ensures magic(3, n))]
pub fn test_all_l(_x: i32) {}

#[flux::sig(fn(n:i32) ensures magic_all(n))]
pub fn test_all_r(n: i32) {
    do_magic(0, n);
    do_magic(1, n);
    do_magic(2, n);
    do_magic(3, n);
}

// exists tests ----------------------------------------------------------------
#[flux::sig(fn({i32[@n] | magic_ex(n)}) -&gt; bool[true])]
pub fn test_exi_l(n: i32) -&gt; bool {
    n == 0 || n == 1 || n == 2 || n == 3
}

#[flux::sig(fn(n:i32) -&gt; bool[magic_ex(n)])]
pub fn test_exi_r(n: i32) -&gt; bool {
    n == 0 || n == 1 || n == 2 || n == 3
}</code></pre>
<h3 id="no-cycles"><a class="header" href="#no-cycles">No Cycles!</a></h3>
<p>However, there should be no <em>cyclic dependencies</em> in the function definitions.</p>
<pre><code class="language-rust noplayground">#![flux::defs {
    fn even(x: int) -&gt; bool { x == 0 || odd(x-1) }
    fn odd(x: int) -&gt; bool { x == 1 || even(x-1) } //~ ERROR cycle
}]

#[flux::sig(fn(x:i32) -&gt; i32[x+1])]
pub fn test(x: i32) -&gt; i32 {
    x + 1
}</code></pre>
<h2 id="uninterpreted-function-declarations"><a class="header" href="#uninterpreted-function-declarations">Uninterpreted Function Declarations</a></h2>
<p>You can also declare <em>uninterpreted</em> functions -- about which <code>flux</code> knows nothing
other than the congruence property -- and then use them in refinements. Note that
in this case you have to use a <code>trusted</code> annotation for the function (e.g. <code>is_valid</code>)
that asserts facts over the uninterpreted function</p>
<pre><code class="language-rust noplayground">#![flux::defs {
    fn valid(x:int) -&gt; bool;
}]

#[flux::trusted]
#[flux::sig(fn(x:i32) -&gt; bool[valid(x)])]
fn is_valid(x: i32) -&gt; bool {
    0 &lt;= x &amp;&amp; x &lt;= 100
}

#[flux::sig(fn (i32{v:valid(v)}) -&gt; i32)]
fn bar(a: i32) -&gt; i32 {
    return a;
}

#[flux::sig(fn(i32))]
pub fn test(n: i32) {
    let ok = is_valid(n);
    if ok {
        bar(n);
    }
}</code></pre>
<pre><code class="language-rust noplayground">#![flux::defs {
    fn foo(x:int, y:int) -&gt; int;
}]

#[flux::trusted]
#[flux::sig(fn(x: i32, y:i32) -&gt; i32[foo(x, y)])]
fn foo(x: i32, y: i32) -&gt; i32 {
    x + y
}

#[flux::sig(fn (i32[foo(10, 20)]) -&gt; i32)]
fn bar(a: i32) -&gt; i32 {
    return a;
}

#[flux::sig(fn())]
pub fn test() {
    let a = 10;
    let b = 20;
    let c = foo(a, b);
    bar(c);
}</code></pre>
<h2 id="hiding-and-revealing-function-definitions"><a class="header" href="#hiding-and-revealing-function-definitions">Hiding and Revealing Function Definitions</a></h2>
<p>By default all the function definitions are either <em>inlined</em> or sent to the SMT solver
as <code>define-fun</code> (when run with <code>FLUX_SMT_DEFINE_FUN=1</code>). Sometimes we want to <em>hide</em> the
definition because reasoning about those functions can kill the solver -- or the function
is super complex and we just want to reason about it via congruence. For that you can</p>
<ul>
<li>use the <code>#[hide]</code> attribute at the spec function definition, to make the function <em>uninterpreted</em> by default, and</li>
<li>use the <code>#[reveal]</code> attribute at specific Rust function definition, to indicate you
want to use the actual definition when checking that Rust function.</li>
</ul>
<pre><code class="language-rust noplayground">#![flux::defs {
    #[hide]
    fn mod33(n:int) -&gt; int {
        n % 33
    }

    #[hide]
    fn foo(n:int, k:int) -&gt; bool {
      mod33(n) == k
    }

}]

#[flux::sig(fn (a:i32) requires foo(a, 7))]
pub fn assert_foo(_a: i32) {}

#[flux::reveal(foo, mod33)]
pub fn use_foo(n: i32) {
    if n == 40 {
        assert_foo(n)
        // without `reveal(foo)` we want to see an error in the above line.
    }
}

#[flux::sig(fn (xs: &amp;[i32{v: foo(v, 7)}][100]) -&gt; i32{v : foo(v, 7)})]
pub fn bar(xs: &amp;[i32]) -&gt; i32 {
    xs[0] // `foo` as uninterpreted works fine
}</code></pre>
<h2 id="spec-functions-in-smtlib"><a class="header" href="#spec-functions-in-smtlib">Spec Functions in SMTLIB</a></h2>
<p>By default <code>flux</code> inlines all such function definitions.</p>
<p>Monomorphic functions may <em>optionally</em> be encoded
as functions in SMT by using the <code>FLUX_SMT_DEFINE_FUN=1</code>
environment variable.</p>
<h2 id="type-holes"><a class="header" href="#type-holes">Type Holes</a></h2>
<p>You can (sometimes!) use <code>_</code> in the <code>flux</code> signatures to omit the Rust components, e.g.</p>
<h3 id="function-signatures"><a class="header" href="#function-signatures">Function Signatures</a></h3>
<pre><code class="language-rust noplayground">#[flux::sig(fn(_) -&gt; Option&lt;_&gt;)]
fn test00(x: i32) -&gt; Option&lt;i32&gt; {
    Some(x)
}

#[flux::sig(fn(x: &amp;strg _) ensures x: i32[0])]
fn test01(x: &amp;mut i32) {
    *x = 0;
}

#[flux::sig(fn(x: &amp;strg i32) ensures x: _)]
fn test02(x: &amp;mut i32) {
    *x = 0;
}</code></pre>
<h3 id="structs-and-enums"><a class="header" href="#structs-and-enums">Structs and Enums</a></h3>
<pre><code class="language-rust noplayground">// Type holes in structs and enums

pub struct S {
    #[flux::field(Option&lt;_&gt;)]
    x: Option&lt;i32&gt;,
}

pub fn test_s(s: S) -&gt; Option&lt;i32&gt; {
    s.x
}

pub enum E {
    #[flux::variant((_) -&gt; E)]
    A(i32),
}

pub fn test_e(e: E) -&gt; i32 {
    match e {
        E::A(x) =&gt; x,
    }
}</code></pre>
<h3 id="type-aliases-1"><a class="header" href="#type-aliases-1">Type Aliases</a></h3>
<pre><code class="language-rust noplayground">#[flux::alias(type Test = Vec&lt;_&gt;)]
type Test = Vec&lt;i32&gt;;

fn test(x: Test) -&gt; Vec&lt;i32&gt; {
    x
}</code></pre>
<h3 id="generic-args"><a class="header" href="#generic-args">Generic Args</a></h3>
<pre><code class="language-rust noplayground">#[flux_rs::refined_by(m: Map&lt;int, int&gt;)]
#[flux_rs::opaque]
pub struct S1&lt;const N: usize&gt; {
    _arr: [usize; N],
}

const MY_N: usize = 10;

#[flux_rs::refined_by(gloop: S1)]
pub struct S2 {
    #[field(S1&lt;_&gt;[gloop])]
    pub s1: S1&lt;MY_N&gt;,
}

#[flux_rs::refined_by(zoo: S1)]
pub struct S3&lt;const M: usize&gt; {
    #[field(S1&lt;_&gt;[zoo])]
    pub s1: S1&lt;M&gt;,
}</code></pre>
<h2 id="closures"><a class="header" href="#closures">Closures</a></h2>
<pre><code class="language-rust noplayground">use flux_rs::attrs::*;

#[trusted]
#[spec(fn(c: Option&lt;bool&gt;) -&gt; Option&lt;i32{v:0 &lt;= v}&gt;)]
pub fn test0(c: Option&lt;bool&gt;) -&gt; Option&lt;i32&gt; {
    c.map(|b| if b { 1 } else { 2 })
}

// pub fn test0_buddy(x: i32) -&gt; i32 {
//     x + 1
// }

// #[flux::sig(fn(c: Option&lt;bool&gt;) -&gt; Option&lt;i32{v:1 &lt;= v}&gt;)]
// pub fn test1(c: Option&lt;bool&gt;) -&gt; Option&lt;i32&gt; {
//     c.map(|b| if b { 1 } else { 2 })
// }

// #[flux::sig(fn(c: Option&lt;bool[true]&gt;) -&gt; Option&lt;i32[1]&gt;)]
// pub fn test2(c: Option&lt;bool&gt;) -&gt; Option&lt;i32&gt; {
//     c.map(|b| if b { 1 } else { 2 })
// }

// #[flux::sig(fn(n:usize) -&gt; usize[n + 2])]
// pub fn test3(n: usize) -&gt; usize {
//     checked_add(n, 1)
//         .and_then(|m| Some(m + 1))
//         .expect("overflow")
// }

// #[flux::trusted]
// #[flux::sig(fn(n:usize, m:usize) -&gt; Option&lt;usize[n + m]&gt;)]
// pub fn checked_add(n: usize, m: usize) -&gt; Option&lt;usize&gt; {
//     n.checked_add(m)
// }</code></pre>
<pre><code class="language-rust noplayground">#[path = "../../lib/rvec.rs"]
mod rvec;
use rvec::RVec;

#[flux::trusted]
fn smap&lt;S, F, A, B&gt;(s: S, v: Vec&lt;A&gt;, f: F) -&gt; Vec&lt;B&gt;
where
    F: Fn(S, A) -&gt; B,
    S: Copy,
{
    v.into_iter().map(|x| f(s, x)).collect()
}

#[flux::sig(fn(vs: Vec&lt;i32{v:0&lt;=v}&gt;) -&gt; Vec&lt;i32{v:3&lt;=v}&gt;)]
pub fn test1_old(vs: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    let st = 3;
    smap(st, vs, |s, x| s + x)
}

#[flux::sig(fn(vs: Option&lt;i32{v:0&lt;=v}&gt;) -&gt; Option&lt;i32{v:3&lt;=v}&gt;)]
pub fn test2_old(vs: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    let y = 1;
    let z = 2;
    vs.map(|x| x + y + z)
}

pub struct Foo {
    #[flux::field(i32{v: 10 &lt;= v})]
    pub val: i32,
}

pub fn test1(c: Option&lt;bool&gt;) -&gt; Option&lt;Foo&gt; {
    let x = 6;
    let y = 10;
    c.map(|b| if b { Foo { val: x + y } } else { Foo { val: 20 } })
}

#[flux::sig(fn(vec:&amp;RVec&lt;i32{v: 10 &lt;= v}&gt;{v: 0 &lt; v}) -&gt; Foo)]
fn bob(vec: &amp;RVec&lt;i32&gt;) -&gt; Foo {
    Foo { val: vec[0] }
}

pub fn test2(c: Option&lt;bool&gt;) -&gt; Option&lt;Foo&gt; {
    let vec = rvec![100, 200, 300];
    c.map(|b| if b { bob(&amp;vec) } else { Foo { val: 20 } })
}

#[flux::trusted]
fn frob(_vec: &amp;RVec&lt;RVec&lt;i32&gt;&gt;) -&gt; Foo {
    todo!()
}

pub fn test3(c: Option&lt;bool&gt;, vec: RVec&lt;RVec&lt;i32&gt;&gt;) -&gt; Option&lt;Foo&gt; {
    // let mut vec = rvec![rvec![100, 200, 300]];
    c.map(|b| if b { frob(&amp;vec) } else { Foo { val: 20 } })
}</code></pre>
<h2 id="function-pointers"><a class="header" href="#function-pointers">Function Pointers</a></h2>
<pre><code class="language-rust noplayground">#![allow(unused)]

#[flux::sig(fn (x:usize) -&gt; usize[x+1])]
fn inc(x: usize) -&gt; usize {
    x + 1
}

#[flux::sig(fn(c: Option&lt;usize[99]&gt;) -&gt; Option&lt;usize[100]&gt;)]
pub fn test_ok(c: Option&lt;usize&gt;) -&gt; Option&lt;usize&gt; {
    c.map(inc)
}</code></pre>
<pre><code class="language-rust noplayground">#![allow(unused)]

fn id&lt;T&gt;(x: T) -&gt; T {
    x
}

#[flux::sig(fn(c: Option&lt;usize[99]&gt;) -&gt; Option&lt;usize[99]&gt;)]
pub fn test_ok(c: Option&lt;usize&gt;) -&gt; Option&lt;usize&gt; {
    c.map(id)
}

#[flux::sig(fn(Option&lt;i32[99]&gt;) -&gt; Option&lt;i32[99]&gt;)]
fn test_also_ok(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    let f = id;
    x.map(f)
}</code></pre>
<pre><code class="language-rust noplayground">use flux_rs::*;

#[sig(fn(x: i32{x != 0}) -&gt; i32[1/x])]
fn div(x: i32) -&gt; i32 {
    1 / x
}

fn apply&lt;A, B&gt;(f: impl FnOnce(A) -&gt; B, x: A) -&gt; B {
    f(x)
}

#[sig(fn() -&gt; i32[0])]
fn test() -&gt; i32 {
    apply(div, 10)
}</code></pre>
<h2 id="traits-and-implementations"><a class="header" href="#traits-and-implementations">Traits and Implementations</a></h2>
<pre><code class="language-rust noplayground">pub trait MyTrait {
    fn foo() -&gt; i32;
    fn bar();
}

pub struct MyTy;

impl MyTrait for MyTy {
    #[flux::sig(fn () -&gt; i32[10])]
    fn foo() -&gt; i32 {
        10
    }

    fn bar() {}
}

#[flux::sig(fn () -&gt; i32[10])]
pub fn test() -&gt; i32 {
    let n = MyTy::foo();
    MyTy::bar();
    n
}</code></pre>
<pre><code class="language-rust noplayground">pub trait Mono {
    #[flux::sig(fn (zing: &amp;strg i32[@n]) ensures zing: i32{v:n &lt; v})]
    fn foo(z: &amp;mut i32);
}

pub struct Tiger;

impl Mono for Tiger {
    #[flux::sig(fn (pig: &amp;strg i32[@m]) ensures pig: i32{v:m &lt; v})]
    fn foo(pig: &amp;mut i32) {
        *pig += 1;
    }
}

pub struct Snake;

impl Mono for Snake {
    #[flux::sig(fn (pig: &amp;strg i32[@m]) ensures pig: i32[m+1])]
    fn foo(pig: &amp;mut i32) {
        *pig += 1;
    }
}</code></pre>
<pre><code class="language-rust noplayground">pub trait Mono {
    #[flux::sig(fn (zing: &amp;strg i32[@n])
                  requires 100 &lt; n
                  ensures zing: i32{v:n &lt; v})]
    fn foo(z: &amp;mut i32);
}

pub struct Tiger;

impl Mono for Tiger {
    #[flux::sig(fn (pig: &amp;strg i32[@m])
                  requires 0 &lt; m
                  ensures pig: i32{v:m &lt; v})]
    fn foo(pig: &amp;mut i32) {
        *pig += 1;
    }
}

pub struct Snake;

impl Mono for Snake {
    #[flux::sig(fn (pig: &amp;strg {i32[@m] | 0 &lt; m})
                ensures pig: i32[m+1])]
    fn foo(pig: &amp;mut i32) {
        *pig += 1;
    }
}</code></pre>
<pre><code class="language-rust noplayground">pub trait MyTrait {
    #[flux::sig(fn[hrn p: Self -&gt; bool](&amp;Self{v: p(v)}) -&gt; Self{v: p(v)})]
    fn foo1(&amp;self) -&gt; Self;

    fn foo2(&amp;self) -&gt; Self;
}

impl MyTrait for i32 {
    // TODO: error-message when below is missing (currently: fixpoint crash!) see tests/tests/todo/trait13.rs
    #[flux::sig(fn[hrn p: Self -&gt; bool](&amp;Self{v: p(v)}) -&gt; Self{v: p(v)})]
    fn foo1(&amp;self) -&gt; Self {
        *self
    }

    #[flux::sig(fn[hrn q: Self -&gt; bool](&amp;Self{v: q(v)}) -&gt; Self{v: q(v)})]
    fn foo2(&amp;self) -&gt; Self {
        *self
    }
}

#[flux::sig(fn[hrn q: T -&gt; bool](&amp;T{v:q(v)}) -&gt; T{v: q(v)})]
pub fn bar1&lt;T: MyTrait&gt;(x: &amp;T) -&gt; T {
    x.foo1()
}

#[flux::sig(fn(bool[true]))]
fn assert(_b: bool) {}

pub fn test() {
    let x = 42;
    assert(bar1(&amp;x) == 42);
    assert(x.foo2() == 42);
}</code></pre>
<pre><code class="language-rust noplayground">pub trait Silly&lt;A&gt; {
    #[flux::sig(fn(&amp;Self, z: A) -&gt; i32{v:100 &lt; v})]
    fn bloop(&amp;self, z: A) -&gt; i32;
}

impl Silly&lt;bool&gt; for i32 {
    #[flux::sig(fn(&amp;Self, b : bool) -&gt; i32[2000])]
    fn bloop(&amp;self, _b: bool) -&gt; i32 {
        2000
    }
}

#[flux::sig(fn(i32) -&gt; i32{v: 100 &lt; v})]
pub fn client(x: i32) -&gt; i32 {
    let y = x.bloop(true);
    y + 1
}

#[flux::sig(fn(_, _) -&gt; i32{v:100 &lt; v})]
pub fn client2&lt;A, B: Silly&lt;A&gt;&gt;(x: B, y: A) -&gt; i32 {
    x.bloop(y)
}</code></pre>
<h2 id="impl-trait"><a class="header" href="#impl-trait">Impl Trait</a></h2>
<pre><code class="language-rust noplayground">pub fn test1() -&gt; impl Iterator&lt;Item = i32&gt; {
    Some(10).into_iter()
}

#[flux::sig(fn () -&gt; impl Iterator&lt;Item = i32{v:1&lt;=v}&gt;)]
pub fn test2() -&gt; impl Iterator&lt;Item = i32&gt; {
    Some(10).into_iter()
}

#[flux::sig(fn () -&gt; impl Iterator&lt;Item = i32{v:1&lt;=v}&gt;)]
pub fn test_lib() -&gt; impl Iterator&lt;Item = i32&gt; {
    Some(10).into_iter()
}

#[flux::sig(fn () -&gt; Option&lt;i32{v:0&lt;=v}&gt;)]
pub fn test_client() -&gt; Option&lt;i32&gt; {
    let mut it = test_lib();
    it.next()
}</code></pre>
<pre><code class="language-rust noplayground">#[flux::sig(fn (x:i32) -&gt; impl Iterator&lt;Item = i32{v:x&lt;=v}&gt;)]
pub fn lib(x: i32) -&gt; impl Iterator&lt;Item = i32&gt; {
    Some(x).into_iter()
}

#[flux::sig(fn (k:i32) -&gt; Option&lt;i32{v:k&lt;=v}&gt;)]
pub fn test_client(k: i32) -&gt; Option&lt;i32&gt; {
    let mut it = lib(k);
    it.next()
}</code></pre>
<h2 id="dynamic-trait-objects"><a class="header" href="#dynamic-trait-objects">Dynamic Trait Objects</a></h2>
<pre><code class="language-rust noplayground">#![allow(unused)]

// ------------------------------------------------------

trait Shape {
    #[flux::sig(fn(self: _) -&gt; i32{v: 0 &lt;= v})]
    fn vertices(&amp;self) -&gt; i32;
}

// ------------------------------------------------------

struct Circle {}

impl Shape for Circle {
    #[flux::sig(fn(self: _) -&gt; i32{v: 0 &lt;= v})]
    fn vertices(&amp;self) -&gt; i32 {
        0
    }
}

// ------------------------------------------------------

#[flux::sig(fn(shape: _) -&gt; i32{v: 0 &lt;= v})]
fn count(shape: &amp;dyn Shape) -&gt; i32 {
    shape.vertices()
}

#[flux::sig(fn(shape: _) -&gt; i32{v: 10 &lt;= v})]
fn count_bad(shape: &amp;dyn Shape) -&gt; i32 {
    shape.vertices() //~ ERROR: refinement type
}

fn main() {
    let c = Circle {};
    count(&amp;c);
    count_bad(&amp;c);
}</code></pre>
<h2 id="generic-refinements"><a class="header" href="#generic-refinements">Generic Refinements</a></h2>
<p><code>flux</code> supports <em>generic refinements</em> see <a href="https://dl.acm.org/doi/10.1145/3704885">this paper for details</a></p>
<p><strong>Horn Refinements</strong></p>
<pre><code class="language-rust noplayground">// Define a function whose type uses the Horn generic refinement `p`
#[flux::sig(
    fn[hrn p: int -&gt; bool](x: i32, y: i32) -&gt; i32{v: p(v) &amp;&amp; v &gt;= x &amp;&amp; v &gt;= y}
    requires p(x) &amp;&amp; p(y)
)]
fn max(x: i32, y: i32) -&gt; i32 {
    if x &gt; y { x } else { y }
}

// A client of `max` where the generic is instantiated to `|v| {v % 2 == 0}`
#[flux::sig(fn() -&gt; i32{v: v % 2 == 0})]
pub fn test00() -&gt; i32 {
    max(4, 10)
}

// A client of `max` where the generic is instantiated to `|v| {v == 4 || v == 10}`
#[flux::sig(fn() -&gt; i32[10])]
pub fn test01() -&gt; i32 {
    max(4, 10)
}</code></pre>
<pre><code class="language-rust noplayground">#[flux::refined_by(a: int, b: int, hrn p: (int, int) -&gt; bool)]
struct Pair {
    #[flux::field(i32[a])]
    fst: i32,
    #[flux::field({i32[b] | p(a, b)})]
    snd: i32,
}

#[flux::sig(fn() -&gt; Pair)]
fn test00() -&gt; Pair {
    Pair { fst: 0, snd: 1 }
}

#[flux::sig(fn(Pair[@a, @b, |a, b| a &lt; b]) -&gt; i32{v: v &gt; 0})]
fn test01(pair: Pair) -&gt; i32 {
    pair.snd - pair.fst
}

fn test02() {
    let pair = Pair { fst: 0, snd: 1 };
    let x = test01(pair);
}

#[flux::sig(fn(x: i32, Pair[@a, @b, |a, b| a &gt; x]) -&gt; i32{v: v &gt; x})]
fn test03(x: i32, pair: Pair) -&gt; i32 {
    pair.fst
}

fn test04() {
    let pair = Pair { fst: 10, snd: 0 };
    test03(0, pair);
}</code></pre>
<pre><code class="language-rust noplayground">#[derive(Clone, Copy)]
#[flux::refined_by(hrn p: int -&gt; bool)]
pub struct S;

#[flux::sig(fn(x: i32) -&gt; S[|y| y &gt; x])]
pub fn gt(x: i32) -&gt; S {
    S
}

#[flux::sig(fn(x: i32) -&gt; S[|y| y &lt; x])]
pub fn lt(x: i32) -&gt; S {
    S
}

#[flux::sig(fn(S[@p1], S[@p2]) -&gt; S[|x| p1(x) || p2(x)])]
pub fn or(_: S, _: S) -&gt; S {
    S
}

#[flux::sig(fn(S[@p], x: i32{ p(x) }))]
pub fn check(_: S, x: i32) {}

pub fn test() {
    let s = or(gt(10), lt(0));
    check(s, 11);
    check(s, -1);
}</code></pre>
<p><strong>Hindley Refinements</strong></p>
<p>TODO</p>
<h2 id="bitvector-refinements"><a class="header" href="#bitvector-refinements">Bitvector Refinements</a></h2>
<h3 id="operators"><a class="header" href="#operators">Operators</a></h3>
<pre><code class="language-rust noplayground">// https://github.com/flux-rs/flux/issues/1010

use flux_rs::{attrs::*, bitvec::BV32};

#[sig(fn (x:BV32{x == 1}) ensures (bv_shl(x, 3) == 8))]
pub fn test_shl_a(_x: BV32) {}

#[sig(fn (x:BV32{x == 1}) ensures (x &lt;&lt; 3 == 8))]
pub fn test_shl_b(_x: BV32) {}

#[sig(fn (x:BV32{x == 8}) ensures (bv_lshr(x, 3) == 1))]
pub fn test_shr_a(_x: BV32) {}

#[sig(fn (x:BV32{x == 8}) ensures (x &gt;&gt; 3 == 1))]
pub fn test_shr_b(_x: BV32) {}

#[sig(fn (x:BV32{x == 8}) ensures (bv_or(x, 3) == 11))]
pub fn test_or_a(_x: BV32) {}

#[sig(fn (x:BV32{x == 8}) ensures (x | 3 == 11))]
pub fn test_or_b(_x: BV32) {}

#[sig(fn (x:BV32{x == 10}) ensures (bv_and(x, 3) == 2))]
pub fn test_and_a(_x: BV32) {}

#[sig(fn (x:BV32{x == 10}) ensures (x &amp; 3 == 2))]
pub fn test_and_b(_x: BV32) {}</code></pre>
<pre><code class="language-rust noplayground">use flux_rs::{attrs::*, bitvec::BV32};

#[sig(fn(x: BV32) -&gt; BV32[bv_add(x, bv_int_to_bv32(1))])]
pub fn test_00(x: BV32) -&gt; BV32 {
    x + BV32::new(1)
}

#[sig(fn(x: BV32) -&gt; BV32[x + bv_int_to_bv32(1)])]
pub fn test_01(x: BV32) -&gt; BV32 {
    x + BV32::new(1)
}

#[sig(fn(x: BV32) -&gt; BV32[x + 1])]
pub fn test_02(x: BV32) -&gt; BV32 {
    x + BV32::new(1)
}

#[sig(fn(x: i32) -&gt; i32[x + (1 + 2)])]
pub fn test_03(x: i32) -&gt; i32 {
    x + 3
}

#[sig(fn() -&gt; BV32[bv_int_to_bv32(0x5)])]
pub fn test_04() -&gt; BV32 {
    BV32::new(0x5)
}

#[sig(fn() -&gt; BV32[5])]
pub fn test_05() -&gt; BV32 {
    BV32::new(0x5)
}

#[sig(fn(x: BV32, y:BV32) -&gt; bool[x + y &gt; 5])]
pub fn test_06(x: BV32, y: BV32) -&gt; bool {
    x + y &gt; BV32::new(5)
}

#[sig(fn(x: BV32, y:BV32) -&gt; bool[x + y &gt; x - y])]
pub fn test_07(x: BV32, y: BV32) -&gt; bool {
    x + y &gt; x - y
}</code></pre>
<pre><code class="language-rust noplayground">extern crate flux_core;

use std::ops::{Add, Sub};

#[flux::opaque]
#[flux::refined_by(x: bitvec&lt;32&gt;)]
pub struct BV32(u32);

impl BV32 {
    #[flux::trusted]
    #[flux::sig(fn (u32[@x]) -&gt; BV32[bv_int_to_bv32(x)])]
    pub fn new(x: u32) -&gt; Self {
        BV32(x)
    }
}

impl Add for BV32 {
    type Output = BV32;

    #[flux_rs::trusted]
    #[flux_rs::sig(fn (BV32[@val1], BV32[@val2]) -&gt; BV32[bv_add(val1, val2)])]
    fn add(self, rhs: Self) -&gt; BV32 {
        BV32(self.0 + rhs.0)
    }
}

impl Sub for BV32 {
    type Output = BV32;

    #[flux_rs::trusted]
    #[flux_rs::sig(fn (BV32[@val1], BV32[@val2]) -&gt; BV32[bv_sub(val1, val2)])]
    fn sub(self, rhs: Self) -&gt; BV32 {
        BV32(self.0.wrapping_add(!rhs.0))
    }
}

impl PartialEq for BV32 {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        self.0 == other.0
    }
}
flux_core::eq!(
    #[trusted]
    BV32
);

impl PartialOrd for BV32 {
    #[flux::trusted]
    fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;std::cmp::Ordering&gt; {
        self.0.partial_cmp(&amp;other.0)
    }

    #[flux::trusted]
    #[flux::sig(fn (&amp;BV32[@x], &amp;BV32[@y]) -&gt; bool[bv_ule(x, y)])]
    fn le(&amp;self, other: &amp;Self) -&gt; bool {
        self.0 &lt;= other.0
    }

    #[flux::trusted]
    #[flux::sig(fn (&amp;BV32[@x], &amp;BV32[@y]) -&gt; bool[bv_ult(x, y)])]
    fn lt(&amp;self, other: &amp;Self) -&gt; bool {
        self.0 &lt; other.0
    }

    #[flux::trusted]
    #[flux::sig(fn (&amp;BV32[@x], &amp;BV32[@y]) -&gt; bool[bv_uge(x, y)])]
    fn ge(&amp;self, other: &amp;Self) -&gt; bool {
        self.0 &gt;= other.0
    }

    #[flux::trusted]
    #[flux::sig(fn (&amp;BV32[@x], &amp;BV32[@y]) -&gt; bool[bv_ugt(x, y)])]
    fn gt(&amp;self, other: &amp;Self) -&gt; bool {
        self.0 &gt; other.0
    }
}

#[flux::sig(fn (BV32[@x]) -&gt; bool[bv_ule(x, x)])]
pub fn trivial_le(x: BV32) -&gt; bool {
    x &lt;= x
}

#[flux::sig(fn (BV32[@x]) -&gt; bool[bv_ult(x, x)])]
pub fn trivial_lt(x: BV32) -&gt; bool {
    x &lt; x
}

#[flux::sig(fn (BV32[@x]) -&gt; bool[bv_uge(x, x)])]
pub fn trivial_ge(x: BV32) -&gt; bool {
    x &lt;= x
}

#[flux::sig(fn (BV32[@x]) -&gt; bool[bv_ugt(x, x)])]
pub fn trivial_gt(x: BV32) -&gt; bool {
    x &lt; x
}

#[flux::sig(fn (BV32[@x], BV32[@y]) -&gt; bool[
    bv_ule(x, bv_int_to_bv32(10))
    &amp;&amp;
    bv_uge(y, bv_int_to_bv32(20))
    &amp;&amp;
    bv_ult(x, bv_int_to_bv32(11))
    &amp;&amp;
    bv_ugt(y, bv_int_to_bv32(21))
])]
pub fn real_example(x: BV32, y: BV32) -&gt; bool {
    x &lt;= BV32::new(10) &amp;&amp; y &gt;= BV32::new(20) &amp;&amp; x &lt; BV32::new(11) &amp;&amp; y &gt; BV32::new(21)
}

#[flux_rs::sig(fn (BV32[@x], BV32[@y]) -&gt; bool[true] requires bv_ult(x, y) &amp;&amp; bv_ugt(x, bv_int_to_bv32(0x20)) &amp;&amp; bv_ult(y, bv_int_to_bv32(0xFF)))]
pub fn lt_imp(x: BV32, y: BV32) -&gt; bool {
    x - BV32::new(0x20) &lt; y + BV32::new(0x20)
}

#[flux_rs::sig(fn (BV32[@x], BV32[@y]) -&gt; bool[true] requires bv_ule(x, y) &amp;&amp; bv_uge(x, bv_int_to_bv32(0x20)) &amp;&amp; bv_ule(y, bv_int_to_bv32(0xFF)))]
pub fn le_imp(x: BV32, y: BV32) -&gt; bool {
    x - BV32::new(0x20) &lt;= y + BV32::new(0x20)
}

#[flux_rs::sig(fn (BV32[@x], BV32[@y]) -&gt; bool[true] requires bv_ugt(x, y) &amp;&amp; bv_ugt(y, bv_int_to_bv32(0x20)) &amp;&amp; bv_ult(x, bv_int_to_bv32(0xFF)))]
pub fn gt_imp(x: BV32, y: BV32) -&gt; bool {
    x + BV32::new(0x20) &gt; y - BV32::new(0x20)
}

#[flux_rs::sig(fn (BV32[@x], BV32[@y]) -&gt; bool[true] requires bv_uge(x, y) &amp;&amp; bv_uge(y, bv_int_to_bv32(0x20)) &amp;&amp; bv_ule(x, bv_int_to_bv32(0xFF)))]
pub fn ge_imp(x: BV32, y: BV32) -&gt; bool {
    x + BV32::new(0x20) &gt;= y - BV32::new(0x20)
}</code></pre>
<h3 id="specification-functions"><a class="header" href="#specification-functions">Specification functions</a></h3>
<pre><code class="language-rust noplayground">use flux_rs::{attrs::*, bitvec::BV32};

defs! {
    fn is_pow2(x: bitvec&lt;32&gt;) -&gt; bool {
        (x &gt; 0) &amp;&amp; ((x &amp; x - 1) == 0)
    }
}

#[sig(fn(x: BV32) requires is_pow2(x) &amp;&amp; 8 &lt;= x ensures x % 8 == 0)]
fn theorem_pow2_octet(x: BV32) {}</code></pre>
<h3 id="extensions"><a class="header" href="#extensions">Extensions</a></h3>
<pre><code class="language-rust noplayground">// https://github.com/flux-rs/flux/issues/686

#[allow(dead_code)]
#[flux::sig(fn(x: bool[true]))]
pub fn assert(_x: bool) {}

#[flux::opaque]
#[flux::refined_by(v: bitvec&lt;32&gt;)]
struct Register {
    inner: u32,
}

impl Register {
    #[flux::sig(fn(u32[@n]) -&gt; Register[bv_int_to_bv32(n)])]
    #[flux::trusted]
    fn new(v: u32) -&gt; Self {
        Register { inner: v }
    }

    #[flux::sig(fn(&amp;Register[@n]) -&gt; u64[bv_bv64_to_int(bv_zero_extend_32_to_64(n))])]
    #[flux::trusted]
    fn zero_extend(&amp;self) -&gt; u64 {
        self.inner as u64
    }

    #[flux::sig(fn(&amp;Register[@n]) -&gt; u64[bv_bv64_to_int(bv_sign_extend_32_to_64(n))])]
    #[flux::trusted]
    fn sign_extend(&amp;self) -&gt; u64 {
        self.inner as i32 as i64 as u64
    }
}

pub fn test_bv_extensions() {
    let r = Register::new(u32::MAX);
    assert(r.zero_extend() == u32::MAX as u64);
    assert(r.zero_extend() == 12); //~ ERROR refinement type
    assert(r.sign_extend() == u64::MAX);
    assert(r.sign_extend() == 12); //~ ERROR refinement type
}</code></pre>
<h3 id="bitvector-constants"><a class="header" href="#bitvector-constants">Bitvector Constants</a></h3>
<pre><code class="language-rust noplayground">#![flux::defs(
    fn is_start(x:bitvec&lt;32&gt;) -&gt; bool { x == START }
)]

#[flux::opaque]
#[flux::refined_by(val: bitvec&lt;32&gt;)]
pub struct BV32(u32);

impl BV32 {
    #[flux::trusted]
    #[flux::sig(fn (x:u32) -&gt; BV32[bv_int_to_bv32(x)])]
    const fn new(val: u32) -&gt; Self {
        BV32(val)
    }
}

#[flux_rs::constant(bv_int_to_bv32(0x4567))]
pub const START: BV32 = BV32::new(0x4567);

#[flux_rs::sig(fn () -&gt; BV32[START])]
pub fn test1() -&gt; BV32 {
    BV32::new(0x4567)
}

#[flux_rs::sig(fn () -&gt; BV32{v: is_start(v)})]
pub fn test2() -&gt; BV32 {
    BV32::new(0x4567)
}

#[flux_rs::sig(fn () -&gt; BV32{v: is_start(v)})]
pub fn test3() -&gt; BV32 {
    BV32::new(0x4568) //~ ERROR: refinement type
}</code></pre>
<h2 id="char-literals"><a class="header" href="#char-literals"><code>char</code> Literals</a></h2>
<pre><code class="language-rust noplayground">#[flux::sig(fn() -&gt; char['a'])]
pub fn char00() -&gt; char {
    'a'
}

#[flux::sig(fn(c: char{v: 'a' &lt;= v &amp;&amp; v &lt;= 'z'}) -&gt; bool[true])]
pub fn lowercase(c: char) -&gt; bool {
    'c' == 'c'
}</code></pre>
<h2 id="string-literals"><a class="header" href="#string-literals"><code>String</code> Literals</a></h2>
<pre><code class="language-rust noplayground">#[flux::sig(fn (&amp;str["cat"]))]
fn require_cat(_x: &amp;str) {}

pub fn test_cat() {
    require_cat("cat");
    require_cat("dog"); //~ ERROR refinement type
}

#[flux::sig(fn (&amp;str[@a], &amp;{str[@b] | a == b}))]
fn require_eq(_x: &amp;str, _y: &amp;str) {}

pub fn test_eq() {
    require_eq("a", "a");
    require_eq("a", "b"); //~ ERROR refinement type
}</code></pre>
<h2 id="extern-specs"><a class="header" href="#extern-specs">Extern Specs</a></h2>
<p>Sometimes you may want to refine a struct or function that outside your code. We
refer to such a specification as an "extern spec," which is short for "external
specification."</p>
<p>Currently, Flux supports extern specs for functions, structs, enums, traits and impls.
The support is a bit rudimentary. For example, multiple impls for a struct (such as <code>&amp;[T]</code>
and <code>[T]</code>) may conflict, and extern specs for structs only support opaque refinements.</p>
<p>Extern specs are given using <code>extern_spec</code> attribute macro, which is provided
by the procedural macros package <code>flux_rs</code>.</p>
<pre><code>use flux_rs::extern_spec;
</code></pre>
<p>The <code>extern_spec</code> is used to provide <code>flux</code> signatures for functions defined in <em>external</em> crates. See the <a href="guide/specs.html">specifications guide</a> for more details.</p>
<h3 id="extern-functions"><a class="header" href="#extern-functions">Extern Functions</a></h3>
<p>An example of refining an extern function can be found
<a href="https://github.com/flux-rs/flux/blob/d49a74dc59b2b9bb1dda01ee019d0ab9a66cdd89/flux-tests/tests/pos/surface/extern_spec_macro.rs">here</a>.</p>
<p>To define an extern spec on a function, you need to do three things, which
happen to correspond to each of the below lines.</p>
<pre><code class="language-rust noplayground">#[extern_spec(std::mem)]
#[spec(fn(x: &amp;mut T[@vx], y: &amp;mut T[@vy]) ensures x: T[vy], y: T[vx])]
fn swap&lt;T&gt;(a: &amp;mut T, b: &amp;mut T);</code></pre>
<ol>
<li>Add the <code>#[extern_spec]</code> attribute. This attribute optionally takes a path;
in the above example, this is <code>std::mem</code>. You can use this path to qualify
the function. So in the above example, the function we are targeting has the
full path of <code>std::mem::swap</code>.</li>
<li>Add a <code>#[spec(...)]</code> (or equivalently <code>#[flux_rs::sig(...)]</code>) attribute, which
is required for any extern spec on a function. This signature behaves as if
the <code>#[flux_rs::trusted]</code> attribute was added, because we cannot <em>actually</em>
check the implementation. Instead, flux just verifies some simple things,
like that the function arguments have compatible types.</li>
<li>Write a function stub whose rust signature matches the external function.</li>
</ol>
<p>If you do the above, you can use <code>std::mem::swap</code> as if it were refined by the
above type.</p>
<p>Here are two examples:</p>
<pre><code class="language-rust noplayground">pub fn test_swap() {
    let mut x = 5;
    let mut y = 10;
    swap(&amp;mut x, &amp;mut y); // actually calls `std::mem::swap`
    assert(x == 10); // verified by flux
    assert(y == 5); // verified by flux
    assert(y == 10); //~ ERROR refinement type
}</code></pre>
<pre><code class="language-rust noplayground">use std::slice::from_ref;

use flux_rs::extern_spec;

#[extern_spec]
#[flux::sig(fn(&amp;T) -&gt; &amp;[T][1])]
fn from_ref&lt;T&gt;(s: &amp;T) -&gt; &amp;[T];

#[flux::sig(fn(&amp;i32) -&gt; &amp;[i32]{n: n &gt; 0})]
pub fn test(x: &amp;i32) -&gt; &amp;[i32] {
    from_ref(x)
}</code></pre>
<h3 id="options"><a class="header" href="#options">Options</a></h3>
<pre><code class="language-rust noplayground">use flux_attrs::*;

#[extern_spec]
#[refined_by(is_some: bool)]
enum Option&lt;T&gt; {
    #[variant(Option&lt;T&gt;[false])]
    None,
    #[variant((T) -&gt; Option&lt;T&gt;[true])]
    Some(T),
}

#[extern_spec]
impl&lt;T&gt; Option&lt;T&gt; {
    #[sig(fn(&amp;Self[@b]) -&gt; bool[b])]
    const fn is_some(&amp;self) -&gt; bool;

    #[sig(fn(&amp;Self[@b]) -&gt; bool[!b])]
    const fn is_none(&amp;self) -&gt; bool;

    #[no_panic]
    #[sig(fn(Option&lt;T&gt;[true]) -&gt; T)]
    const fn unwrap(self) -&gt; T;

    #[sig(fn(&amp;Self[@b]) -&gt; Option&lt;&amp;T&gt;[b])]
    fn as_ref(&amp;self) -&gt; Option&lt;&amp;T&gt;;

    #[sig(fn(&amp;mut Self[@b]) -&gt; Option&lt;&amp;mut T&gt;[b])]
    fn as_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt;;

    #[sig(fn(&amp;Self[@b]) -&gt; &amp;[T][if b { 1 } else { 0 }])]
    fn as_slice(&amp;self) -&gt; &amp;[T];

    #[sig(fn(&amp;mut Self[@b]) -&gt; &amp;mut [T][if b { 1 } else { 0 }])]
    fn as_mut_slice(&amp;mut self) -&gt; &amp;mut [T];
}</code></pre>
<pre><code class="language-rust noplayground">use flux_rs::{assert, attrs::*};

extern crate flux_core;

#[flux::trusted]
#[spec(fn(i32{v: false}) -&gt; T)]
pub fn never&lt;T&gt;(_: i32) -&gt; T {
    loop {}
}

#[spec(fn(x:Option&lt;T&gt;[true]) -&gt; T)]
pub fn my_unwrap&lt;T&gt;(x: Option&lt;T&gt;) -&gt; T {
    match x {
        Option::Some(v) =&gt; v,
        Option::None =&gt; never(0),
    }
}

#[spec(fn(T) -&gt; Option&lt;T&gt;[true])]
fn my_some&lt;T&gt;(x: T) -&gt; Option&lt;T&gt; {
    Option::Some(x)
}

pub fn test1() {
    let x = my_some(42);
    let y = my_unwrap(x);
    assert(y == 42);
}

pub fn test3() {
    let x = Option::Some(42);
    let y = my_unwrap(x);
    assert(y == 42);
}

pub fn test_opt_specs() {
    let a = Some(42);
    assert(a.is_some());
    let b: Option&lt;i32&gt; = None;
    assert(b.is_none());
    let c = a.unwrap();
    assert(c == 42);
}

#[spec(fn (numerator: u32, denominator: u32) -&gt; Option&lt;u32[numerator / denominator]&gt;[denominator != 0])]
pub fn safe_div(numerator: u32, denominator: u32) -&gt; Option&lt;u32&gt; {
    if denominator == 0 { None } else { Some(numerator / denominator) }
}

pub fn test_safe_div() {
    let res = safe_div(42, 2).unwrap();
    assert(res == 21);
}</code></pre>
<h3 id="vec"><a class="header" href="#vec">Vec</a></h3>
<pre><code class="language-rust noplayground">use std::{
    alloc::{Allocator, Global},
    ops::{Index, IndexMut},
    slice::SliceIndex,
};

use flux_attrs::*;

//---------------------------------------------------------------------------------------
#[extern_spec]
#[refined_by(len: int)]
#[invariant(0 &lt;= len)]
struct Vec&lt;T, A: Allocator = Global&gt;;

//---------------------------------------------------------------------------------------

#[extern_spec]
impl&lt;T&gt; Vec&lt;T&gt; {
    #[flux::sig(fn() -&gt; Vec&lt;T&gt;[0])]
    fn new() -&gt; Vec&lt;T&gt;;
}

#[extern_spec]
impl&lt;T, A: Allocator&gt; Vec&lt;T, A&gt; {
    #[spec(fn(self: &amp;mut Vec&lt;T, A&gt;[@n], T) ensures self: Vec&lt;T, A&gt;[n+1])]
    fn push(v: &amp;mut Vec&lt;T, A&gt;, value: T);

    #[spec(fn(&amp;Vec&lt;T, A&gt;[@n]) -&gt; usize[n])]
    fn len(v: &amp;Vec&lt;T, A&gt;) -&gt; usize;

    #[spec(fn(self: &amp;mut Vec&lt;T, A&gt;[@n]) -&gt; Option&lt;T&gt;[n &gt; 0] ensures self: Vec&lt;T, A&gt;[if n &gt; 0 { n-1 } else { 0 }])]
    fn pop(&amp;mut self) -&gt; Option&lt;T&gt;;

    #[spec(fn(self: &amp;Vec&lt;T, A&gt;[@n]) -&gt; bool[n == 0])]
    fn is_empty(&amp;self) -&gt; bool;
}

//---------------------------------------------------------------------------------------

#[extern_spec]
impl&lt;T, I: SliceIndex&lt;[T]&gt;, A: Allocator&gt; Index&lt;I&gt; for Vec&lt;T, A&gt; {
    #[spec(fn(&amp;Vec&lt;T, A&gt;[@len], {I[@idx] | &lt;I as SliceIndex&lt;[T]&gt;&gt;::in_bounds(idx, len)}) -&gt; _)]
    fn index(z: &amp;Vec&lt;T, A&gt;, index: I) -&gt; &amp;&lt;I as SliceIndex&lt;[T]&gt;&gt;::Output;
}

#[extern_spec]
impl&lt;T, I: SliceIndex&lt;[T]&gt;, A: Allocator&gt; IndexMut&lt;I&gt; for Vec&lt;T, A&gt; {
    #[spec(fn(&amp;mut Vec&lt;T,A&gt;[@len], {I[@idx] | &lt;I as SliceIndex&lt;[T]&gt;&gt;::in_bounds(idx, len)}) -&gt; _)]
    fn index_mut(z: &amp;mut Vec&lt;T, A&gt;, index: I) -&gt; &amp;mut &lt;I as SliceIndex&lt;[T]&gt;&gt;::Output;
}

//---------------------------------------------------------------------------------------
#[extern_spec]
impl&lt;'a, T, A: Allocator&gt; IntoIterator for &amp;'a Vec&lt;T, A&gt; {
    #[spec(fn (&amp;Vec&lt;T, A&gt;[@n]) -&gt; &lt;&amp;Vec&lt;T, A&gt; as IntoIterator&gt;::IntoIter[0,n])]
    fn into_iter(v: &amp;'a Vec&lt;T, A&gt;) -&gt; &lt;&amp;'a Vec&lt;T, A&gt; as IntoIterator&gt;::IntoIter;
}

#[extern_spec]
#[assoc(fn with_size(self: Self, n:int) -&gt; bool { self.len == n })]
impl&lt;T&gt; FromIterator&lt;T&gt; for Vec&lt;T&gt; {}</code></pre>
<h3 id="extern-structs"><a class="header" href="#extern-structs">Extern Structs</a></h3>
<p>Here is an example of refining an extern struct</p>
<pre><code class="language-rust noplayground">use flux_rs::extern_spec;

#[extern_spec(std::string)]
#[flux::refined_by(len: int)]
struct String;

#[flux::sig(fn(String[@n]) requires n == 3)]
fn expect_string_len_3(s: String) {}

#[flux::sig(fn(String[2]))]
fn test_string_len_2(s: String) {
    expect_string_len_3(s); //~ ERROR refinement type
}</code></pre>
<p>Here's a longer example of refining an extern <code>struct</code> as well as an <code>impl</code></p>
<pre><code class="language-rust noplayground">use flux_rs::extern_spec;

#[extern_spec]
#[flux::refined_by(len: int)]
struct String;

#[extern_spec]
impl String {
    #[flux::sig(fn() -&gt; String[0])]
    fn new() -&gt; String;

    #[flux::sig(fn(&amp;String[@n]) -&gt; usize[n])]
    fn len(s: &amp;String) -&gt; usize;

    #[flux::sig(fn(&amp;String[@n]) -&gt; bool[n == 0])]
    fn is_empty(s: &amp;String) -&gt; bool;

    #[flux::sig(fn(s: &amp;mut String[@n], char) ensures s: String[n+1])]
    fn push(s: &amp;mut String, c: char);

    #[flux::sig(fn(s: &amp;mut String[@n]) -&gt; Option&lt;char&gt;
                requires n &gt; 0
                ensures s: String[n-1])]
    fn pop(s: &amp;mut String) -&gt; Option&lt;char&gt;;

    #[flux::sig(fn(&amp;String[@n]) -&gt; &amp;[u8][n])]
    fn as_bytes(s: &amp;String) -&gt; &amp;[u8];
}

#[extern_spec]
impl&lt;T&gt; [T] {
    #[flux::sig(fn(&amp;[T][@n]) -&gt; usize[n])]
    fn len(v: &amp;[T]) -&gt; usize;

    #[flux::sig(fn(&amp;[T][@n]) -&gt; bool[n == 0])]
    fn is_empty(v: &amp;[T]) -&gt; bool;
}

#[flux::sig(fn(bool[@b]) requires b)]
pub fn assert_true(_: bool) {}

pub fn test_string() {
    let mut s = String::new();
    assert_true(s.is_empty());
    assert_true(s.as_bytes().is_empty());
    s.push('h');
    s.push('i');
    assert_true(s.len() == 2);
    s.pop();
    assert_true(s.len() == 1);
    s.pop();
    assert_true(s.is_empty());
    assert_true(s.as_bytes().is_empty());
}</code></pre>
<p>The syntax for an extern spec on a struct is very similar to that for a
function. Once again, each line in the example happens to correspond to a step.</p>
<pre><code>#[extern_spec(std::string)]
#[flux_rs::refined_by(len: int)]
struct String;
</code></pre>
<ol>
<li>Add the <code>#[extern_spec]</code> attribute. This attribute optionally takes a path;
in the above example, this is <code>std::string</code>. You can use this path to qualify
the function. So in the above example, the struct we are targeting has the
full path of <code>std::string::String</code>.</li>
<li>Add a <code>#[flux_rs::refined_by(...)]</code> attribute. This is required for any extern
spec on a struct. Right now these attributes behave as if they were opaque
(<code>#[flux_rs::opaque]</code>), although we may support non-opaque extern structs.</li>
<li>Write a stub for the extern struct.</li>
</ol>
<p>If you do the above, you can use <code>std::string::String</code> as if it were refined by
an integer index.</p>
<p>The syntax for an extern impl is a little different than that for functions or
structs.</p>
<pre><code>#[extern_spec(std::string)]
impl String {
    #[flux_rs::sig(fn() -&gt; String[0])]
    fn new() -&gt; String;

    #[flux_rs::sig(fn(&amp;String[@n]) -&gt; usize[n])]
    fn len(s: &amp;String) -&gt; usize;
}
</code></pre>
<ol>
<li>You still need to add the <code>#[extern_spec]</code> attribute, with the same optional
argument of the path as above.</li>
<li>You need to write out the <code>impl</code> block for the struct you want to refine.
This struct does not need an extern spec, since by refining the <code>impl</code> you're
only refining its methods.</li>
<li>Write an extern spec for each function you wish to refine (this may be a
subset). This is written just like a function extern spec with the caveat
that the <code>self</code> parameter is not presently supported. So for example, instead
of writing <code>fn len(&amp;self) -&gt; usize;</code>, you need to write <code>fn len(s: &amp;String) -&gt; usize;</code>.</li>
</ol>
<p>If you do the above, you can use the above methods of<code>std::string::String</code> as if
they were refined.</p>
<pre><code class="language-rust noplayground">// Testing we can add external specs to "transparent" structs.

use flux_rs::extern_spec;

#[extern_spec(std::ops)]
#[refined_by(start: Idx, end: Idx)]
struct Range&lt;Idx&gt; {
    #[field(Idx[start])]
    start: Idx,
    #[field(Idx[end])]
    end: Idx,
}

#[extern_spec(std::ops)]
impl&lt;Idx: PartialOrd&lt;Idx&gt;&gt; Range&lt;Idx&gt; {
    // This specification is actually unsound for `Idx`s where the `PartialOrd` implementation doesn't
    // match the logical `&lt;`.
    #[sig(fn(&amp;Range&lt;Idx&gt;[@r]) -&gt; bool[!(r.start &lt; r.end)])]
    fn is_empty(&amp;self) -&gt; bool;
}

#[flux::sig(fn(bool[true]))]
fn assert(_: bool) {}

fn test00() {
    let r = 0..1;
    assert(!r.is_empty());
}</code></pre>
<pre><code class="language-rust noplayground">// Extern spec of a type with a lifetime

use std::slice::Iter;

use flux_rs::*;

#[extern_spec]
#[refined_by(len: int)]
struct Iter&lt;'a, T&gt;;

#[extern_spec]
impl&lt;'a, T&gt; Iter&lt;'a, T&gt; {
    #[spec(fn as_slice(&amp;Iter&lt;T&gt;[@n]) -&gt; &amp;[T][n])]
    fn as_slice(v: &amp;Iter&lt;'a, T&gt;) -&gt; &amp;'a [T];
}

#[extern_spec]
impl&lt;T&gt; [T] {
    #[spec(fn iter(&amp;[T][@n]) -&gt; Iter&lt;T&gt;[n])]
    fn iter(v: &amp;[T]) -&gt; Iter&lt;'_, T&gt;;
}

#[spec(fn test00(x: &amp;[i32][@n]) -&gt; &amp;[i32][n])]
fn test00(x: &amp;[i32]) -&gt; &amp;[i32] {
    x.iter().as_slice()
}</code></pre>
<h3 id="extern-impls"><a class="header" href="#extern-impls">Extern Impls</a></h3>
<pre><code class="language-rust noplayground">use flux_rs::extern_spec;

#[extern_spec]
#[flux::refined_by(len: int)]
struct String;

#[extern_spec]
impl String {
    #[flux::sig(fn() -&gt; String[0])]
    fn new() -&gt; String;

    #[flux::sig(fn(&amp;String[@n]) -&gt; usize[n])]
    fn len(s: &amp;String) -&gt; usize;

    #[flux::sig(fn(&amp;String[@n]) -&gt; bool[n == 0])]
    fn is_empty(s: &amp;String) -&gt; bool;

    #[flux::sig(fn(s: &amp;mut String[@n], char) ensures s: String[n+1])]
    fn push(s: &amp;mut String, c: char);

    #[flux::sig(fn(s: &amp;mut String[@n]) -&gt; Option&lt;char&gt;
                requires n &gt; 0
                ensures s: String[n-1])]
    fn pop(s: &amp;mut String) -&gt; Option&lt;char&gt;;

    #[flux::sig(fn(&amp;String[@n]) -&gt; &amp;[u8][n])]
    fn as_bytes(s: &amp;String) -&gt; &amp;[u8];
}

#[extern_spec]
impl&lt;T&gt; [T] {
    #[flux::sig(fn(&amp;[T][@n]) -&gt; usize[n])]
    fn len(v: &amp;[T]) -&gt; usize;

    #[flux::sig(fn(&amp;[T][@n]) -&gt; bool[n == 0])]
    fn is_empty(v: &amp;[T]) -&gt; bool;
}

#[flux::sig(fn(bool[@b]) requires b)]
pub fn assert_true(_: bool) {}

pub fn test_string() {
    let mut s = String::new();
    assert_true(s.is_empty());
    assert_true(s.as_bytes().is_empty());
    s.push('h');
    s.push('i');
    assert_true(s.len() == 2);
    s.pop();
    assert_true(s.len() == 1);
    s.pop();
    assert_true(s.is_empty());
    assert_true(s.as_bytes().is_empty());
}</code></pre>
<pre><code class="language-rust noplayground">//@aux-build:extern_spec_impl01_aux.rs

extern crate extern_spec_impl01_aux;

use extern_spec_impl01_aux::MyTrait;
use flux_rs::extern_spec;

#[extern_spec]
impl&lt;T&gt; MyTrait for Vec&lt;T&gt; {
    #[flux::sig(fn() -&gt; i32[10])]
    fn foo() -&gt; i32;
}

#[flux::sig(fn () -&gt; i32[10])]
pub fn test_ok() -&gt; i32 {
    &lt;Vec&lt;i32&gt; as MyTrait&gt;::foo()
}</code></pre>
<h3 id="extern-traits"><a class="header" href="#extern-traits">Extern Traits</a></h3>
<pre><code class="language-rust noplayground">use flux_rs::*;

#[extern_spec(std::cmp)]
#[assoc(fn eq_rel(lhs: Self, rhs: Rhs) -&gt; bool)]
trait PartialEq&lt;Rhs&gt; {
    #[sig(fn(&amp;Self[@lhs], &amp;Rhs[@rhs]) -&gt; bool[&lt;Self as PartialEq&lt;Rhs&gt;&gt;::eq_rel(lhs, rhs)])]
    fn eq(&amp;self, other: &amp;Rhs) -&gt; bool;
}

#[refined_by(n: int)]
struct MyInt(#[field(i32[n])] i32);

#[assoc(fn eq_rel(lhs: MyInt, rhs: MyInt) -&gt; bool { lhs == rhs })]
impl PartialEq for MyInt {
    #[sig(fn(&amp;Self[@lhs], &amp;MyInt[@rhs]) -&gt; bool[&lt;MyInt as PartialEq&lt;MyInt&gt;&gt;::eq_rel(lhs, rhs)])]
    fn eq(&amp;self, other: &amp;MyInt) -&gt; bool {
        self.0 == other.0
    }
}

#[sig(fn(x: T, y: T) -&gt; bool[&lt;T as PartialEq&lt;T&gt;&gt;::eq_rel(x, y)])]
fn test00&lt;T: PartialEq&gt;(x: T, y: T) -&gt; bool {
    x == y
}

#[sig(fn(x: MyInt, y: MyInt) -&gt; bool[x == y])]
fn test01(x: MyInt, y: MyInt) -&gt; bool {
    test00(x, y)
}</code></pre>
<h3 id="for-loops-with-range-ij"><a class="header" href="#for-loops-with-range-ij"><code>for</code> loops with range <code>i..j</code></a></h3>
<p>To see how <code>flux</code> handles <code>for i in 0..n</code> style loops:</p>
<pre><code class="language-rust noplayground">#![feature(step_trait)]
#![allow(unused)]

extern crate flux_core;

#[flux_rs::sig(fn (bool[true]))]
fn assert(b: bool) {}

fn donald() {
    let n: i32 = 10;
    let mut thing = 0..n;
    let a = thing.next().unwrap();
    assert(a == 0);
    let b = thing.next().unwrap();
    assert(b == 1);
    let c = thing.next().unwrap();
    assert(c == 2);
}

#[flux_rs::sig(fn (n:i32{n == 99}))]
fn goofy(n: i32) {
    let mut thing = 0..n;
    let a0 = thing.end;
    assert(a0 == n);
    while let Some(i) = thing.next() {
        assert(0 &lt;= i);
        assert(i &lt; n);
    }
}

#[flux_rs::sig(fn (n:i32{n == 99}))]
fn mickey(n: i32) {
    for i in 0..n {
        assert(0 &lt;= i);
        assert(i &lt; n);
    }
}

#[flux_rs::trusted]
fn cond() -&gt; bool {
    todo!()
}

fn test(len: i32) {
    if len &gt;= 0 {
        let mut del = 0;
        for i in 0..len {
            assert(del &lt;= i);
            if cond() {
                del += 1;
            }
        }
        assert(del &lt;= len)
    }
}</code></pre>
<h2 id="associated-refinements-1"><a class="header" href="#associated-refinements-1">Associated Refinements</a></h2>
<h3 id="basic"><a class="header" href="#basic">Basic</a></h3>
<pre><code class="language-rust noplayground">#![allow(dead_code)]

use flux_rs::attrs::*;

trait MyTrait {
    #![reft(fn f(x: int) -&gt; int)]
    //
}

struct Add1;

impl MyTrait for Add1 {
    #![reft(fn f(x: int) -&gt; int { x + 1 })]
    //
}

#[sig(fn(x: i32{v: v == &lt;Add1 as MyTrait&gt;::f(0) }))]
fn test00(_x: i32) {}

fn test01() {
    test00(1);
}</code></pre>
<h3 id="check-subtyping-at-impl"><a class="header" href="#check-subtyping-at-impl">Check Subtyping at Impl</a></h3>
<pre><code class="language-rust noplayground">// test that implementations with extra const generics work as expected

use flux_rs::attrs::*;

#[reft(fn p(x: int) -&gt; bool)]
trait MyTrait {
    #[sig(fn() -&gt; i32{ v: &lt;Self as MyTrait&gt;::p(v) })]
    fn method() -&gt; i32;
}

struct MyStruct&lt;const N: i32&gt;;

// This implementation requires proving `x == N =&gt; x &gt;= N`
#[reft(fn p(x: int) -&gt; bool { x &gt;= N })]
impl&lt;const N: i32&gt; MyTrait for MyStruct&lt;N&gt; {
    #[sig(fn() -&gt; i32{v: v == N})]
    fn method() -&gt; i32 {
        N
    }
}</code></pre>
<h3 id="default"><a class="header" href="#default">Default</a></h3>
<pre><code class="language-rust noplayground">use flux_rs::attrs::*;

pub trait MyTrait {
    #![reft(fn f(x: int) -&gt; int { x + 1 })]
    //
}

// -----------------------------------------------------------------------------

pub struct Add1;

// Use the "default" assoc reft for Add1
impl MyTrait for Add1 {}

#[flux::sig(fn() -&gt; i32{v: v == &lt;Add1 as MyTrait&gt;::f(0)})]
pub fn test1_ok() -&gt; i32 {
    1
}

#[flux::sig(fn() -&gt; i32{v: v == &lt;Add1 as MyTrait&gt;::f(0)})]
pub fn test1_fail() -&gt; i32 {
    99 //~ ERROR: refinement type error
}

// -----------------------------------------------------------------------------

pub struct Add2;

// Specify a custom assoc reft for Add2
impl MyTrait for Add2 {
    #![reft(fn f(x: int) -&gt; int { x + 2 })]
    //
}

#[flux::sig(fn() -&gt; i32{v: v == &lt;Add2 as MyTrait&gt;::f(0)})]
pub fn test2() -&gt; i32 {
    2
}</code></pre>
<h3 id="use-in-extern-spec"><a class="header" href="#use-in-extern-spec">Use in Extern Spec</a></h3>
<pre><code class="language-rust noplayground">use flux_rs::*;

#[extern_spec(std::cmp)]
#[assoc(fn eq_rel(lhs: Self, rhs: Rhs) -&gt; bool)]
trait PartialEq&lt;Rhs&gt; {
    #[sig(fn(&amp;Self[@lhs], &amp;Rhs[@rhs]) -&gt; bool[&lt;Self as PartialEq&lt;Rhs&gt;&gt;::eq_rel(lhs, rhs)])]
    fn eq(&amp;self, other: &amp;Rhs) -&gt; bool;
}

#[refined_by(n: int)]
struct MyInt(#[field(i32[n])] i32);

#[assoc(fn eq_rel(lhs: MyInt, rhs: MyInt) -&gt; bool { lhs == rhs })]
impl PartialEq for MyInt {
    #[sig(fn(&amp;Self[@lhs], &amp;MyInt[@rhs]) -&gt; bool[&lt;MyInt as PartialEq&lt;MyInt&gt;&gt;::eq_rel(lhs, rhs)])]
    fn eq(&amp;self, other: &amp;MyInt) -&gt; bool {
        self.0 == other.0
    }
}

#[sig(fn(x: T, y: T) -&gt; bool[&lt;T as PartialEq&lt;T&gt;&gt;::eq_rel(x, y)])]
fn test00&lt;T: PartialEq&gt;(x: T, y: T) -&gt; bool {
    x == y
}

#[sig(fn(x: MyInt, y: MyInt) -&gt; bool[x == y])]
fn test01(x: MyInt, y: MyInt) -&gt; bool {
    test00(x, y)
}</code></pre>
<pre><code class="language-rust noplayground">use std::{
    alloc::{Allocator, Global},
    ops::{Index, IndexMut},
    slice::SliceIndex,
};

use flux_attrs::*;

//---------------------------------------------------------------------------------------
#[extern_spec]
#[refined_by(len: int)]
#[invariant(0 &lt;= len)]
struct Vec&lt;T, A: Allocator = Global&gt;;

//---------------------------------------------------------------------------------------

#[extern_spec]
impl&lt;T&gt; Vec&lt;T&gt; {
    #[flux::sig(fn() -&gt; Vec&lt;T&gt;[0])]
    fn new() -&gt; Vec&lt;T&gt;;
}

#[extern_spec]
impl&lt;T, A: Allocator&gt; Vec&lt;T, A&gt; {
    #[spec(fn(self: &amp;mut Vec&lt;T, A&gt;[@n], T) ensures self: Vec&lt;T, A&gt;[n+1])]
    fn push(v: &amp;mut Vec&lt;T, A&gt;, value: T);

    #[spec(fn(&amp;Vec&lt;T, A&gt;[@n]) -&gt; usize[n])]
    fn len(v: &amp;Vec&lt;T, A&gt;) -&gt; usize;

    #[spec(fn(self: &amp;mut Vec&lt;T, A&gt;[@n]) -&gt; Option&lt;T&gt;[n &gt; 0] ensures self: Vec&lt;T, A&gt;[if n &gt; 0 { n-1 } else { 0 }])]
    fn pop(&amp;mut self) -&gt; Option&lt;T&gt;;

    #[spec(fn(self: &amp;Vec&lt;T, A&gt;[@n]) -&gt; bool[n == 0])]
    fn is_empty(&amp;self) -&gt; bool;
}

//---------------------------------------------------------------------------------------

#[extern_spec]
impl&lt;T, I: SliceIndex&lt;[T]&gt;, A: Allocator&gt; Index&lt;I&gt; for Vec&lt;T, A&gt; {
    #[spec(fn(&amp;Vec&lt;T, A&gt;[@len], {I[@idx] | &lt;I as SliceIndex&lt;[T]&gt;&gt;::in_bounds(idx, len)}) -&gt; _)]
    fn index(z: &amp;Vec&lt;T, A&gt;, index: I) -&gt; &amp;&lt;I as SliceIndex&lt;[T]&gt;&gt;::Output;
}

#[extern_spec]
impl&lt;T, I: SliceIndex&lt;[T]&gt;, A: Allocator&gt; IndexMut&lt;I&gt; for Vec&lt;T, A&gt; {
    #[spec(fn(&amp;mut Vec&lt;T,A&gt;[@len], {I[@idx] | &lt;I as SliceIndex&lt;[T]&gt;&gt;::in_bounds(idx, len)}) -&gt; _)]
    fn index_mut(z: &amp;mut Vec&lt;T, A&gt;, index: I) -&gt; &amp;mut &lt;I as SliceIndex&lt;[T]&gt;&gt;::Output;
}

//---------------------------------------------------------------------------------------
#[extern_spec]
impl&lt;'a, T, A: Allocator&gt; IntoIterator for &amp;'a Vec&lt;T, A&gt; {
    #[spec(fn (&amp;Vec&lt;T, A&gt;[@n]) -&gt; &lt;&amp;Vec&lt;T, A&gt; as IntoIterator&gt;::IntoIter[0,n])]
    fn into_iter(v: &amp;'a Vec&lt;T, A&gt;) -&gt; &lt;&amp;'a Vec&lt;T, A&gt; as IntoIterator&gt;::IntoIter;
}

#[extern_spec]
#[assoc(fn with_size(self: Self, n:int) -&gt; bool { self.len == n })]
impl&lt;T&gt; FromIterator&lt;T&gt; for Vec&lt;T&gt; {}</code></pre>
<pre><code class="language-rust noplayground">mod adapters;
#[cfg(flux)]
mod range;
mod traits;</code></pre>
<pre><code class="language-rust noplayground">#![allow(unused)]
#![feature(allocator_api)]

use std::{iter::Enumerate, slice::Iter};

extern crate flux_alloc;
extern crate flux_core;

#[flux::sig(fn(bool[true]))]
pub fn assert(_b: bool) {}

// Tests
#[flux::sig(fn(slice: &amp;[u8]{n: n &gt; 0}))]
fn test_iter1(slice: &amp;[u8]) {
    let mut iter = slice.iter();
    let next = iter.next();
    assert(next.is_some());
}

#[flux::sig(fn(slice: &amp;[u8]{n: n &gt; 1}))]
fn test_enumerate1(slice: &amp;[u8]) {
    assert(slice.len() &gt; 0);
    let mut enumer = slice.iter().enumerate();

    let next = enumer.next();
    assert(next.is_some());
    let (idx, _) = next.unwrap();
    assert(idx == 0);

    let next_next = enumer.next();
    assert(next_next.is_some());
    let (idx, _) = next_next.unwrap();
    assert(idx == 1);
}

#[flux::sig(fn(&amp;[usize][1]) )]
pub fn test_enumer2(slice: &amp;[usize]) {
    assert(slice.len() == 1);
    let mut enumer = slice.iter().enumerate();

    let next = enumer.next();
    assert(next.is_some());

    let next_next = enumer.next();
    assert(next_next.is_none())
}

#[flux::sig(fn(&amp;[usize][@n]) )]
pub fn test_enumer3(slice: &amp;[usize]) {
    let mut e = slice.iter().enumerate();
    while let Some((idx, _)) = e.next() {
        assert(idx &lt; slice.len())
    }
}

#[flux::sig(fn(&amp;[usize][@n]) )]
pub fn test_enumer4(slice: &amp;[usize]) {
    for (idx, _) in slice.iter().enumerate() {
        assert(idx &lt; slice.len())
    }
}</code></pre>
<h3 id="associated-types"><a class="header" href="#associated-types">Associated Types</a></h3>
<pre><code class="language-rust noplayground">use flux_rs::attrs::*;

trait MyTrait {
    #![reft(fn f(x: int) -&gt; int)]
    //
}

struct Add1;

#[assoc(fn f(x: int) -&gt; int { x + 1 })]
impl MyTrait for Add1 {}

#[sig(fn(x: i32{v: v == &lt;Add1 as MyTrait&gt;::f(0) }))]
fn test00(x: i32) {}

fn test01() {
    test00(0); //~ ERROR refinement type error
}</code></pre>
<pre><code class="language-rust noplayground">// Testing that we properly map generics in trait's default associated refinement
// body into the impl.

use flux_rs::attrs::*;

trait MyTrait {
    #![reft(fn p(x: Self) -&gt; bool { true })]

    #[sig(fn(&amp;Self{v: &lt;Self as MyTrait&gt;::p(v)}))]
    fn method(&amp;self);
}

impl MyTrait for i32 {
    #[sig(fn(&amp;Self{v: &lt;Self as MyTrait&gt;::p(v)}))]
    fn method(&amp;self) {}
}

impl&lt;T&gt; MyTrait for S&lt;T&gt; {
    #[sig(fn(&amp;Self{v: &lt;Self as MyTrait&gt;::p(v)}))]
    fn method(&amp;self) {}
}

struct S&lt;T&gt; {
    f: T,
}</code></pre>
<h3 id="refined-associated-types-1"><a class="header" href="#refined-associated-types-1">Refined Associated Types</a></h3>
<pre><code class="language-rust noplayground">use flux_rs::*;

#[assoc(fn can_fit(self: Self, animal: Self::Animal) -&gt; bool)]
trait Barn {
    type Animal;

    #[sig(fn(self: &amp;mut Self[@barn], animal: Self::Animal{ &lt;Self as Barn&gt;::can_fit(barn, animal) }))]
    fn put_animal_in_house(&amp;mut self, animal: Self::Animal);
}

#[refined_by(size: int)]
struct Horse {
    #[field(i32[size])]
    size: i32,
}

#[refined_by(max_size: int)]
struct HorseBarn {
    #[field(i32[max_size])]
    max_size: i32,
}

#[assoc(fn can_fit(self: HorseBarn, horse: Horse) -&gt; bool { horse.size &lt;= self.max_size })]
impl Barn for HorseBarn {
    type Animal = Horse;

    #[trusted]
    #[sig(fn(self: &amp;mut Self[@barn], horse: Horse { horse.size &lt;= barn.max_size}))]
    fn put_animal_in_house(&amp;mut self, horse: Horse) {}
}

fn test00() {
    let mut barn = HorseBarn { max_size: 20 };
    let horse = Horse { size: 10 };

    barn.put_animal_in_house(horse);
}</code></pre>
<h2 id="checking-overflows"><a class="header" href="#checking-overflows">Checking Overflows</a></h2>
<p>You can switch on overflow checking</p>
<ul>
<li><em>globally</em> <a href="http://localhost:3000/guide/run.html?highlight=cache#flux-flags">with a flag</a> or</li>
<li><em>locally</em> with an attribute as shown below</li>
</ul>
<pre><code class="language-rust noplayground">const MAX: u32 = std::u32::MAX;

// Error on this as it may overflow
#[flux::opts(check_overflow = "strict")]
#[flux::sig(fn (u32[@x], u32[@y], u32[@z]) -&gt; u32[x + y + z] requires x + y + z &lt;= MAX)]
fn add_three(x: u32, y: u32, z: u32) -&gt; u32 {
    x + y + z
}</code></pre>
<pre><code class="language-rust noplayground">#[flux::opts(check_overflow = "strict")]
mod my_mod {
    const MAX: u32 = std::u32::MAX;

    #[flux::sig(fn(u32[@x], u32[@y]) -&gt; u32[x + y] requires x + y &lt;= MAX)]
    fn add(x: u32, y: u32) -&gt; u32 {
        x + y
    }

    #[flux::sig(fn(u32[@x]) -&gt; u32[x + 2] requires x + 2 &lt;= MAX)]
    fn add2(x: u32) -&gt; u32 {
        x + 2
    }
}</code></pre>
<pre><code class="language-rust noplayground">const MAX: u32 = std::u32::MAX;

#[flux_rs::refined_by(inner: int)]
struct MyStruct {
    #[field(u32[inner])]
    inner: u32,
}

impl MyStruct {
    fn add1(&amp;self) -&gt; u32 {
        self.inner + 1
    }

    // Error as this may overflow
    #[flux::opts(check_overflow = "strict")]
    #[flux::sig(fn (&amp;MyStruct[@inner]) -&gt; u32[inner + 2] requires inner + 2 &lt;= MAX)]
    fn add2(&amp;self) -&gt; u32 {
        self.inner + 2
    }
}</code></pre>
<pre><code class="language-rust noplayground">const MAX: u32 = std::u32::MAX;

struct MyStruct {
    inner: u32,
}

#[flux::opts(check_overflow = "strict")]
trait MyTrait {
    #[flux::sig(fn(u32[@x], { u32[@y] | x + y &lt;= MAX }) -&gt; u32[x + y] )]
    fn add(x: u32, y: u32) -&gt; u32;
}

impl MyTrait for MyStruct {
    #[flux::sig(fn(u32[@x], { u32[@y] | x + y &lt;= MAX }) -&gt; u32[x + y] )]
    fn add(x: u32, y: u32) -&gt; u32 {
        x + y
    }
}</code></pre>
<h2 id="extensible-properties-for-primitive-ops"><a class="header" href="#extensible-properties-for-primitive-ops">Extensible Properties for Primitive Ops</a></h2>
<p>You can provide <em>properties</em> to be used when doing computations with
primitive operations like <code>&lt;&lt;</code> or <code>&gt;&gt;</code>.</p>
<p>Given a primop <code>op</code> with signature <code>(t1,...,tn) -&gt; t</code> we define
a refined type for <code>op</code> expressed as a [<code>RuleMatcher</code>]</p>
<pre><code class="language-rust noplayground">op :: (x1: t1, ..., xn: tn) -&gt; { t[op_val[op](x1,...,xn)] | op_rel[x1,...,xn] }</code></pre>
<p>that is, using two <em>uninterpreted functions</em> <code>op_val</code> and <code>op_rel</code> that respectively denote</p>
<ol>
<li>The <em>value</em> of the primop, and</li>
<li>Some invariant <em>relation</em> that holds for the primop.</li>
</ol>
<p>The latter can be extended by the user via a <code>property</code> definition,
which allows us to customize primops like <code>&lt;&lt;</code> with extra "facts"
or lemmas. See <code>tests/tests/pos/surface/primops00.rs</code> for an example.</p>
<pre><code class="language-rust noplayground">use flux_rs::{assert, attrs::*, defs};

defs! {

    fn is_char(n: int) -&gt; bool {
        0 &lt;= n &amp;&amp; n &lt;= 0x10FFFF
    }

    property ShiftByTwo[&lt;&lt;](x, y) {
        [&lt;&lt;](x, 2) == 4*x
    }

    property ShiftRightByFour[&gt;&gt;](x, y) {
        16 * [&gt;&gt;](x, 4) == x
    }

    property MaskBy[&amp;](x, y) {
        [&amp;](x, y) &lt;= y
    }

    property XorSelfInverse[^](x, y) {
        x == y =&gt; [^](x, y) == 0
    }

    property OrBy1[|](x, y) {
        is_char(x) =&gt; is_char([|](x, 1))
    }
}

pub fn test0() {
    let x: usize = 1 &lt;&lt; 2;
    assert(x == 4);
}

pub fn test1() {
    let x = 1;
    let x = x &lt;&lt; 2;
    let x = x &lt;&lt; 2;
    assert(x == 16)
}

#[spec(fn (x: u32) -&gt; u32[16*x])]
pub fn test2(x: u32) -&gt; u32 {
    let x = x &lt;&lt; 2;
    let x = x &lt;&lt; 2;
    x
}

#[spec(fn (byte: u8{byte &lt;= 127}))]
pub fn test3(byte: u8) {
    let tmp1 = byte &gt;&gt; 4;
    let tmp2 = byte &amp; 0xf;
    assert(byte &lt;= 127);
    assert(tmp1 &lt;= 0xf);
    assert(tmp2 &lt;= 0xf);
}

static POW10: [i32; 10] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];

pub fn test4(n: usize) -&gt; i32 {
    POW10[n &amp; 7]
}

#[spec(fn(x: usize) -&gt; usize[0])]
pub fn test5(x: usize) -&gt; usize {
    x ^ x
}

pub fn test6(c: char) {
    let c = c as u32;
    flux_rs::assert(c &lt;= 0x10FFFF); // (0)
    let c = c | 1;
    flux_rs::assert(c &lt;= 0x10FFFF); // (1)
}</code></pre>
<h2 id="casting-sorts"><a class="header" href="#casting-sorts">Casting Sorts</a></h2>
<p>You can convert refinements of different sorts -- e.g. <code>int</code> to <code>char</code> or <code>int</code> to <code>bool</code> --
using the <code>cast</code> internal function.</p>
<pre><code class="language-rust noplayground">#![flux::defs {
    fn is_ascii_digit(c: char) -&gt; bool {
        let i = cast(c);
        48 &lt;= i &amp;&amp; i &lt;= 57
    }

    fn is_ascii(c: char) -&gt; bool {
        let i = cast(c);
        0 &lt;= i &amp;&amp; i &lt;= 127
    }
}]

use flux_rs::{assert, attrs::*};

// extern specs for is_ascii and is_ascii_digit
#[extern_spec]
impl char {
    #[spec(fn (&amp;Self[@c]) -&gt; bool[is_ascii(c)])]
    fn is_ascii(&amp;self) -&gt; bool;

    #[spec(fn (&amp;Self[@c]) -&gt; bool[is_ascii_digit(c)])]
    fn is_ascii_digit(&amp;self) -&gt; bool;
}

pub fn test_ok(x: char) {
    if x.is_ascii_digit() {
        assert(x.is_ascii())
    }
}

#[spec(fn (char{v: '0' &lt;= v &amp;&amp; v &lt;= '9'}))]
pub fn test_digit(x: char) {
    assert(x.is_ascii_digit())
}</code></pre>
<h2 id="detached-specifications-1"><a class="header" href="#detached-specifications-1">Detached Specifications</a></h2>
<p>Sometimes you may want to write specs for functions, structs, enums
etc. but not <em>directly</em> attached to the function i.e. as an attribute
of the definition, perhaps because you don't want to modify the original
source file, or because the code for the function was derived or generated
by a macro.</p>
<p>You can write <em>detached</em> specifications using the <code>specs</code> macro
as illustrated by the following</p>
<p><strong>Function Types</strong></p>
<pre><code class="language-rust noplayground">#![flux::specs {

   fn inc(n:i32) -&gt; i32{v: n &lt; v};

   fn id(n:i32) -&gt; i32[n];

}]

pub fn inc(n: i32) -&gt; i32 {
    n - 1 //~ ERROR refinement type
}

pub fn id(n: i32) -&gt; i32 {
    n
}</code></pre>
<p><strong>Structs</strong></p>
<pre><code class="language-rust noplayground">use flux_rs::assert;

pub struct MyStruct {
    x: usize,
    y: usize,
}

pub fn mk_struct(x: usize, y: usize) -&gt; MyStruct {
    if x &lt; y { MyStruct { x, y } } else { MyStruct { x: y, y: x } }
}

pub fn use_struct(s: MyStruct) {
    assert(s.x &lt;= s.y)
}

#[flux::specs {

    #[refined_by(vx: int, vy: int)]
    #[invariant(vx &lt;= vy)]
    struct MyStruct {
        x: usize[vx],
        y: usize[vy],
    }

}]
const _: () = ();</code></pre>
<p><strong>Enums</strong></p>
<pre><code class="language-rust noplayground">enum Nat {
    Zero,
    Succ(Box&lt;Nat&gt;),
}

fn zero() -&gt; Nat {
    Nat::Zero
}

fn succ(n: Nat) -&gt; Nat {
    Nat::Succ(Box::new(n))
}

fn from_usize(n: usize) -&gt; Nat {
    if n == 0 { zero() } else { succ(from_usize(n - 1)) }
}

#[flux::specs {

    #[refined_by(n: int)]
    #[invariant(0 &lt;= n)]
    enum Nat {
      Zero               -&gt; Nat[0],
      Succ(Box&lt;Nat[@n]&gt;) -&gt; Nat[n+1],
    }

    fn zero() -&gt; Nat[0];

    fn succ(n:Nat) -&gt; Nat[n+1];

    fn from_usize(n:usize) -&gt; Nat[n];
}]
const _: () = ();</code></pre>
<p><strong>Traits</strong></p>
<pre><code class="language-rust noplayground">#![allow(dead_code)]

use flux_rs::attrs::*;

trait MyTrait {
    fn baz(&amp;self) -&gt; usize;
}

struct Add1;

impl MyTrait for Add1 {
    fn baz(&amp;self) -&gt; usize {
        1
    }
}

#[spec(fn(x: i32{v: v == &lt;Add1 as MyTrait&gt;::f(0) }))]
fn test00(_x: i32) {}

fn test01() {
    test00(1);
}

#[flux::specs {

    trait MyTrait {
        #[reft]
        fn f(x: int) -&gt; int;

        fn baz(&amp;Self) -&gt; usize[Self::f(0)];

    }

    impl MyTrait for Add1 {
        #[reft] fn f(x: int) -&gt; int {
            x + 1
        }

        fn baz(&amp;Self) -&gt; usize[1];
    }

}]
const _: () = ();</code></pre>
<p><strong>Inherent Impls</strong></p>
<pre><code class="language-rust noplayground">use flux_rs::attrs::*;

pub enum Nat {
    Zero,
    Succ(Box&lt;Nat&gt;),
}

impl Nat {
    fn zero() -&gt; Self {
        Nat::Zero
    }
}

impl Nat {
    fn succ(n: Self) -&gt; Self {
        Nat::Succ(Box::new(n))
    }
}

// --------------------------------------------------------------------------------------

#[spec(fn () -&gt; Nat[0])]
pub fn test_a() -&gt; Nat {
    Nat::zero()
}

#[spec(fn () -&gt; Nat[3])]
pub fn test_b() -&gt; Nat {
    Nat::succ(Nat::succ(Nat::succ(Nat::zero())))
}

// --------------------------------------------------------------------------------------

#[flux::specs {

    #[refined_by(n: int)]
    #[invariant(0 &lt;= n)]
    enum Nat {
      Zero               -&gt; Nat[0],
      Succ(Box&lt;Nat[@n]&gt;) -&gt; Nat[n + 1],
    }

    impl Nat {

        fn zero() -&gt; Nat[0];

    }

    impl Nat {

        fn succ(n:Nat) -&gt; Nat[n+1];

    }
}]
const _: () = ();</code></pre>
<p><strong>Trait Impls</strong></p>
<p>Note the <em>fully qualified</em> name of the <code>trait</code> in the spec.</p>
<pre><code class="language-rust noplayground">#![allow(unused)]

extern crate flux_core;

use flux_rs::{assert, attrs::*};

pub mod a {
    pub mod b {
        pub trait MyTrait {
            fn gromp(&amp;self) -&gt; usize;
        }
    }
}

pub mod x {
    pub mod y {
        pub struct Thing&lt;T&gt; {
            inner: T,
        }

        impl&lt;T&gt; Thing&lt;T&gt; {
            pub fn new(inner: T) -&gt; Self {
                Thing { inner }
            }
        }

        impl&lt;T&gt; crate::a::b::MyTrait for Thing&lt;T&gt; {
            fn gromp(&amp;self) -&gt; usize {
                42
            }
        }
    }
}

// -------------------------------------------------------------------
mod test {
    use crate::a::b::MyTrait;

    #[flux_rs::spec(fn () -&gt; usize[42])]
    fn test() -&gt; usize {
        crate::x::y::Thing::new(true).gromp()
    }
}

// -------------------------------------------------------------------
#[flux_rs::specs {
    mod x {
        mod y {
            impl a::b::MyTrait for Thing&lt;T&gt; {
                fn gromp(&amp;Self) -&gt; usize[42];
            }
        }
    }
}]
const _: () = ();</code></pre>
<h2 id="include-patterns"><a class="header" href="#include-patterns">Include Patterns</a></h2>
<p>You can include patterns to restrict <code>flux</code> to only check a subset of a codebase.
A <code>def_id</code> is checked if it matches any of the patterns.</p>
<pre><code>cargo x run tests/tests/pos/detached/detach00.rs -- -Fdump-checker-trace -Fdump-constraint -Finclude=span:tests/tests/pos/detached/detach00.rs:13:1 -Finclude=def:id -Finclude=path/to/file.rs
</code></pre>
<h2 id="scraping-qualifiers"><a class="header" href="#scraping-qualifiers">Scraping Qualifiers</a></h2>
<p>Sometimes it is useful to tell fixpoint to automatically "scrape" qualifiers from constraints etc. to synthesize
solutions for constraints.</p>
<pre><code class="language-rust noplayground">#![flux::opts(scrape_quals = "true")]

#[path = "../../lib/rvec.rs"]
mod rvec;
use rvec::RVec;

// test that the (fixpoint) `--scrape` mechanism suffices to get
// the qualifier needed for the loop invariant below.

#[flux::sig(fn(lo: usize, hi:usize{lo&lt;=hi}) -&gt; RVec&lt;usize&gt;[hi-lo] )]
pub fn range(lo: usize, hi: usize) -&gt; RVec&lt;usize&gt; {
    let mut i = lo;
    let mut res = RVec::new();
    while i &lt; hi {
        // inv: res.len() = i - lo
        res.push(i);
        i += 1;
    }
    res
}</code></pre>
<h2 id="invariant-macro"><a class="header" href="#invariant-macro">Invariant Macro</a></h2>
<p>The <code>invariant!</code> macro can be used to simulate a restricted form of loop invariant,
by simultaneously specifying assertions and qualifiers that can be used to establish
that assertion.</p>
<pre><code class="language-rust noplayground">use flux_rs::{attrs::*, macros::invariant};

#[spec(fn (n: usize) -&gt; usize[n])]
pub fn test_with_qualifier(n: usize) -&gt; usize {
    let mut i = n;
    let mut res = 0;
    while i &gt; 0 {
        #[flux::defs{
            invariant qualifier Auto(res: int) { res + i == n  &amp;&amp; i &gt;= 99-99 &amp;&amp; res &gt;= 66 - 66 }
         }]
        const _: () = ();
        i -= 1;
        res += 1;
    }
    res
}

#[spec(fn (n: usize) -&gt; usize[n])]
pub fn test(n: usize) -&gt; usize {
    let mut i = n;
    let mut res = 0;
    while i &gt; 0 {
        invariant!(res:int; res + i == n &amp;&amp; i &gt;= 99-99 &amp;&amp; res &gt;= 66 - 66);
        i -= 1;
        res += 1;
    }
    res
}</code></pre>
<hr>
<ol class="footnote-definition"><li id="footnote-ignore-shorthand">
<p><code>#[flux_rs::ignore]</code> (resp. <code>#[flux_rs::trusted]</code>) is shorthand for <code>#[flux_rs::ignore(yes)]</code> (resp. <code>#[flux_rs::trusted(yes)]</code>). <a href="#fr-ignore-shorthand-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="developers-guide"><a class="header" href="#developers-guide">Developer's Guide</a></h1>
<h2 id="backtraces"><a class="header" href="#backtraces">Backtraces</a></h2>
<p>You can use the usual <code>RUST_BACKTRACE=1</code> environment variable to enable backtraces.
With the regular <code>release</code> build (<code>cargo x install</code>) you get some backtraces, but
the <code>dev</code> build, which you can install as shown below, gives more information e.g.
the source-spans of various calls in the backtrace.</p>
<pre><code class="language-sh">$ cargo x install --profile dev
</code></pre>
<h2 id="regression-tests"><a class="header" href="#regression-tests">Regression Tests</a></h2>
<p>You can run the various regression tests in the <code>tests/pos</code> and <code>tests/neg</code> directories using
<code>cargo xtask test</code></p>
<p>This will build the flux binary and then run it against the entire test suite.
You can optionally pass a <em>filter</em> to only run tests containing some substring.
For example:</p>
<pre><code class="language-console">$ cargo xtask test impl_trait
   Compiling xtask v0.1.0 (/path/to/flux/xtask)
    Finished dev [unoptimized + debuginfo] target(s) in 0.29s
     Running `target/debug/xtask test impl_trait`
$ cargo build
    Finished dev [unoptimized + debuginfo] target(s) in 0.05s
$ cargo test -p tests -- --test-args impl_trait
   Compiling fluxtests v0.1.0 (/path/to/flux/tests)
    Finished test [unoptimized + debuginfo] target(s) in 0.62s
     Running tests/compiletest.rs (target/debug/deps/compiletest-1241128f1f51caa4)

running 5 tests
test [ui] pos/surface/impl_trait04.rs ... ok
test [ui] pos/surface/impl_trait03.rs ... ok
test [ui] pos/surface/impl_trait01.rs ... ok
test [ui] pos/surface/impl_trait00.rs ... ok
test [ui] pos/surface/impl_trait02.rs ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 191 filtered out; finished in 0.10s


running 2 tests
test [compile-fail] neg/surface/impl_trait00.rs ... ok
test [compile-fail] neg/surface/impl_trait02.rs ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 207 filtered out; finished in 0.09s
</code></pre>
<h2 id="testing-flux-on-a-file"><a class="header" href="#testing-flux-on-a-file">Testing Flux on a File</a></h2>
<p>When working on Flux, you may want to test your changes by running it against a test file.
You can use <code>cargo xtask run &lt;input&gt;</code> to run Flux on a single input file.
The command will set appropriate flags to be able to use custom Flux attributes and macros,
plus some extra flags useful for debugging.
For example:</p>
<pre><code class="language-console">$ cat test.rs
#[flux::sig(fn(x: i32) -&gt; i32[x + 1])]
fn add1(x: i32) -&gt; i32 {
    x + 1
}
$ cargo xtask run test.rs
</code></pre>
<p>The command will use a super set of the flags passed when running regression tests.
Thus, a common workflow is to identify a failing test and run it directly with <code>cargo xtask run</code>,
or alternatively copy it to a different file.</p>
<p>You may also find useful to create a directory in the root of the project and add it to
<a href="https://git-scm.com/docs/gitignore"><code>.git/info/exclude</code></a>.
You can keep files there, outside of version control, and test Flux against them.
I have a directory called <code>attic/</code> where I keep a file named <code>playground.rs</code>.
To run Flux on it, I do <code>cargo xtask run attic/playground.rs</code>.</p>
<h2 id="reporting-locations-where-errors-are-emitted"><a class="header" href="#reporting-locations-where-errors-are-emitted">Reporting locations where errors are emitted</a></h2>
<p>When you use <code>cargo xtask run</code> you'll see that we report the location an error was emitted, e.g.,</p>
<pre><code class="language-console">error[FLUX]: refinement type error
 --&gt; attic/playground.rs:4:5
  |
4 |     0
  |     ^ a postcondition cannot be proved
-Ztrack-diagnostics: created at crates/flux-refineck/src/lib.rs:114:15   &lt;------- this
</code></pre>
<p>You can also pass <code>-Ztrack-diagnostics=y</code> to enable it if you are not using <code>cargo xtask run</code></p>
<h2 id="macro-expansion"><a class="header" href="#macro-expansion">Macro expansion</a></h2>
<p>For example if you have code like in <code>path/to/file.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[extern_spec]
#[flux::refined_by(elems: Set&lt;T&gt;)]
struct HashSet&lt;T, S = RandomState&gt;;
<span class="boring">}</span></code></pre></pre>
<p>and you want to see what the <code>extern_spec</code> macro expands it out to, then run</p>
<pre><code class="language-shell">cargo x run -- -Zunpretty=expanded path/to/file.rs
</code></pre>
<p>Or you can run the <code>xtask</code> command directly</p>
<pre><code class="language-shell">cargo x expand path/to/file.rs
</code></pre>
<h2 id="examining-the-mir"><a class="header" href="#examining-the-mir">Examining the MIR</a></h2>
<p>You can use the <code>-Zdump-mir</code> flag to dump the MIR at various stages of compilation.
For example,</p>
<pre><code>$ cargo x run path/to/test.rs -- -Zdump-mir=renumber
</code></pre>
<p>or</p>
<pre><code>$ cargo x run path/to/test.rs -- -Zdump-mir=ghost
</code></pre>
<p>will stash the MIR for those relevant stages in the <code>mir_dump</code> directory.</p>
<p>You can then look at the <code>&lt;fn-name&gt;.ghost.mir</code> to see the MIR that Flux is checking.</p>
<h2 id="reporting-and-dealing-with-bugs"><a class="header" href="#reporting-and-dealing-with-bugs">Reporting and dealing with bugs</a></h2>
<p>As Flux is under active development, there are many aspects of Rust that Flux does not yet support, are
only partially implemented, or where the implementation may contain bugs. These issues typically manifest
as unreachable arms in a match statement (that turn out not to be unreachable) or preemtive assertions to
guard against code we don't yet support. To help identify the code that triggers these bugs, there are a few
recommended methods for reporting them:</p>
<ul>
<li><code>QueryErr::bug</code>: Use this method to report a bug if the code already returns a <code>QueryResult</code>. This
approach is preferred because we will correctly recover from the error.</li>
<li><code>span_bug!</code>: When you have a <code>Span</code> at hand, you can use this macro in place of <code>panic!</code> to report
the span before panicking.</li>
<li><code>tracked_span_bug!</code>: This macro is similar to <code>span_bug!</code>, but it uses a span stored in a thread local
variable (if one exists). To track a span in the thread local variable you can use <code>flux_common::bug::track_span</code>.</li>
<li><code>bug!</code>: For other cases where none of the above applies, you can use the <code>bug!</code> macro. This behaves
mostly like <code>panic!</code> but with nicer formatting.</li>
</ul>
<p>When running Flux in a new code base, consider setting the flag <code>FLUX_CATCH_BUGS=1</code>. If this flag is set,
Flux will try to catch and recover from panics emitted with one of the bug macros (using
<code>std::panic::catch_unwind</code>). Bugs are caught at item boundaries. This may leave Flux or rustc
in an inconsistent state, so there are no guarantees that Flux will behave correctly after recovering
from a panic. However, this may still be useful to gather as many errors as possible. Code can
be selectively ignored later.</p>
<h2 id="dumping-the-checker-trace"><a class="header" href="#dumping-the-checker-trace">Dumping the Checker Trace</a></h2>
<pre><code>cargo x install --debug
FLUX_DUMP_CHECKER_TRACE=1 FLUX_CHECK_DEF=mickey cargo flux
python3  path/to/flux/tools/logreader.py
</code></pre>
<h2 id="debugging-extern-specs"><a class="header" href="#debugging-extern-specs">Debugging Extern Specs</a></h2>
<p>To see the expanded code of an <code>extern_spec</code> macro, you can do</p>
<pre><code>cargo x expand path/to/file.rs
</code></pre>
<h2 id="rebuilding-libraries"><a class="header" href="#rebuilding-libraries">(Re)building Libraries</a></h2>
<p>When making changes to the libraries, including <code>flux-core</code> which has the
<code>extern_spec</code>ifications for the standard library, you can force a rebuild
of the libraries by running:</p>
<pre><code class="language-sh">cargo x build-sysroot
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="high-level-architecture"><a class="header" href="#high-level-architecture">High-level Architecture</a></h1>
<p>Flux is implemented as a compiler <a href="https://rustc-dev-guide.rust-lang.org/rustc-driver.html?highlight=Callbacks%5C#rustc_driver-and-rustc_interface">driver</a>. We hook into the compiler by implementing the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_driver/trait.Callbacks.html"><code>Callbacks</code></a> trait. The implementation is located is in the <code>flux-driver</code> crate, and it is the main entry point to Flux.</p>
<h2 id="crates"><a class="header" href="#crates">Crates</a></h2>
<ul>
<li><code>crates/flux-bin</code>: Contains the <code>cargo-flux</code> and <code>flux</code> binaries used to launch the <code>flux-driver</code>.</li>
<li><code>crates/flux-common</code>: Common utility definitions used across all crates.</li>
<li><code>crates/flux-config</code>: Crate containing logic associated with global configuration flags that change the behavior of Flux, e.g, to enable or disable overflow checking.</li>
<li><code>crates/flux-desugar</code>: Implementation of name resolution and desugaring from Flux surface syntax into Flux high-level intermediate representation (<code>fhir</code>). This includes name resolution.</li>
<li><code>crates/flux-driver</code>: Main entry point to Flux. It contains the <code>flux-driver</code> binary and the implementation of the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_driver/trait.Callbacks.html"><code>Callbacks</code></a> trait.</li>
<li><code>crates/flux-errors</code>: Utility definitions for user facing error reporting.</li>
<li><code>crates/flux-fhir-analysis</code>: Implements the "analyses" performed in the <code>fhir</code>, most notably well-formedness checking and conversion from <code>fhir</code> into <code>rty</code>.</li>
<li><code>crates/flux-fixpoint</code>: Code to interact with the Liquid Fixpoint binary.</li>
<li><code>crates/flux-macros</code>: Procedural macros used internally to implement Flux.</li>
<li><code>crates/flux-metadata</code>: Logic for saving Flux crate metadata that can be used to import refined signatures from external crates.</li>
<li><code>crates/flux-middle</code>: This crate contains common type definitions that are used by the rest of Flux like the <code>rty</code> and <code>fhir</code> intermediate representations. Akin to <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/index.html"><code>rustc_middle</code></a>.</li>
<li><code>crates/flux-refineck</code>: Implementation of refinement type checking.</li>
<li><code>crates/flux-syntax</code>: Definition of the surface syntax AST and parser.</li>
<li><code>tests</code>: Flux regression tests.</li>
<li><code>lib/flux-attrs</code>: Implementation of user facing procedural macros for annotating programs with Flux specs.</li>
<li><code>lib/flux-rs</code>: This is just a re-export of the macros implemented in <code>flux-attrs</code>. The intention is to eventually put Flux "standard library" here, i.e., a set of definitions that are useful when working with Flux.</li>
</ul>
<h2 id="intermediate-representations"><a class="header" href="#intermediate-representations">Intermediate Representations</a></h2>
<p>Flux has several intermediate representations (IR) for types. They represent a refined version of an equivalent type in some <code>rustc</code> IR. We have picked a distinct <em>verb</em> to refer to the process of going between these different representations to make it easier to refer to them. The following image summarizes all the IRs and the process for going between them.</p>
<p><img src="guide/../img/irs.svg" alt="IRs diagram" /></p>
<h3 id="surface"><a class="header" href="#surface">Surface</a></h3>
<p>The surface IR represents source level Flux annotations. It corresponds to the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/index.html"><code>rustc_ast</code></a> data structures in <code>rustc</code>. The definition as well as the parser is located in the <code>flux-syntax</code> crate.</p>
<h3 id="fhir"><a class="header" href="#fhir">Fhir</a></h3>
<p>The Flux High-Level Intermediate Representation (fhir) is a refined version of <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/index.html"><code>rustc</code>'s hir</a>. The definition is located in the <code>flux_middle</code> crate inside the <code>fhir</code> module. The process of going from <code>surface</code> to <code>fhir</code> is called <em>desugaring</em>, and it is implemented in the <code>flux-desugar</code> crate.</p>
<h3 id="rty"><a class="header" href="#rty">Rty</a></h3>
<p>The definition in the <code>flux_middle::rty</code> module correspond to a refined version of the main <code>rustc</code> representation for types defined in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/index.html"><code>rustc_middle::ty</code></a>. The process of going from <code>fhir</code> to <code>rty</code> is called <em>conversion</em>, and it is implemented in the <code>flux_fhir_analysis::conv</code> module.</p>
<h3 id="simplified-rustc"><a class="header" href="#simplified-rustc">Simplified Rustc</a></h3>
<p>The definition in the <code>flux_middle::rustc</code> module correspond to simplified version of data structures in <code>rustc</code>. They can be understood as the currently supported subset of Rust. The process of going from a definition in <code>rustc_middle</code> into <code>flux_middle::rustc</code> is called <em>lowering</em> and it is implemented in <code>flux_middle::rustc::lowering</code>.</p>
<h3 id="lifting-and-refining"><a class="header" href="#lifting-and-refining">Lifting and Refining</a></h3>
<p>Besides the different translation between Flux intermediate representations, there are two ways to get a refined version from a rust type. The process of going from a type in <code>hir</code> into a type in <code>fhir</code> is called <em>lifting</em>, and it is implemented in <code>flux_middle::fhir::lift</code>. The process for going from a type in <code>flux_middle::rustc::ty</code> into a <code>flux_middle::rty</code> is called <em>refining</em>, and it is implemented <code>flux_middle::rty::refining</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
