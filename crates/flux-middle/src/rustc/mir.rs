//! A simplified version of rust mir.

use std::fmt;

use flux_common::{
    bug,
    index::{Idx, IndexVec},
};
use itertools::Itertools;
pub use rustc_borrowck::borrow_set::BorrowData;
use rustc_borrowck::consumers::{BodyWithBorrowckFacts, BorrowIndex};
use rustc_data_structures::{fx::FxIndexMap, graph::dominators::Dominators};
use rustc_hir::def_id::{DefId, LocalDefId};
use rustc_index::IndexSlice;
use rustc_infer::infer::TyCtxtInferExt;
use rustc_macros::{Decodable, Encodable};
use rustc_middle::{
    mir::{self, MutBorrowKind},
    ty::{FloatTy, IntTy, TyCtxt, UintTy},
};
pub use rustc_middle::{
    mir::{
        BasicBlock, Local, LocalKind, Location, SourceInfo, SwitchTargets, UnOp, UnwindAction,
        RETURN_PLACE, START_BLOCK,
    },
    ty::Variance,
};
use rustc_span::{Span, Symbol};
pub use rustc_target::abi::{FieldIdx, VariantIdx, FIRST_VARIANT};

use super::ty::{GenericArg, GenericArgs, Region, Ty, TyKind};
use crate::{
    global_env::GlobalEnv, intern::List, pretty::def_id_to_string, queries::QueryResult,
    rustc::ty::region_to_string,
};

pub struct Body<'tcx> {
    pub basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,
    pub local_decls: IndexVec<Local, LocalDecl>,
    /// During borrow checking, `rustc` generates fresh [region variable ids] for each structurally
    /// different position in a type. For example, given a function
    ///
    /// `fn foo<'a, 'b>(x: &'a S<'a>, y: &'b u32)`
    ///
    /// `rustc` will generate variables `?2` and `?3` for the universal regions `'a` and `'b` (the variable
    /// `?0` correspond to `'static` and `?1` to the implicit lifetime of the function body). Additionally,
    /// it will assign `x` type &'?4 S<'?5>` and `y` type `&'?6 u32` (together with some constraints relating
    /// region variables). Unfortunately, we cannot recover the exact region variables rustc used.
    ///
    /// The exact ids picked for `'a` and `'b` are not too relevant to us, the important part is the regions
    /// used in the types of `x` and `y`. To work around this, we generate fresh regions variables for
    /// the function signature, different from the ones sued by rustc. To recover the correct regions, whenever
    /// there's an assignment of a refinement type `T` to a variable with (unrefined) Rust type `S`, we _match_
    /// both types to infer a region substition. For this to work, we need to give a different variable id to every
    /// position in `T`. To avoid clashes, we need to use fresh ids, so we start enumerating from the last id
    /// generated by borrow checking.
    ///
    /// To do that, we replicate the [`InferCtxt`] use for mir typeck by generating region variables for every
    /// region in the `RegionInferenceContext`. The [`InferCtxt`] is then used to generate new region variables.
    ///
    /// The ids generated during refinement type checking are purely instrumental and temporary, they should never
    /// appear in a type bound in the environment.
    ///
    /// Besides generating ids when checking a function's body, we also need to generate fresh ids at
    /// function calls.
    ///
    /// Additionally, the [`InferCtxt`] is used during type projection normalization.
    ///
    /// [region variable ids]: super::ty::RegionVid
    /// [`InferCtxt`]: rustc_infer::infer::InferCtxt
    pub infcx: rustc_infer::infer::InferCtxt<'tcx>,
    /// See [`mk_fake_predecessors`]
    fake_predecessors: IndexVec<BasicBlock, usize>,
    body_with_facts: BodyWithBorrowckFacts<'tcx>,
}

#[derive(Debug)]
pub struct BasicBlockData<'tcx> {
    pub statements: Vec<Statement>,
    pub terminator: Option<Terminator<'tcx>>,
    pub is_cleanup: bool,
}

pub type LocalDecls = IndexSlice<Local, LocalDecl>;

#[derive(Clone, Debug)]
pub struct LocalDecl {
    pub ty: Ty,
    pub source_info: SourceInfo,
}

pub struct Terminator<'tcx> {
    pub kind: TerminatorKind<'tcx>,
    pub source_info: SourceInfo,
}

#[derive(Debug)]
pub struct CallArgs<'tcx> {
    pub orig: rustc_middle::ty::GenericArgsRef<'tcx>,
    pub lowered: List<GenericArg>,
}

/// An `Instance` is the resolved call-target at a particular trait-call-site
#[derive(Debug)]
pub struct Instance {
    pub impl_f: DefId,
    pub args: GenericArgs,
}

#[derive(Debug)]
pub enum TerminatorKind<'tcx> {
    Return,
    Call {
        func: DefId,
        generic_args: CallArgs<'tcx>,
        args: Vec<Operand>,
        destination: Place,
        target: Option<BasicBlock>,
        unwind: UnwindAction,
        resolved_call: (DefId, CallArgs<'tcx>),
    },
    SwitchInt {
        discr: Operand,
        targets: SwitchTargets,
    },
    Goto {
        target: BasicBlock,
    },
    Drop {
        place: Place,
        target: BasicBlock,
        unwind: UnwindAction,
    },
    Assert {
        cond: Operand,
        expected: bool,
        target: BasicBlock,
        msg: AssertKind,
    },
    Unreachable,
    FalseEdge {
        real_target: BasicBlock,
        imaginary_target: BasicBlock,
    },
    FalseUnwind {
        real_target: BasicBlock,
        unwind: UnwindAction,
    },
    Yield {
        value: Operand,
        resume: BasicBlock,
        resume_arg: Place,
        drop: Option<BasicBlock>,
    },
    CoroutineDrop,
    UnwindResume,
}

#[derive(Debug)]
pub enum AssertKind {
    BoundsCheck,
    RemainderByZero,
    Overflow(BinOp),
    DivisionByZero,
    // OverflowNeg(O),
    // ResumedAfterReturn(GeneratorKind),
    // ResumedAfterPanic(GeneratorKind),
}

pub struct Statement {
    pub kind: StatementKind,
    pub source_info: SourceInfo,
}

#[derive(Debug)]
pub enum StatementKind {
    Assign(Place, Rvalue),
    SetDiscriminant(Place, VariantIdx),
    FakeRead(Box<(FakeReadCause, Place)>),
    AscribeUserType(Place, Variance),
    PlaceMention(Place),
    Nop,
}

pub enum Rvalue {
    Use(Operand),
    Ref(Region, BorrowKind, Place),
    BinaryOp(BinOp, Operand, Operand),
    CheckedBinaryOp(BinOp, Operand, Operand),
    UnaryOp(UnOp, Operand),
    Aggregate(AggregateKind, Vec<Operand>),
    Discriminant(Place),
    Len(Place),
    Cast(CastKind, Operand, Ty),
}

pub enum BorrowKind {
    Mut { kind: MutBorrowKind },
    Shared,
}

#[derive(Copy, Clone)]
pub enum CastKind {
    IntToInt,
    FloatToInt,
    IntToFloat,
    PtrToPtr,
    Pointer(PointerCast),
}

#[derive(Copy, Clone)]
pub enum PointerCast {
    MutToConstPointer,
    Unsize,
}

#[derive(Debug)]
pub enum AggregateKind {
    Adt(DefId, VariantIdx, GenericArgs),
    Array(Ty),
    Tuple,
    Closure(DefId, GenericArgs),
    Coroutine(DefId, GenericArgs),
}

#[derive(Debug, Copy, Clone, Hash, Eq, PartialEq)]
pub enum BinOp {
    Gt,
    Ge,
    Lt,
    Le,
    Eq,
    Ne,
    Add,
    Sub,
    Mul,
    Div,
    Rem,
    BitAnd,
    BitOr,
    Shl,
    Shr,
}

pub enum Operand {
    Copy(Place),
    Move(Place),
    Constant(Constant),
}

#[derive(Clone, PartialEq, Eq, Hash, Encodable, Decodable)]
pub struct Place {
    /// the "root" of the place, e.g. `_1` in `*_1.f.g.h`
    pub local: Local,
    /// path taken to "get" the place e.g. `*.f.g.h` in `*_1.f.g.h` (except also have derefs)
    pub projection: Vec<PlaceElem>,
}

#[derive(Debug)]
pub struct PlaceTy {
    pub ty: Ty,
    /// Downcast to a particular variant of an enum or a generator, if included.
    pub variant_index: Option<VariantIdx>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Encodable, Decodable)]
pub enum PlaceElem {
    Deref,
    Field(FieldIdx),
    Downcast(Option<Symbol>, VariantIdx),
    Index(Local),
}

pub enum Constant {
    Int(i128, IntTy),
    Uint(u128, UintTy),
    Float(u128, FloatTy),
    Bool(bool),
    /// We only support opaque string slices, so no data stored here for now.
    Str,
    /// We only support opaque chars, so no data stored here for now
    Char,
    Unit,
    /// General catch-all for constants of a given Ty
    Opaque(Ty),
}

pub enum FakeReadCause {
    ForLet(Option<LocalDefId>),
    ForMatchedPlace(Option<LocalDefId>),
}

impl<'tcx> Terminator<'tcx> {
    pub fn is_return(&self) -> bool {
        matches!(self.kind, TerminatorKind::Return)
    }
}

impl Statement {
    pub fn is_nop(&self) -> bool {
        matches!(self.kind, StatementKind::Nop)
    }
}

impl<'tcx> Body<'tcx> {
    pub fn new(
        basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,
        local_decls: IndexVec<Local, LocalDecl>,
        body_with_facts: BodyWithBorrowckFacts<'tcx>,
        infcx: rustc_infer::infer::InferCtxt<'tcx>,
    ) -> Self {
        let fake_predecessors = mk_fake_predecessors(&basic_blocks);
        Self { basic_blocks, local_decls, infcx, fake_predecessors, body_with_facts }
    }

    pub fn span(&self) -> Span {
        self.body_with_facts.body.span
    }

    pub fn inner(&self) -> &mir::Body<'tcx> {
        &self.body_with_facts.body
    }

    #[inline]
    pub fn args_iter(&self) -> impl ExactSizeIterator<Item = Local> {
        (1..self.body_with_facts.body.arg_count + 1).map(Local::new)
    }

    #[inline]
    pub fn vars_and_temps_iter(&self) -> impl ExactSizeIterator<Item = Local> {
        (self.body_with_facts.body.arg_count + 1..self.local_decls.len()).map(Local::new)
    }

    #[inline]
    pub fn is_join_point(&self, bb: BasicBlock) -> bool {
        let total_preds = self.body_with_facts.body.basic_blocks.predecessors()[bb].len();
        let real_preds = total_preds - self.fake_predecessors[bb];
        // The entry block is a joint point if it has at least one predecessor because there's
        // an implicit goto from the environment at the beginning of the function.
        real_preds > usize::from(bb != START_BLOCK)
    }

    #[inline]
    pub fn dominators(&self) -> &Dominators<BasicBlock> {
        self.body_with_facts.body.basic_blocks.dominators()
    }

    pub fn terminator_loc(&self, bb: BasicBlock) -> Location {
        Location { block: bb, statement_index: self.basic_blocks[bb].statements.len() }
    }

    pub fn calculate_borrows_out_of_scope_at_location(
        &self,
    ) -> FxIndexMap<Location, Vec<BorrowIndex>> {
        rustc_borrowck::consumers::calculate_borrows_out_of_scope_at_location(
            &self.body_with_facts.body,
            &self.body_with_facts.region_inference_context,
            &self.body_with_facts.borrow_set,
        )
    }

    pub fn borrow_data(&self, idx: BorrowIndex) -> &BorrowData<'tcx> {
        self.body_with_facts
            .borrow_set
            .location_map
            .get_index(idx.as_usize())
            .unwrap()
            .1
    }

    pub fn rustc_body(&self) -> &mir::Body<'tcx> {
        &self.body_with_facts.body
    }

    pub fn local_kind(&self, local: Local) -> LocalKind {
        self.body_with_facts.body.local_kind(local)
    }
}

impl Place {
    pub const RETURN: &'static Place = &Place { local: RETURN_PLACE, projection: vec![] };

    pub fn new(local: Local, projection: Vec<PlaceElem>) -> Place {
        Place { local, projection }
    }

    pub fn ty(&self, genv: GlobalEnv, local_decls: &LocalDecls) -> QueryResult<PlaceTy> {
        self.projection
            .iter()
            .try_fold(PlaceTy::from_ty(local_decls[self.local].ty.clone()), |place_ty, elem| {
                place_ty.projection_ty(genv, *elem)
            })
    }

    pub fn behind_raw_ptr(&self, genv: GlobalEnv, local_decls: &LocalDecls) -> QueryResult<bool> {
        let mut place_ty = PlaceTy::from_ty(local_decls[self.local].ty.clone());
        for elem in &self.projection {
            if let (PlaceElem::Deref, TyKind::RawPtr(..)) = (elem, place_ty.ty.kind()) {
                return Ok(true);
            }
            place_ty = place_ty.projection_ty(genv, *elem)?;
        }
        Ok(false)
    }
}

impl PlaceTy {
    fn from_ty(ty: Ty) -> PlaceTy {
        PlaceTy { ty, variant_index: None }
    }

    fn projection_ty(&self, genv: GlobalEnv, elem: PlaceElem) -> QueryResult<PlaceTy> {
        if self.variant_index.is_some() && !matches!(elem, PlaceElem::Field(..)) {
            bug!("cannot use non field projection on downcasted place");
        }
        let place_ty = match elem {
            PlaceElem::Deref => PlaceTy::from_ty(self.ty.deref()),
            PlaceElem::Field(fld) => PlaceTy::from_ty(self.field_ty(genv, fld)?),
            PlaceElem::Downcast(_, variant_idx) => {
                PlaceTy { ty: self.ty.clone(), variant_index: Some(variant_idx) }
            }
            PlaceElem::Index(_) => {
                if let TyKind::Array(ty, _) | TyKind::Slice(ty) = self.ty.kind() {
                    PlaceTy::from_ty(ty.clone())
                } else {
                    bug!("index of no-array non-slice {self:?}")
                }
            }
        };
        Ok(place_ty)
    }

    fn field_ty(&self, genv: GlobalEnv, f: FieldIdx) -> QueryResult<Ty> {
        match self.ty.kind() {
            TyKind::Adt(adt_def, args) => {
                let variant_def = match self.variant_index {
                    None => adt_def.non_enum_variant(),
                    Some(variant_index) => {
                        assert!(adt_def.is_enum());
                        adt_def.variant(variant_index)
                    }
                };
                let field_def = &variant_def.fields[f];
                let ty = genv.lower_type_of(field_def.did)?;
                Ok(ty.subst(args))
            }
            TyKind::Tuple(tys) => Ok(tys[f.index()].clone()),
            _ => bug!("extracting field of non-tuple non-adt: {self:?}"),
        }
    }
}

/// Replicate the [`InferCtxt`] used for mir typeck by generating region variables for every region in
/// the `RegionInferenceContext`
///
/// [`InferCtxt`]: rustc_infer::infer::InferCtxt
pub(crate) fn replicate_infer_ctxt<'tcx>(
    tcx: TyCtxt<'tcx>,
    body_with_facts: &BodyWithBorrowckFacts<'tcx>,
) -> rustc_infer::infer::InferCtxt<'tcx> {
    let infcx = tcx.infer_ctxt().build();
    for info in &body_with_facts.region_inference_context.var_infos {
        infcx.next_region_var(info.origin);
    }
    infcx
}

/// The `FalseEdge/imaginary_target` edges mess up the `is_join_point` computation which creates spurious
/// join points that lose information e.g. in match arms, the k+1-th arm has the k-th arm as a "fake"
/// predecessor so we lose the assumptions specific to the k+1-th arm due to a spurious join. This code
/// corrects for this problem by computing the number of "fake" predecessors and decreasing them from
/// the total number of "predecessors" returned by `rustc`.  The option is to recompute "predecessors"
/// from scratch but we may miss some cases there. (see also [`is_join_point`])
///
/// [`is_join_point`]: crate::rustc::mir::Body::is_join_point
fn mk_fake_predecessors(
    basic_blocks: &IndexVec<BasicBlock, BasicBlockData>,
) -> IndexVec<BasicBlock, usize> {
    let mut res: IndexVec<BasicBlock, usize> = basic_blocks.iter().map(|_| 0).collect();

    for bb in basic_blocks {
        if let Some(terminator) = &bb.terminator {
            if let TerminatorKind::FalseEdge { imaginary_target, .. } = terminator.kind {
                res[imaginary_target] += 1;
            }
        }
    }
    res
}

impl fmt::Debug for Body<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        for (bb, data) in self.basic_blocks.iter_enumerated() {
            writeln!(
                f,
                "{bb:?}: {{{}",
                data.statements
                    .iter()
                    .filter(|stmt| !matches!(stmt.kind, StatementKind::Nop))
                    .format_with("", |stmt, f| f(&format_args!("\n    {stmt:?};")))
            )?;
            if let Some(terminator) = &data.terminator {
                writeln!(f, "    {terminator:?}")?;
            }
            writeln!(f, "}}\n")?;
        }
        Ok(())
    }
}

impl fmt::Debug for Statement {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match &self.kind {
            StatementKind::Assign(place, rvalue) => write!(f, "{place:?} = {rvalue:?}"),
            StatementKind::Nop => write!(f, "nop"),
            StatementKind::PlaceMention(place) => {
                write!(f, "PlaceMention({place:?})")
            }
            StatementKind::SetDiscriminant(place, variant_idx) => {
                write!(f, "discriminant({place:?}) = {variant_idx:?}")
            }
            StatementKind::FakeRead(box (cause, place)) => {
                write!(f, "FakeRead({cause:?}, {place:?})")
            }
            StatementKind::AscribeUserType(place, variance) => {
                write!(f, "AscribeUserType({place:?}, {variance:?})")
            }
        }
    }
}

impl<'tcx> fmt::Debug for Terminator<'tcx> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match &self.kind {
            TerminatorKind::Return => write!(f, "return"),
            TerminatorKind::Unreachable => write!(f, "unreachable"),
            TerminatorKind::Call { args, destination, target, unwind, resolved_call, .. } => {
                let (func, generic_args) = resolved_call;
                let fname = rustc_middle::ty::tls::with(|tcx| {
                    let path = tcx.def_path(*func);
                    path.data.iter().join("::")
                });
                write!(f, "{destination:?} = call {fname}")?;

                if !generic_args.lowered.is_empty() {
                    write!(f, "::<{:?}>", generic_args.lowered.iter().format(", "))?;
                }

                write!(
                    f,
                    "({args:?}) -> [return: {target}, unwind: {unwind:?}]",
                    args = args.iter().format(", "),
                    target = opt_bb_to_str(*target),
                )
            }
            TerminatorKind::SwitchInt { discr, targets } => {
                write!(
                    f,
                    "switchInt({discr:?}) -> [{}, otherwise: {:?}]",
                    targets
                        .iter()
                        .format_with(", ", |(val, bb), f| f(&format_args!("{val:?}: {bb:?}"))),
                    targets.otherwise()
                )
            }
            TerminatorKind::Goto { target } => {
                write!(f, "goto -> {target:?}")
            }
            TerminatorKind::Drop { place, target, unwind } => {
                write!(f, "drop({place:?}) -> [{target:?}, unwind: {unwind:?}]",)
            }
            TerminatorKind::Assert { cond, target, expected, msg } => {
                write!(
                    f,
                    "assert({cond:?} is expected to be {expected:?}, \"{msg:?}\") -> {target:?}"
                )
            }
            TerminatorKind::FalseEdge { real_target, imaginary_target } => {
                write!(f, "falseEdge -> [real: {real_target:?}, imaginary: {imaginary_target:?}]")
            }
            TerminatorKind::FalseUnwind { real_target, unwind } => {
                write!(f, "falseUnwind -> [real: {real_target:?}, cleanup: {unwind:?}]")
            }
            TerminatorKind::UnwindResume => write!(f, "resume"),
            TerminatorKind::CoroutineDrop => write!(f, "generator_drop"),
            TerminatorKind::Yield { value, resume, drop, resume_arg } => {
                write!(
                    f,
                    "{resume_arg:?} = yield({value:?}) -> [resume: {resume:?}, drop: {drop:?}]"
                )
            }
        }
    }
}

impl fmt::Debug for Place {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let mut p = format!("{:?}", self.local);
        let mut need_parens = false;
        for elem in &self.projection {
            match elem {
                PlaceElem::Field(f) => {
                    if need_parens {
                        p = format!("({p}).{}", u32::from(*f));
                        need_parens = false;
                    } else {
                        p = format!("{p}.{}", u32::from(*f));
                    }
                }
                PlaceElem::Deref => {
                    p = format!("*{p}");
                    need_parens = true;
                }
                PlaceElem::Downcast(variant_name, variant_idx) => {
                    if let Some(variant_name) = variant_name {
                        p = format!("{p} as {variant_name}");
                    } else {
                        p = format!("{p} as {variant_idx:?}");
                    }
                    need_parens = true;
                }
                PlaceElem::Index(v) => {
                    p = format!("{p}[{v:?}]");
                    need_parens = false;
                }
            }
        }
        write!(f, "{p}")
    }
}

impl fmt::Debug for Rvalue {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Rvalue::Use(op) => write!(f, "{op:?}"),
            Rvalue::Ref(r, BorrowKind::Mut { .. }, place) => {
                write!(f, "&{} mut {place:?}", region_to_string(*r))
            }
            Rvalue::Ref(r, BorrowKind::Shared, place) => {
                write!(f, "&{} {place:?}", region_to_string(*r))
            }
            Rvalue::Discriminant(place) => write!(f, "discriminant({place:?})"),
            Rvalue::BinaryOp(bin_op, op1, op2) => write!(f, "{bin_op:?}({op1:?}, {op2:?})"),
            Rvalue::CheckedBinaryOp(bin_op, op1, op2) => {
                write!(f, "Checked{bin_op:?}({op1:?}, {op2:?})")
            }
            Rvalue::UnaryOp(un_op, op) => write!(f, "{un_op:?}({op:?})"),
            Rvalue::Aggregate(AggregateKind::Adt(def_id, variant_idx, args), operands) => {
                let (fname, variant_name) = rustc_middle::ty::tls::with(|tcx| {
                    let variant_name = tcx.adt_def(*def_id).variant(*variant_idx).name;
                    let fname = tcx.def_path(*def_id).data.iter().join("::");
                    (fname, variant_name)
                });
                write!(f, "{fname}::{variant_name}")?;
                if !args.is_empty() {
                    write!(f, "<{:?}>", args.iter().format(", "),)?;
                }
                if !operands.is_empty() {
                    write!(f, "({:?})", operands.iter().format(", "))?;
                }
                Ok(())
            }
            Rvalue::Aggregate(AggregateKind::Closure(def_id, args), operands) => {
                write!(
                    f,
                    "closure({}, {args:?}, {:?})",
                    def_id_to_string(*def_id),
                    operands.iter().format(", ")
                )
            }
            Rvalue::Aggregate(AggregateKind::Coroutine(def_id, args), operands) => {
                write!(
                    f,
                    "generator({}, {args:?}, {:?})",
                    def_id_to_string(*def_id),
                    operands.iter().format(", ")
                )
            }
            Rvalue::Aggregate(AggregateKind::Array(_), args) => {
                write!(f, "[{:?}]", args.iter().format(", "))
            }
            Rvalue::Aggregate(AggregateKind::Tuple, args) => {
                write!(f, "({:?})", args.iter().format(", "))
            }
            Rvalue::Len(place) => write!(f, "Len({place:?})"),
            Rvalue::Cast(kind, op, ty) => write!(f, "{op:?} as {ty:?} [{kind:?}]"),
        }
    }
}

impl fmt::Debug for PointerCast {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            PointerCast::MutToConstPointer => write!(f, "MutToConstPointer"),
            PointerCast::Unsize => write!(f, "Unsize"),
        }
    }
}

impl fmt::Debug for CastKind {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            CastKind::IntToInt => write!(f, "IntToInt"),
            CastKind::FloatToInt => write!(f, "FloatToInt"),
            CastKind::IntToFloat => write!(f, "IntToFloat"),
            CastKind::PtrToPtr => write!(f, "PtrToPtr"),
            CastKind::Pointer(c) => write!(f, "Pointer({c:?})"),
        }
    }
}

impl fmt::Debug for Operand {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Copy(place) => write!(f, "copy {place:?}"),
            Self::Move(place) => write!(f, "move {place:?}"),
            Self::Constant(c) => write!(f, "{c:?}"),
        }
    }
}

impl fmt::Debug for Constant {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Constant::Int(n, int_ty) => write!(f, "{n}{}", int_ty.name_str()),
            Constant::Uint(n, uint_ty) => write!(f, "{n}{}", uint_ty.name_str()),
            Constant::Float(bits, float_ty) => write!(f, "{bits}{}", float_ty.name_str()),
            Constant::Bool(b) => write!(f, "{b}"),
            Constant::Unit => write!(f, "()"),
            Constant::Str => write!(f, "\"<opaque str>\""),
            Constant::Char => write!(f, "\"<opaque char>\""),
            Constant::Opaque(ty) => write!(f, "<opaque {:?}>", ty),
        }
    }
}

impl fmt::Debug for FakeReadCause {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FakeReadCause::ForLet(def_id) => write!(f, "ForLet({def_id:?})"),
            FakeReadCause::ForMatchedPlace(def_id) => write!(f, "ForMatchedPlace({def_id:?})"),
        }
    }
}

fn opt_bb_to_str(bb: Option<BasicBlock>) -> String {
    match bb {
        Some(bb) => format!("{bb:?}"),
        None => "None".to_string(),
    }
}
