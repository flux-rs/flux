<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Defines how flux represents refinement types internally. Definitions in this module are used during refinement type checking. A couple of important differences between definitions in this module and in `crate::fhir` are:"><title>flux_middle::rty - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-ca0dd0c4.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="flux_middle" data-themes="" data-resource-suffix="" data-rustdoc-version="1.93.0-nightly (c871d09d1 2025-11-24)" data-channel="nightly" data-search-js="search-680b2199.js" data-stringdex-js="stringdex-a3946164.js" data-settings-js="settings-c38705f0.js" ><script src="../../static.files/storage-e2aeef58.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-a410ff4d.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Module rty</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../flux_middle/index.html">flux_<wbr>middle</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module rty</a></h2><h3><a href="#reexports">Module Items</a></h3><ul class="block"><li><a href="#reexports" title="Re-exports">Re-exports</a></li><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#macros" title="Macros">Macros</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#constants" title="Constants">Constants</a></li><li><a href="#statics" title="Statics">Statics</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate flux_<wbr>middle</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">flux_middle</a></div><h1>Module <span>rty</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/flux_middle/rty/mod.rs.html#1-3234">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Defines how flux represents refinement types internally. Definitions in this module are used
during refinement type checking. A couple of important differences between definitions in this
module and in <a href="../fhir/index.html" title="mod flux_middle::fhir"><code>crate::fhir</code></a> are:</p>
<ul>
<li>Types in this module use debruijn indices to represent local binders.</li>
<li>Data structures are interned so they can be cheaply cloned.</li>
</ul>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">Â§</a></h2><dl class="item-table reexports"><dt id="reexport.FuncInfo"><code>pub use normalize::<a class="struct" href="normalize/struct.FuncInfo.html" title="struct flux_middle::rty::normalize::FuncInfo">FuncInfo</a>;</code></dt><dt id="reexport.NormalizedDefns"><code>pub use normalize::<a class="struct" href="normalize/struct.NormalizedDefns.html" title="struct flux_middle::rty::normalize::NormalizedDefns">NormalizedDefns</a>;</code></dt><dt id="reexport.local_deps"><code>pub use normalize::<a class="fn" href="normalize/fn.local_deps.html" title="fn flux_middle::rty::normalize::local_deps">local_deps</a>;</code></dt><dt id="reexport.InferMode"><code>pub use crate::fhir::<a class="enum" href="../fhir/enum.InferMode.html" title="enum flux_middle::fhir::InferMode">InferMode</a>;</code></dt><dt><code>pub use flux_rustc_bridge::ty::<a class="enum" href="enum.Region.html" title="enum flux_middle::rty::Region">Region</a>::*;</code></dt></dl><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="mod" href="binder/index.html" title="mod flux_middle::rty::binder">binder</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="mod" href="canonicalize/index.html" title="mod flux_middle::rty::canonicalize">canonicalize</a></dt><dd>A canonical type is a type where all <a href="enum.TyKind.html#variant.Exists" title="variant flux_middle::rty::TyKind::Exists">existentials</a> and <a href="enum.TyKind.html#variant.Constr" title="variant flux_middle::rty::TyKind::Constr">constraint predicates</a> are <em>hoisted</em> to
the top level. For example, the canonical version of <code>âˆƒa. {âˆƒb. i32[a + b] | b &gt; 0}</code> is
<code>âˆƒa,b. {i32[a + b] | b &gt; 0}</code>.</dd><dt><a class="mod" href="expr/index.html" title="mod flux_middle::rty::expr">expr</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="mod" href="fold/index.html" title="mod flux_middle::rty::fold">fold</a></dt><dd>This modules follows the implementation of folding in rustc. For more information read the
documentation in <code>rustc_type_ir::fold</code>.</dd><dt><a class="mod" href="normalize/index.html" title="mod flux_middle::rty::normalize">normalize</a></dt><dt><a class="mod" href="pretty/index.html" title="mod flux_middle::rty::pretty">pretty</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="mod" href="refining/index.html" title="mod flux_middle::rty::refining">refining</a></dt><dd><em>Refining</em> is the process of generating a refined version of a rust type.</dd><dt><a class="mod" href="region_matching/index.html" title="mod flux_middle::rty::region_matching">region_<wbr>matching</a></dt><dt><a class="mod" href="subst/index.html" title="mod flux_middle::rty::subst">subst</a></dt></dl><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="macro" href="macro.Bool.html" title="macro flux_middle::rty::Bool">Bool</a></dt><dt><a class="macro" href="macro.Char.html" title="macro flux_middle::rty::Char">Char</a></dt><dt><a class="macro" href="macro.Int.html" title="macro flux_middle::rty::Int">Int</a></dt><dt><a class="macro" href="macro.Ref.html" title="macro flux_middle::rty::Ref">Ref</a></dt><dt><a class="macro" href="macro.Uint.html" title="macro flux_middle::rty::Uint">Uint</a></dt></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.AdtDef.html" title="struct flux_middle::rty::AdtDef">AdtDef</a></dt><dt><a class="struct" href="struct.AdtDefData.html" title="struct flux_middle::rty::AdtDefData">AdtDef<wbr>Data</a></dt><dt><a class="struct" href="struct.AdtSortDef.html" title="struct flux_middle::rty::AdtSortDef">AdtSort<wbr>Def</a></dt><dd>The definition of the data sort automatically generated for a struct or enum.</dd><dt><a class="struct" href="struct.AdtSortDefData.html" title="struct flux_middle::rty::AdtSortDefData">AdtSort<wbr>DefData</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="struct" href="struct.AdtSortVariant.html" title="struct flux_middle::rty::AdtSortVariant">AdtSort<wbr>Variant</a></dt><dt><a class="struct" href="struct.AliasReft.html" title="struct flux_middle::rty::AliasReft">Alias<wbr>Reft</a></dt><dt><a class="struct" href="struct.AliasTy.html" title="struct flux_middle::rty::AliasTy">AliasTy</a></dt><dt><a class="struct" href="struct.AssocRefinements.html" title="struct flux_middle::rty::AssocRefinements">Assoc<wbr>Refinements</a></dt><dt><a class="struct" href="struct.AssocReft.html" title="struct flux_middle::rty::AssocReft">Assoc<wbr>Reft</a></dt><dt><a class="struct" href="struct.Binder.html" title="struct flux_middle::rty::Binder">Binder</a></dt><dt><a class="struct" href="struct.BoundReft.html" title="struct flux_middle::rty::BoundReft">Bound<wbr>Reft</a></dt><dt><a class="struct" href="struct.BoundRegion.html" title="struct flux_middle::rty::BoundRegion">Bound<wbr>Region</a></dt><dt><a class="struct" href="struct.BvSizeVid.html" title="struct flux_middle::rty::BvSizeVid">BvSize<wbr>Vid</a></dt><dd>A <em>b</em>it <em>v</em>ector <em>size</em> <em>v</em>variable <em>id</em></dd><dt><a class="struct" href="struct.Clause.html" title="struct flux_middle::rty::Clause">Clause</a></dt><dt><a class="struct" href="struct.Const.html" title="struct flux_middle::rty::Const">Const</a></dt><dt><a class="struct" href="struct.CoroutineObligPredicate.html" title="struct flux_middle::rty::CoroutineObligPredicate">Coroutine<wbr>Oblig<wbr>Predicate</a></dt><dt><a class="struct" href="struct.ESpan.html" title="struct flux_middle::rty::ESpan">ESpan</a></dt><dt><a class="struct" href="struct.EVid.html" title="struct flux_middle::rty::EVid">EVid</a></dt><dd><em>E</em>xistential <em>v</em>ariable <em>id</em></dd><dt><a class="struct" href="struct.EarlyBinder.html" title="struct flux_middle::rty::EarlyBinder">Early<wbr>Binder</a></dt><dt><a class="struct" href="struct.EarlyReftParam.html" title="struct flux_middle::rty::EarlyReftParam">Early<wbr>Reft<wbr>Param</a></dt><dt><a class="struct" href="struct.ExistentialProjection.html" title="struct flux_middle::rty::ExistentialProjection">Existential<wbr>Projection</a></dt><dt><a class="struct" href="struct.ExistentialTraitRef.html" title="struct flux_middle::rty::ExistentialTraitRef">Existential<wbr>Trait<wbr>Ref</a></dt><dt><a class="struct" href="struct.Expr.html" title="struct flux_middle::rty::Expr">Expr</a></dt><dt><a class="struct" href="struct.FnOutput.html" title="struct flux_middle::rty::FnOutput">FnOutput</a></dt><dt><a class="struct" href="struct.FnSig.html" title="struct flux_middle::rty::FnSig">FnSig</a></dt><dt><a class="struct" href="struct.FnTraitPredicate.html" title="struct flux_middle::rty::FnTraitPredicate">FnTrait<wbr>Predicate</a></dt><dt><a class="struct" href="struct.FuncSort.html" title="struct flux_middle::rty::FuncSort">Func<wbr>Sort</a></dt><dt><a class="struct" href="struct.GenericParamDef.html" title="struct flux_middle::rty::GenericParamDef">Generic<wbr>Param<wbr>Def</a></dt><dt><a class="struct" href="struct.GenericPredicates.html" title="struct flux_middle::rty::GenericPredicates">Generic<wbr>Predicates</a></dt><dt><a class="struct" href="struct.Generics.html" title="struct flux_middle::rty::Generics">Generics</a></dt><dt><a class="struct" href="struct.Invariant.html" title="struct flux_middle::rty::Invariant">Invariant</a></dt><dt><a class="struct" href="struct.KVar.html" title="struct flux_middle::rty::KVar">KVar</a></dt><dd>In theory a kvar is just an unknown predicate that can use some variables in scope. In practice,
fixpoint makes a difference between the first and the rest of the arguments, the first one being
the kvarâ€™s <em>self argument</em>. Fixpoint will only instantiate qualifiers that use the self argument.
Flux generalizes the self argument to be a list. We call the rest of the arguments the <em>scope</em>.</dd><dt><a class="struct" href="struct.KVid.html" title="struct flux_middle::rty::KVid">KVid</a></dt><dt><a class="struct" href="struct.Lambda.html" title="struct flux_middle::rty::Lambda">Lambda</a></dt><dd>A lambda abstraction with an elaborated output sort. We need the output sort of lambdas for
encoding into fixpoint</dd><dt><a class="struct" href="struct.LocalTableInContext.html" title="struct flux_middle::rty::LocalTableInContext">Local<wbr>Table<wbr>InContext</a></dt><dt><a class="struct" href="struct.LocalTableInContextMut.html" title="struct flux_middle::rty::LocalTableInContextMut">Local<wbr>Table<wbr>InContext<wbr>Mut</a></dt><dt><a class="struct" href="struct.Name.html" title="struct flux_middle::rty::Name">Name</a></dt><dt><a class="struct" href="struct.OutlivesPredicate.html" title="struct flux_middle::rty::OutlivesPredicate">Outlives<wbr>Predicate</a></dt><dt><a class="struct" href="struct.ParamSort.html" title="struct flux_middle::rty::ParamSort">Param<wbr>Sort</a></dt><dd><a href="struct.ParamSort.html" title="struct flux_middle::rty::ParamSort"><code>ParamSort</code></a> is used for polymorphic sorts (<code>Set</code>, <code>Map</code>, etc.) and <a href="enum.BvSize.html#variant.Param" title="variant flux_middle::rty::BvSize::Param">bit-vector size parameters</a>.
They should occur â€œboundâ€ under a <a href="struct.PolyFuncSort.html" title="struct flux_middle::rty::PolyFuncSort"><code>PolyFuncSort</code></a> or an <a href="struct.AdtSortDef.html" title="struct flux_middle::rty::AdtSortDef"><code>AdtSortDef</code></a>. We assume thereâ€™s a
single binder and a <a href="struct.ParamSort.html" title="struct flux_middle::rty::ParamSort"><code>ParamSort</code></a> represents a variable as an index into the list of variables
bound by that binder, i.e., the representation doesntâ€™t support higher-ranked sorts.</dd><dt><a class="struct" href="struct.Path.html" title="struct flux_middle::rty::Path">Path</a></dt><dt><a class="struct" href="struct.PolyFuncSort.html" title="struct flux_middle::rty::PolyFuncSort">Poly<wbr>Func<wbr>Sort</a></dt><dd>A polymorphic function sort parametric over <a href="enum.Sort.html" title="enum flux_middle::rty::Sort">sorts</a> or <a href="enum.BvSize.html#variant.Param" title="variant flux_middle::rty::BvSize::Param">bit-vector sizes</a>.</dd><dt><a class="struct" href="struct.PrettyMap.html" title="struct flux_middle::rty::PrettyMap">Pretty<wbr>Map</a></dt><dt><a class="struct" href="struct.PrimOpProp.html" title="struct flux_middle::rty::PrimOpProp">Prim<wbr>OpProp</a></dt><dd>A <code>PrimOpProp</code> is a single property for a primitive operation which
can be conjoined to get the definition of the <a href="struct.PrimRel.html" title="struct flux_middle::rty::PrimRel"><code>PrimRel</code></a> for that
primitive operation.</dd><dt><a class="struct" href="struct.PrimRel.html" title="struct flux_middle::rty::PrimRel">PrimRel</a></dt><dt><a class="struct" href="struct.ProjectionPredicate.html" title="struct flux_middle::rty::ProjectionPredicate">Projection<wbr>Predicate</a></dt><dt><a class="struct" href="struct.Qualifier.html" title="struct flux_middle::rty::Qualifier">Qualifier</a></dt><dt><a class="struct" href="struct.Real.html" title="struct flux_middle::rty::Real">Real</a></dt><dt><a class="struct" href="struct.RefineParam.html" title="struct flux_middle::rty::RefineParam">Refine<wbr>Param</a></dt><dt><a class="struct" href="struct.RefinementGenerics.html" title="struct flux_middle::rty::RefinementGenerics">Refinement<wbr>Generics</a></dt><dt><a class="struct" href="struct.SortCstr.html" title="struct flux_middle::rty::SortCstr">Sort<wbr>Cstr</a></dt><dd>A <em>sort constraint</em> is a set of operations a sort must support.</dd><dt><a class="struct" href="struct.SortVid.html" title="struct flux_middle::rty::SortVid">SortVid</a></dt><dd>A <em>sort</em> <em>v</em>variable <em>id</em></dd><dt><a class="struct" href="struct.SubsetTy.html" title="struct flux_middle::rty::SubsetTy">Subset<wbr>Ty</a></dt><dd>A subset type is a simplified version of a type that has the form <code>{b[e] | p}</code> where <code>b</code> is a
<a href="enum.BaseTy.html" title="enum flux_middle::rty::BaseTy"><code>BaseTy</code></a>, <code>e</code> a refinement index, and <code>p</code> a predicate.</dd><dt><a class="struct" href="struct.TraitPredicate.html" title="struct flux_middle::rty::TraitPredicate">Trait<wbr>Predicate</a></dt><dt><a class="struct" href="struct.TraitRef.html" title="struct flux_middle::rty::TraitRef">Trait<wbr>Ref</a></dt><dt><a class="struct" href="struct.Ty.html" title="struct flux_middle::rty::Ty">Ty</a></dt><dt><a class="struct" href="struct.VariantSig.html" title="struct flux_middle::rty::VariantSig">Variant<wbr>Sig</a></dt><dt><a class="struct" href="struct.WfckResults.html" title="struct flux_middle::rty::WfckResults">Wfck<wbr>Results</a></dt><dt><a class="struct" href="struct.AdtFlags.html" title="struct flux_middle::rty::AdtFlags">AdtFlags</a></dt><dt><a class="struct" href="struct.BoundVar.html" title="struct flux_middle::rty::BoundVar">Bound<wbr>Var</a></dt><dt><a class="struct" href="struct.ConstVid.html" title="struct flux_middle::rty::ConstVid">Const<wbr>Vid</a></dt><dd>A <strong><code>const</code></strong> <strong>v</strong>ariable <strong>ID</strong>.</dd><dt><a class="struct" href="struct.DebruijnIndex.html" title="struct flux_middle::rty::DebruijnIndex">Debruijn<wbr>Index</a></dt><dd>A <a href="https://en.wikipedia.org/wiki/De_Bruijn_index">De Bruijn index</a> is a standard means of representing
regions (and perhaps later types) in a higher-ranked setting. In
particular, imagine a type like this:</dd><dt><a class="struct" href="struct.EarlyParamRegion.html" title="struct flux_middle::rty::EarlyParamRegion">Early<wbr>Param<wbr>Region</a></dt><dt><a class="struct" href="struct.LateParamRegion.html" title="struct flux_middle::rty::LateParamRegion">Late<wbr>Param<wbr>Region</a></dt><dd>The parameter representation of late-bound function parameters, â€œsome region
at least as big as the scope <code>fr.scope</code>â€.</dd><dt><a class="struct" href="struct.ParamConst.html" title="struct flux_middle::rty::ParamConst">Param<wbr>Const</a></dt><dt><a class="struct" href="struct.ParamTy.html" title="struct flux_middle::rty::ParamTy">ParamTy</a></dt><dt><a class="struct" href="struct.RegionVid.html" title="struct flux_middle::rty::RegionVid">Region<wbr>Vid</a></dt><dd>A <strong>region</strong> <strong>v</strong>ariable <strong>ID</strong>.</dd><dt><a class="struct" href="struct.ScalarInt.html" title="struct flux_middle::rty::ScalarInt">Scalar<wbr>Int</a></dt><dd>The raw bytes of a simple value.</dd><dt><a class="struct" href="struct.TyVid.html" title="struct flux_middle::rty::TyVid">TyVid</a></dt><dd>A <strong>ty</strong>pe <strong>v</strong>ariable <strong>ID</strong>.</dd><dt><a class="struct" href="struct.VariantIdx.html" title="struct flux_middle::rty::VariantIdx">Variant<wbr>Idx</a></dt><dd>The <em>source-order</em> index of a variant in a type.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.AggregateKind.html" title="enum flux_middle::rty::AggregateKind">Aggregate<wbr>Kind</a></dt><dt><a class="enum" href="enum.AliasKind.html" title="enum flux_middle::rty::AliasKind">Alias<wbr>Kind</a></dt><dt><a class="enum" href="enum.BaseTy.html" title="enum flux_middle::rty::BaseTy">BaseTy</a></dt><dt><a class="enum" href="enum.BinOp.html" title="enum flux_middle::rty::BinOp">BinOp</a></dt><dt><a class="enum" href="enum.BoundReftKind.html" title="enum flux_middle::rty::BoundReftKind">Bound<wbr>Reft<wbr>Kind</a></dt><dt><a class="enum" href="enum.BoundVariableKind.html" title="enum flux_middle::rty::BoundVariableKind">Bound<wbr>Variable<wbr>Kind</a></dt><dt><a class="enum" href="enum.BvSize.html" title="enum flux_middle::rty::BvSize">BvSize</a></dt><dd>The size of a <a href="enum.Sort.html#variant.BitVec" title="variant flux_middle::rty::Sort::BitVec">bit-vector</a></dd><dt><a class="enum" href="enum.CastKind.html" title="enum flux_middle::rty::CastKind">Cast<wbr>Kind</a></dt><dt><a class="enum" href="enum.ClauseKind.html" title="enum flux_middle::rty::ClauseKind">Clause<wbr>Kind</a></dt><dt><a class="enum" href="enum.Coercion.html" title="enum flux_middle::rty::Coercion">Coercion</a></dt><dt><a class="enum" href="enum.ConstKind.html" title="enum flux_middle::rty::ConstKind">Const<wbr>Kind</a></dt><dt><a class="enum" href="enum.Constant.html" title="enum flux_middle::rty::Constant">Constant</a></dt><dt><a class="enum" href="enum.ConstantInfo.html" title="enum flux_middle::rty::ConstantInfo">Constant<wbr>Info</a></dt><dt><a class="enum" href="enum.Ctor.html" title="enum flux_middle::rty::Ctor">Ctor</a></dt><dt><a class="enum" href="enum.Ensures.html" title="enum flux_middle::rty::Ensures">Ensures</a></dt><dt><a class="enum" href="enum.ExistentialPredicate.html" title="enum flux_middle::rty::ExistentialPredicate">Existential<wbr>Predicate</a></dt><dt><a class="enum" href="enum.ExprKind.html" title="enum flux_middle::rty::ExprKind">Expr<wbr>Kind</a></dt><dt><a class="enum" href="enum.FieldProj.html" title="enum flux_middle::rty::FieldProj">Field<wbr>Proj</a></dt><dt><a class="enum" href="enum.GenericArg.html" title="enum flux_middle::rty::GenericArg">Generic<wbr>Arg</a></dt><dt><a class="enum" href="enum.GenericParamDefKind.html" title="enum flux_middle::rty::GenericParamDefKind">Generic<wbr>Param<wbr>DefKind</a></dt><dt><a class="enum" href="enum.HoleKind.html" title="enum flux_middle::rty::HoleKind">Hole<wbr>Kind</a></dt><dd>The position where a <a href="enum.ExprKind.html#variant.Hole" title="variant flux_middle::rty::ExprKind::Hole">hole</a> appears. This determines how it will be inferred. This is related
to, but not the same as, an <a href="../fhir/enum.InferMode.html" title="enum flux_middle::fhir::InferMode"><code>InferMode</code></a>.</dd><dt><a class="enum" href="enum.InternalFuncKind.html" title="enum flux_middle::rty::InternalFuncKind">Internal<wbr>Func<wbr>Kind</a></dt><dd>Primitive Properties</dd><dt><a class="enum" href="enum.Loc.html" title="enum flux_middle::rty::Loc">Loc</a></dt><dt><a class="enum" href="enum.NameProvenance.html" title="enum flux_middle::rty::NameProvenance">Name<wbr>Provenance</a></dt><dt><a class="enum" href="enum.Opaqueness.html" title="enum flux_middle::rty::Opaqueness">Opaqueness</a></dt><dd>Option-like enum to explicitly mark that we donâ€™t have information about an ADT because it was
annotated with <code>#[flux::opaque]</code>. Note that only structs can be marked as opaque.</dd><dt><a class="enum" href="enum.PrettyVar.html" title="enum flux_middle::rty::PrettyVar">Pretty<wbr>Var</a></dt><dt><a class="enum" href="enum.PtrKind.html" title="enum flux_middle::rty::PtrKind">PtrKind</a></dt><dt><a class="enum" href="enum.QualifierKind.html" title="enum flux_middle::rty::QualifierKind">Qualifier<wbr>Kind</a></dt><dt><a class="enum" href="enum.Region.html" title="enum flux_middle::rty::Region">Region</a></dt><dt><a class="enum" href="enum.Sort.html" title="enum flux_middle::rty::Sort">Sort</a></dt><dt><a class="enum" href="enum.SortArg.html" title="enum flux_middle::rty::SortArg">SortArg</a></dt><dd>An argument for a generic parameter in a <a href="enum.Sort.html" title="enum flux_middle::rty::Sort"><code>Sort</code></a> which can be either a generic sort or a
generic bit-vector size.</dd><dt><a class="enum" href="enum.SortCtor.html" title="enum flux_middle::rty::SortCtor">Sort<wbr>Ctor</a></dt><dt><a class="enum" href="enum.SortParamKind.html" title="enum flux_middle::rty::SortParamKind">Sort<wbr>Param<wbr>Kind</a></dt><dd>See <a href="struct.PolyFuncSort.html" title="struct flux_middle::rty::PolyFuncSort"><code>PolyFuncSort</code></a></dd><dt><a class="enum" href="enum.SortVarVal.html" title="enum flux_middle::rty::SortVarVal">Sort<wbr>VarVal</a></dt><dd>Unification value for sort variables used during sort checking.</dd><dt><a class="enum" href="enum.SpecFuncKind.html" title="enum flux_middle::rty::SpecFuncKind">Spec<wbr>Func<wbr>Kind</a></dt><dt><a class="enum" href="enum.StaticInfo.html" title="enum flux_middle::rty::StaticInfo">Static<wbr>Info</a></dt><dt><a class="enum" href="enum.TyKind.html" title="enum flux_middle::rty::TyKind">TyKind</a></dt><dt><a class="enum" href="enum.TyOrBase.html" title="enum flux_middle::rty::TyOrBase">TyOr<wbr>Base</a></dt><dt><a class="enum" href="enum.TyOrCtor.html" title="enum flux_middle::rty::TyOrCtor">TyOr<wbr>Ctor</a></dt><dt><a class="enum" href="enum.UnOp.html" title="enum flux_middle::rty::UnOp">UnOp</a></dt><dt><a class="enum" href="enum.Var.html" title="enum flux_middle::rty::Var">Var</a></dt><dt><a class="enum" href="enum.BoundRegionKind.html" title="enum flux_middle::rty::BoundRegionKind">Bound<wbr>Region<wbr>Kind</a></dt><dt><a class="enum" href="enum.ClosureKind.html" title="enum flux_middle::rty::ClosureKind">Closure<wbr>Kind</a></dt><dd>Represents the various closure traits in the language. This
will determine the type of the environment (<code>self</code>, in the
desugaring) argument that the closure expects.</dd><dt><a class="enum" href="enum.FloatTy.html" title="enum flux_middle::rty::FloatTy">FloatTy</a></dt><dt><a class="enum" href="enum.IntTy.html" title="enum flux_middle::rty::IntTy">IntTy</a></dt><dt><a class="enum" href="enum.LateParamRegionKind.html" title="enum flux_middle::rty::LateParamRegionKind">Late<wbr>Param<wbr>Region<wbr>Kind</a></dt><dd>When liberating bound regions, we map their <a href="enum.BoundRegionKind.html" title="enum flux_middle::rty::BoundRegionKind"><code>BoundRegionKind</code></a>
to this as we need to track the index of anonymous regions. We
otherwise end up liberating multiple bound regions to the same
late-bound region.</dd><dt><a class="enum" href="enum.Mutability.html" title="enum flux_middle::rty::Mutability">Mutability</a></dt><dt><a class="enum" href="enum.UintTy.html" title="enum flux_middle::rty::UintTy">UintTy</a></dt></dl><h2 id="constants" class="section-header">Constants<a href="#constants" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="constant" href="constant.SELF_PARAM_TY.html" title="constant flux_middle::rty::SELF_PARAM_TY">SELF_<wbr>PARAM_<wbr>TY</a></dt><dt><a class="constant" href="constant.FIRST_VARIANT.html" title="constant flux_middle::rty::FIRST_VARIANT">FIRST_<wbr>VARIANT</a></dt><dd>Equivalent to <code>VariantIdx(0)</code>.</dd><dt><a class="constant" href="constant.INNERMOST.html" title="constant flux_middle::rty::INNERMOST">INNERMOST</a></dt></dl><h2 id="statics" class="section-header">Statics<a href="#statics" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="static" href="static.INT_TYS.html" title="static flux_middle::rty::INT_TYS">INT_TYS</a></dt><dt><a class="static" href="static.UINT_TYS.html" title="static flux_middle::rty::UINT_TYS">UINT_<wbr>TYS</a></dt></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.GenericArgsExt.html" title="trait flux_middle::rty::GenericArgsExt">Generic<wbr>Args<wbr>Ext</a></dt><dt><a class="trait" href="trait.RefineArgsExt.html" title="trait flux_middle::rty::RefineArgsExt">Refine<wbr>Args<wbr>Ext</a></dt></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.auto_strong.html" title="fn flux_middle::rty::auto_strong">auto_<wbr>strong</a></dt><dd>The <a href="fn.auto_strong.html" title="fn flux_middle::rty::auto_strong"><code>auto_strong</code></a> function transforms function signatures by automatically converting
mutable reference parameters into strong references with associated ensures clauses. This
transformation is applied only when the function signature does not already contain region
variables in its return type.</dd><dt><a class="fn" href="fn.can_auto_strong.html" title="fn flux_middle::rty::can_auto_strong">can_<wbr>auto_<wbr>strong</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="fn" href="fn.char_invariants.html" title="fn flux_middle::rty::char_invariants">char_<wbr>invariants</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="fn" href="fn.int_invariants.html" title="fn flux_middle::rty::int_invariants">int_<wbr>invariants</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="fn" href="fn.slice_invariants.html" title="fn flux_middle::rty::slice_invariants">slice_<wbr>invariants</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>returns the same invariants as for <code>usize</code> which is the length of a slice</dd><dt><a class="fn" href="fn.to_closure_sig.html" title="fn flux_middle::rty::to_closure_sig">to_<wbr>closure_<wbr>sig</a></dt><dt><a class="fn" href="fn.uint_invariants.html" title="fn flux_middle::rty::uint_invariants">uint_<wbr>invariants</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="type" href="type.BoundVariableKinds.html" title="type flux_middle::rty::BoundVariableKinds">Bound<wbr>Variable<wbr>Kinds</a></dt><dt><a class="type" href="type.Clauses.html" title="type flux_middle::rty::Clauses">Clauses</a></dt><dt><a class="type" href="type.GenericArgs.html" title="type flux_middle::rty::GenericArgs">Generic<wbr>Args</a></dt><dt><a class="type" href="type.ItemLocalMap.html" title="type flux_middle::rty::ItemLocalMap">Item<wbr>Local<wbr>Map</a></dt><dt><a class="type" href="type.List.html" title="type flux_middle::rty::List">List</a></dt><dt><a class="type" href="type.PolyExistentialPredicate.html" title="type flux_middle::rty::PolyExistentialPredicate">Poly<wbr>Existential<wbr>Predicate</a></dt><dt><a class="type" href="type.PolyExistentialTraitRef.html" title="type flux_middle::rty::PolyExistentialTraitRef">Poly<wbr>Existential<wbr>Trait<wbr>Ref</a></dt><dt><a class="type" href="type.PolyFnSig.html" title="type flux_middle::rty::PolyFnSig">Poly<wbr>FnSig</a></dt><dt><a class="type" href="type.PolyProjectionPredicate.html" title="type flux_middle::rty::PolyProjectionPredicate">Poly<wbr>Projection<wbr>Predicate</a></dt><dt><a class="type" href="type.PolyTraitPredicate.html" title="type flux_middle::rty::PolyTraitPredicate">Poly<wbr>Trait<wbr>Predicate</a></dt><dt><a class="type" href="type.PolyTraitRef.html" title="type flux_middle::rty::PolyTraitRef">Poly<wbr>Trait<wbr>Ref</a></dt><dt><a class="type" href="type.PolyVariant.html" title="type flux_middle::rty::PolyVariant">Poly<wbr>Variant</a></dt><dt><a class="type" href="type.PolyVariants.html" title="type flux_middle::rty::PolyVariants">Poly<wbr>Variants</a></dt><dt><a class="type" href="type.RefineArgs.html" title="type flux_middle::rty::RefineArgs">Refine<wbr>Args</a></dt><dt><a class="type" href="type.RegionOutlivesPredicate.html" title="type flux_middle::rty::RegionOutlivesPredicate">Region<wbr>Outlives<wbr>Predicate</a></dt><dt><a class="type" href="type.SubsetTyCtor.html" title="type flux_middle::rty::SubsetTyCtor">Subset<wbr>TyCtor</a></dt><dd>A type constructor meant to be used as generic a argument of <a href="enum.GenericParamDefKind.html#variant.Base" title="variant flux_middle::rty::GenericParamDefKind::Base">kind base</a>. This is just an alias
to <a href="struct.Binder.html" title="struct flux_middle::rty::Binder"><code>Binder&lt;SubsetTy&gt;</code></a>, but we expect the binder to have a single bound variable of the sort of
the underlying <a href="struct.SubsetTy.html#structfield.bty" title="field flux_middle::rty::SubsetTy::bty">base type</a>.</dd><dt><a class="type" href="type.TyCtor.html" title="type flux_middle::rty::TyCtor">TyCtor</a></dt><dt><a class="type" href="type.TypeOutlivesPredicate.html" title="type flux_middle::rty::TypeOutlivesPredicate">Type<wbr>Outlives<wbr>Predicate</a></dt></dl></section></div></main></body></html>