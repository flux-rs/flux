searchState.loadedDescShard("flux_syntax", 0, "Contains the error value\nContains the success value\nAdvances the underlying cursor to the next token\nAdvances the underlying cursor by the requested number of …\nLooks at the next token and advances the cursor if it …\nLooks at the next two tokens advacing the cursor if there…\nReturns the token (and span) at the requested position.\nIf the next token matches the requested type of token …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSee documentation for <code>Lookahead1</code>\nLooks at the next token in the underlying cursor to …\nLooks at the next two tokens\nLooks at the next three tokens\nLooks whether the next token matches a binary operation. …\n<code>{ ... }</code>\n<code>[ ... ]</code>\nDescribes how a sequence of token trees is delimited. …\n<code>∅ ... ∅</code> An invisible delimiter, that may, for example, …\nA literal token.\n<code>( ... )</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the highest byte position the cursor has yielded. …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the starting byte position of the next token\n&amp;&amp;\n&amp;\n|\n^\n== != &lt; &gt; &lt;= &gt;=\n&lt;=&gt;\n=&gt;\n||\nunary - and !\n/ %\n&lt;&lt; &gt;&gt;\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSupport for “peeking” into the token stream to decide …\n<code>⟨block⟩ := { ⟨let_decls⟩ ⟨expr⟩ }</code>\n<code>⟨block_expr⟩ = ⟨let_decl⟩* ⟨expr⟩</code>\n<code>⟨epath⟩ := ⟨ident⟩ ⟨ :: ⟨ident⟩ ⟩*</code>\n…\n<code>⟨let_decl⟩ := let ⟨refine_param⟩ = ⟨expr⟩ ;</code>\nImplementation of parser combinators\nA struct that can be used to match any identifier\nA struct that can be used to match any literal\nThis is the same as <code>RAngle</code> but for opening angle brackets.\nSupport for checking the next token in a stream to decide …\nA trait for testing whether a token matches a rule.\nThere are some lexing ambiguities with <code>&gt;&gt;</code> which can …\nLike <code>ParseCtxt::advance_if</code> but it records the expected …\nA string representation of the list of tokens matched by …\nList of “expected” tokens that have been peeked by …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate an <code>unexpected token</code> error based on the expected …\nReturns true if a token matches this rule\nLike <code>ParseCtxt::lookahead1</code> but it records the expected …\nParses an item surrounded by an opening an closing …\nParses a list of zero or more items separated by a …\nParses a list of zero or more items separated by a …\nParses a list of zero or more items. Parsing stops when …\nParses a list of one ore more items separated by the …\nParses a list of zero or more items. Parsing continues …\n<code>&lt;qself as path&gt;::name</code>\nA <em>base</em> sort, e.g., <code>int</code> or <code>bool</code>.\nty\n<code>@n</code> or <code>#n</code>, the span corresponds to the span of the …\na bitvector sort, e.g., bitvec&lt;32&gt;\nexample <code>a: i32{a &gt; 0}</code>\nConstrained type: an exists without binder\nB{v: r}\nA <code>Path</code> but for refinement expressions\nA <em>function</em> sort of the form <code>(bi,...) -&gt; bo</code> where <code>bi..</code> and …\nThe <code>NodeId</code> is used to resolve the type to a corresponding …\n<code>B[r]</code>\nA sort that needs to be inferred.\nA literal token.\nA <code>NodeId</code> is a unique identifier we assign to some AST …\nA predicate that needs to hold\nA punctuated sequence of values of type <code>T</code> separated by …\nMutable or shared reference\nA <code>Path</code> but for sorts.\nA compressed span.\nA global function definition. It can be either an …\nexample <code>v: &amp;strg i32</code>\nA type with an optional binder, e.g, <code>i32</code>, <code>x: i32</code> or …\nA type constraint on a location\nThe sort arguments, i.e., the list <code>[int, bool]</code> in …\nBody of the function. If not present this definition …\nReturns true if either this <code>Punctuated</code> is empty, or it has …\nexample: <code>*x: i32{v. v = n+1}</code> or just <code>x &gt; 10</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nIs this function “hidden” i.e. to be considered as …\nBinders are not allowed at this position, but we parse …\nexample: <code>i32&lt;@n&gt;</code>\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDetermines whether this punctuated sequence is empty, …\nWhether the struct contains any path that needs to be …\nWhether the enum contains any path that needs to be …\nOptional list of universally quantified parameters\nAppends a syntax tree node onto the end of this punctuated …\nexample: <code>requires n &gt; 0</code>\nexample <code>i32{v:v &gt;= 0}</code>\nThe segments in the path\nsource span\nDetermines whether this punctuated sequence ends with a …\nA visitor for types in <code>surface</code>")