searchState.loadedDescShard("flux_syntax", 0, "Contains the error value\nContains the success value\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>{ ... }</code>\n<code>[ ... ]</code>\nDescribes how a sequence of token trees is delimited. …\n<code>∅ ... ∅</code> An invisible delimiter, that may, for example, …\nA literal token.\n<code>( ... )</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the highest byte position the cursor has yielded. …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the starting byte position of the token the cursor …\n&amp;&amp;\n&amp;\n|\n^\n== != &lt; &gt; &lt;= &gt;=\n&lt;=&gt;\n=&gt;\n||\n/ %\n&lt;&lt; &gt;&gt;\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n⟨asyncness⟩ := async?\n⟨atom⟩ := ⟨if_expr⟩ | ⟨lit⟩ | ( ⟨expr⟩ ) | …\n⟨base_sort⟩ := bitvec &lt; ⟨u32⟩ &gt; | ⟨sort_path⟩ &lt;…\n⟨block_expr⟩ := { ⟨expr⟩ }\n⟨bty⟩ { ⟨ident⟩ : ⟨expr⟩ }\n⟨bty⟩ [ ⟨refine_arg⟩,* ] |  ⟨bty⟩ { …\n⟨constructor_arg⟩ :=  ⟨ident⟩ : ⟨expr⟩ |  ..\n⟨ensures_clause⟩ :=  ⟨ident⟩ : ⟨ty⟩ |  …\n⟨epath⟩ := ⟨ident⟩ ⟨ :: ⟨ident⟩ ⟩*\n⟨fields⟩ := ( ⟨ty⟩,* ) | { ⟨ty⟩,* }\n⟨fn_input⟩ := ⟨ident⟩ : &amp;strg ⟨ty⟩ | …\n⟨fn_ret⟩ := ⟨ -&gt; ⟨ty⟩ ⟩?\n⟨fn_sig⟩ := ⟨asyncness⟩ fn ⟨ident⟩? ⟨ [ …\n{ ⟨refine_param⟩ ⟨,⟨refine_param⟩⟩* . ⟨ty⟩ …\n⟨generic_arg⟩ := ⟨ty⟩ | ⟨ident⟩ = ⟨ty⟩\n⟨if_expr⟩ := if ⟨cond⟩ ⟨block_expr⟩ ⟨ else …\n⟨impl_assoc_reft⟩ := fn ⟨ident⟩ ( …\n⟨lit⟩ := “a Rust literal like an integer or a boolean…\n⟨ensures⟩ := ⟨ensures ⟨ensures_clause⟩,*⟩?\n⟨mode⟩ := hrn | hdl\n⟨requires⟩ := ⟨ requires ⟨requires_clause⟩,* ⟩?\n⟨path⟩ := ⟨segments⟩ ⟨ ( ⟨refine_arg⟩,* ) …\n⟨qpath⟩ := &lt; ⟨ty⟩ as ⟨segments⟩&gt; :: …\n⟨refine_arg⟩ :=  @ ⟨ident⟩ |  # ⟨ident⟩ |  …\n⟨refine_param⟩ := ⟨mode⟩? ⟨ident⟩ ⟨ : …\n⟨refined_by⟩ := ⟨refine_param⟩,*\n⟨requires_clause⟩ := ⟨ forall ⟨refine_param⟩,+ . …\n⟨segment⟩ := ⟨ident⟩ ⟨ &lt; ⟨generic_arg⟩,* &gt; …\n⟨segments⟩ := ⟨segment⟩ ⟨:: ⟨segment⟩ ⟩*\n⟨sort⟩ :=  ⟨base_sort⟩ |  ( ⟨base_sort⟩,* ) -&gt; …\n⟨trailer_expr⟩ :=  ⟨epath⟩ . ⟨ident⟩ |  …\n⟨trait_assoc_reft⟩ := fn ⟨ident⟩ ( …\n⟨ty⟩ := _ | { ⟨ident⟩ ⟨,⟨ident⟩⟩* . …\n⟨variant⟩ := ⟨fields⟩ -&gt; ⟨variant_ret⟩ | …\n⟨variant_ret⟩ := ⟨path⟩ ⟨ [ ⟨refine_arg⟩,? ] …\n⟨unary_expr⟩ := - ⟨unary_expr⟩ | ! …\n<code>&lt;qself as path&gt;::name</code>\nA <em>base</em> sort, e.g., <code>int</code> or <code>bool</code>.\nty\n<code>@n</code> or <code>#n</code>, the span corresponds to the span of the …\na bitvector sort, e.g., bitvec&lt;32&gt;\nexample <code>a: i32{a &gt; 0}</code>\nConstrained type: an exists without binder\nB{v: r}\nA <code>Path</code> but for refinement expressions\nA <em>function</em> sort of the form <code>(bi,...) -&gt; bo</code> where <code>bi..</code> and …\nThe <code>NodeId</code> is used to resolve the type to a corresponding …\n<code>B[r]</code>\nA sort that needs to be inferred.\nA literal token.\nA <code>NodeId</code> is a unique identifier we assign to some AST …\nA predicate that needs to hold\nA punctuated sequence of values of type <code>T</code> separated by …\nMutable or shared reference\nA <code>Path</code> but for sorts.\nA compressed span.\nA global function definition. It can be either an …\nexample <code>v: &amp;strg i32</code>\nA type with an optional binder, e.g, <code>i32</code>, <code>x: i32</code> or …\nA type constraint on a location\nThe sort arguments, i.e., the list <code>[int, bool]</code> in …\nBody of the function. If not present this definition …\nReturns true if either this <code>Punctuated</code> is empty, or it has …\nexample: <code>*x: i32{v. v = n+1}</code> or just <code>x &gt; 10</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nBinders are not allowed at this position, but we parse …\nexample: <code>i32&lt;@n&gt;</code>\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDetermines whether this punctuated sequence is empty, …\nWhether the struct contains any path that needs to be …\nWhether the enum contains any path that needs to be …\nOptional list of universally quantified parameters\nAppends a syntax tree node onto the end of this punctuated …\nexample: <code>requires n &gt; 0</code>\nexample <code>i32{v:v &gt;= 0}</code>\nThe segments in the path\nsource span\nDetermines whether this punctuated sequence ends with a …")